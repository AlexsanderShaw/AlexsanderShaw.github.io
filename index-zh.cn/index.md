# 《你管这破玩意叫操作系统源码》系列 -- 01_最开始的两行代码


## 前言

从这一篇开始，您就将跟着我一起进入这操作系统的梦幻之旅！

别担心，每一章的内容会非常的少，而且你也不要抱着很大的负担去学习，只需要像读小说一样，跟着我一章一章读下去就好。

## 正文

当按下开机键的那一刻，在主板上提前写死的固件程序 **BIOS** 会将硬盘中**启动区的 512 字节**的数据，原封不动复制到**内存中的 0x7c00** 这个位置，并跳转到那个位置进行执行。

![image-20211129201140709](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111292011746.png)

启动区的定义非常简单，只要硬盘中的 0 盘 0 道 1 扇区的 512 个字节的最后两个字节分别是 **0x55** 和 **0xaa**，那么 BIOS 就会认为它是个启动区。

所以对于我们理解操作系统而言，此时的 BIOS 仅仅就是个代码搬运工，把 512 字节的二进制数据从硬盘搬运到了内存中而已。**所以作为操作系统的开发人员，仅仅需要把操作系统最开始的那段代码，编译并存储在硬盘的 0 盘 0 道 1 扇区即可**。之后 BIOS 会帮我们把它放到内存里，并且跳过去执行。

而 Linux-0.11 的最开始的代码，就是这个用汇编语言写的 **bootsect.s**，位于 **boot** 文件夹下。

![image-20211129201125519](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111292011546.png)

 通过编译，这个 `bootsect.s` 会被编译成二进制文件，存放在启动区的第一扇区。

![image-20211129201112697](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111292011736.png)

 随后就会如刚刚所说，由 BIOS 搬运到内存的 0x7c00 这个位置，而 CPU 也会从这个位置开始，不断往后一条一条语句无脑地执行下去。

 那我们的梦幻之旅，就从这个文件的第一行代码开始啦！

```assembly
mov ax,0x07c0
mov ds,ax
```

好吧，先连续看两行。

这段代码是用汇编语言写的，含义是把 `0x07c0` 这个值复制到 **ax 寄存器**里，再将 `ax` 寄存器里的值复制到 **ds 寄存器**。那其实这一番折腾的结果就是，让 ds 这个寄存器里的值变成了 0x07c0。

![image-20211129201058974](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111292010011.png)

 ds 是一个 16 位的段寄存器，具体表示数据段寄存器，在内存寻址时充当段基址的作用。啥意思呢？就是当我们之后用汇编语言写一个内存地址时，实际上仅仅是写了偏移地址，比如：

```assembly
mov ax, [0x0001]
```

实际上相当于

```assembly
mov ax, [ds:0x0001]
```

ds 是默认加上的，表示在 ds 这个段基址处，往后再偏移 0x0001 单位，将这个位置的内存数据，复制到 ax 寄存器中。

 形象地比喻一下就是，你和朋友商量去哪玩比较好，你说天安门、南锣鼓巷、颐和园等等，实际上都是**偏移地址**，省略了北京市这个**基址**。

 当然你完全可以说北京天安门、北京南锣鼓巷这样，每次都加上北京这个前缀。不过如果你事先和朋友说好，以下我说的地方都是北京市里的哈，之后你就不用每次都带着北京市这个词了，是不是很方便？

 那 ds 这个数据段寄存器的作用就是如此，方便了描述一个内存地址时，可以省略一个基址，没什么神奇之处。

```text
ds : 0x0001

北京市 : 南锣鼓巷
```

 再看，这个 ds 被赋值为了 0x07c0，由于 x86 为了让自己在 16 位这个实模式下能访问到 20 位的地址线这个历史因素（不了解这个的就先别纠结为啥了），所以段基址要先左移四位。**那 0x07c0 左移四位就是 0x7c00**，那这就刚好和这段代码被 BIOS 加载到的内存地址 0x7c00 一样了。

 也就是说，之后再写的代码，里面访问的数据的内存地址，都先默认加上 0x7c00，再去内存中寻址。

 为啥统一加上 0x7c00 这个数呢？这很好解释，BIOS 规定死了把操作系统代码加载到内存 0x7c00，那么里面的各种数据自然就全都被偏移了这么多，所以把数据段寄存器 ds 设置为这个值，方便了以后通过这种基址的方式访问内存里的数据。

![image-20211129201045645](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111292010677.png)

OK，赶紧消化掉前面的知识，那本篇就到此为止，只讲了两行代码，知识量很少，我没骗你吧。

 希望你能做到，对 BIOS 将操作系统代码加载到内存 0x7c00，以及我们通过 mov 指令将默认的数据段寄存器 ds 寄存器的值改为 0x07c0 方便以后的基址寻址方式，这两件事在心里认可，并且没有疑惑，这才方便后面继续进行。

 后面的世界越来越精彩，欲知后事如何，且听下回分解。



**------- 本回扩展资料 -------**

有关寄存器的详细信息，可以参考 Intel 手册：

Volume 1 Chapter 3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMEN

有关计算机启动部分的原理如果还不清楚，可以看我之前的一篇文章了解一下：

[计算机的启动过程](http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247483867&idx=1&sn=76ece31324d32922a7cb9db129decd3f&chksm=c2c67b76f5b1f260bb459e12c029f8e6a7a813055811ab8ed794a3f36d0d7d50e66df27f4f0a&scene=21#wechat_redirect)

如果想了解计算机启动时详细的初始化过程，还是得参考 Intel 手册：

Volume 3A Chapter 9 PROCESSOR MANAGEMENT AND INITIALIZATION
## 原文地址

[闪客新系列！你管这破玩意叫操作系统源码](https://mp.weixin.qq.com/s/LIsqRX51W7d_yw-HN-s2DA)
语单词不是？
## 原文地址

[闪客新系列！你管这破玩意叫操作系统源码](https://mp.weixin.qq.com/s/U-txDYt0YqLh5EeFOcB4NQ)
刻强行塞到你的脑子里，而是**通过一行一行代码逐渐带入情节**，最终让你不知不觉地发现，原来整个操作系统的体系就这样一点一点建立起来了。

本系列的每一章内容都很短，千万不要有心里负担，而正是这些简单的事情联系到一起，就构成了整个操作系统的复杂的设计。

所以也导致了，单独看任何一章都不会有显著的收获，但如果整个系列都能跟下来，并且每一章的内容都能做出思考，把不懂的地方及时解决，我保证你会对操作系统有一个全新的，深入到细节的认识。

 希望你跟我走完这个系列，也能发出一句感叹，**原来操作系统源码不过如此**，就是这么个**破玩意**而已！

 但同时，你也要有耐心，你不要总想着，读到这了我怎么还是没觉得自己懂操作系统了呢？怎么还是没讲多进程如何调度呢？**记住，享受当下，当下你学的每一个看似没啥用的知识，都是后面豁然开朗这种感觉的基石**。

等等，我记得闪客之前也说要写个自制操作系统系列呢？不过好像...

 

**万一中途又鸽了怎么办**

 话说回来，我的老读者有点惨，之前总是看我信誓旦旦说要写操作系统的系列，但无一例外都是中途失败了。

 博客园上写过，公众号上也写过，而公众号里的好多读者就是被我的自制操作系统系列骗进来的，然后写到第五章我就鸽了，实在太过分了！

 所以接下来自然就有一个大家都关心的问题了，就是这次会不会又鸽呢？

 我可以肯定的是，这次绝对绝对绝对绝对绝对绝对不会中途鸽了！**因为我此时此刻已经把全部的大纲以及文章的前 33 章的内容写好了，就藏在我的石墨文档里。后面的内容我打算根据前面的反馈和问答，不断做出调整**。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111291132647)

没错，总共我计划分**六大部分**，**前四部分**你会看到从开机一直到操作系统的最后一行代码的全部主流程，**第五部分**将通过一个命令的执行将操作系统各个模块的运作方式串一遍，而**第六部分**会做一个思想的拔高，这也是我自己给自己挖的一个坑和挑战。

 而六大部分对应到 Linux 0.11 源码从开机到 shell 的流程图，是这样的。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111291133632)

 其实本可以早早就开始边写边发布，但想着要是这次中途又鸽了读者，着实有点不好意思。所以就冒着中途写不下去的风险，先把大部分文章提前写好。

 但我也给自己留了个后路，就是只提前写了 33 章，也够大家看好几个月了，要是大家不捧场，我后面就不更了，哼（傲娇表情.gif）！

 提前写好有个好处，就是写到后面的时候，发现前面有些地方可以提前做个引子，这样整个系列就更完整了，可以**前后呼应**，可读性和收获也会大大增加。

**如何互动**

虽然已经提前写好，但中途还是要不断接受读者反馈和答疑，以便更好修正文章的内容，并且做一些知识点的补充，这也是我对自己的要求和考验。

所以建立**微信群**增加互动性。

在这里你可以不断对文章内容提出**反馈意见**，以及和不同读者进行**心得交流**，以及进行**催更呐喊**。不要觉得你的意见无法左右这个系列，要知道，这个系列的名称就是低并发编程读者群的读者们群体的智慧想出来的。

我觉得这也是公众号里更新系列的一个优势，就是与读者的距离更近，更方便随时讨论和交流，互相促进成长。

 加入方式是加我微信好友，备注

```shell
os-昵称-其他信息

比如

os-闪客-Java
```

我会将所有备注为本格式的好友邀请至微信群。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202111291130700)

一定要按备注要求来哦~

**我是华丽的分割线**

好了！本篇文章就当做开篇词，今后不出意外至少**每周一周四**更新，每一个大部分结束后会看情况留一段时间集中消化与总结。

不过会以文章质量和准确性为主，不会带着问题强行按时更新的。

本系列**完全免费**，直到所有章节全部结束，所以你们的喜欢和传播就是对我最大的支持，可以**星标**我的公众号防止错过更新提醒。

公众号虽然与读者距离更近，但它却是个封闭的空间，平台和搜索引擎不会主动向外扩散，所以如果没有人主动帮忙传播，会一直限制在公众号粉丝的圈子里，越到后面看的人也会越少。

这也是很多公众号系列中途腰斩的因素之一，所以还是希望大家喜欢这个系列的话，可以多多帮忙传播，比如**朋友圈打打卡**，或者如果你也写博客的话，**文章里提提我**，都是可以帮到这个系列活下去的重要途径，在此多谢各位捧场啦！

同时我也会在 **GitHub** 上进行同步，因为公众号文章发了之后就无法修改，也没法进行整体调整。感兴趣的也可以点击**阅读原文**进入 GitHub。但我同步应该不会很及时，还是以公众号为主战场，毕竟时间和精力有限。

那就让我们一起期待吧！

## 原文地址

[闪客新系列！你管这破玩意叫操作系统源码](https://mp.weixin.qq.com/s/tvbkGLfhDq03xxM-FZ4zuA)
