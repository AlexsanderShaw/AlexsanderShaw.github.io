[{"categories":["Fuzz"],"content":"Fuzzing 101 系列 note 8","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Fuzz"],"content":"本文是Fuzzing101系列第八篇，fuzz的对象为 Adobe Reader 。 ","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/:0:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Fuzz"],"content":"1. Basic Info 一个 OOB read vulneratibily. ","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/:1:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Fuzz"],"content":"2. Learning Target 使用 AFL++ 的 QEMU 模式来对闭源软件进行 fuzz 在 QEMU 模式下开启 persistent mode 练习如何使用 QASAN ，一个二进制层面的 sanitizer ","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/:2:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Fuzz"],"content":"3. Fuzzing ","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/:3:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Fuzz"],"content":"1. Workflow 安装 AFL++ 的 QEMU 创建一个 PDF 的语料库 开启 persistent mode 使用 QEMU 模式对 Adobe Reader 进行 fuzz，直到出现crash 使用造成crash的poc重现crash 修复漏洞 ","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/:3:1","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Fuzz"],"content":"2. Solution 1. Download and build target 首先安装 AFL++ 的 QEMU 模式，使用下面的命令来进行检测是否安装： afl-qemu-trace --help 这种显示表明已经安装成功了。如果不能，则需要额外安装： sudo apt install ninja-build libc6-dev-i386 cd ~/Desktop/v4ler1an/AFLplusplus/qemu_mode/ CPU_TARGET=i386 ./build_qemu_support.sh make distrib sudo make install 然后安装 Adobe Reader ： # install dependencies sudo apt-get install libxml2:i386 # download and uncompress wget ftp://ftp.adobe.com/pub/adobe/reader/unix/9.x/9.5.1/enu/AdbeRdr9.5.1-1_i386linux_enu.deb # install sudo dpkg -i AdbeRdr9.5.1-1_i386linux_enu.deb 安装完成后，检测是否成功： /opt/Adobe/Reader9/bin/acroread 安装成功后会出现如下信息： 2. Seed corpus creation 从 SafeDocs “Issue Tracker” 下载语料，或者从这里使用更多的 PDF 语料。 # download and uncompress wget https://corpora.tika.apache.org/base/packaged/pdfs/archive/pdfs_202002/libre_office.zip unzip libre_office.zip -d extracted 这里因为 PDF 格式的文件一般会比较大，所以我们先筛选小于 2KB 的文件来加快 fuzz 速度： mkdir -p $HOME/Desktop/Fuzz/training/fuzzing_adobereader/afl_in find ./extracted -type f -size -2k \\ -exec cp {} $HOME/Desktop/Fuzz/training/fuzzing_adobereader/afl_in \\; 3. Fuzzing 这里在执行 fuzz 时，有两种方式： 第一种是直接使用 -Q 选项开启 QEMU mode。 这里有一个需要注意的问题，因为前面运行的 /opt/Adobe/Reader9/bin/acroread 是一个 shell 脚本，并不是实际的二进制文件。真正的二进制文件是 /opt/Adobe/Reader9/Reader/intellinux/bin/acroread。这里需要设置一下两个环境变量：ACRO_INSTALL_DIR 和 ACRO_CONFIG。然后， 通过 LD_LIBRARY_PATH 指定加载共享库的路径。所以最终执行的 fuzz 命令如下： ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:'/opt/Adobe/Reader9/Reader/intellinux/lib' afl-fuzz -Q -i ./afl_in/ -o ./afl_out/ -t 2000 -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript @@ 但是这种方式很慢，我们需要想办法提升 fuzz 速度。 第二种就是使用 AFL 的 persistent 模式。这种模式可以用在有源码的情况下，也可以用在只有二进制文件的情况下。在有源码时，我们可以直接在源码的合适的位置插入如下代码来实现 persistent 模式： while(__AFL_LOOP(10000)){ /* Read input data. */ /* Call library code to be fuzzed. */ /* Reset state. */ } 对于 persistent 模式的详细介绍可以阅读这里。 而对于只有二进制文件的情况，整体思路上是一样的，也是找到合适的位置设置循环。分析二进制文件的函数地址可以使用常规的 IDA 等工具进行反编译来获取，这里使用一种简单的工具 —— valgrind。我们使用其中的 callgrind 来分析程序运行的时间和调用过程，来判断合适的位置： sudo apt-get install valgrind sudo apt-get install kcachegrind 然后，使用下面的命令来生成一个 callgrind report： ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=/opt/Adobe/Reader9/Reader/intellinux/lib valgrind --tool=callgrind /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript [samplePDF] 上述命令会在当前目录下生成一个 callgrind.out 文件，然后使用 kcachegrind 来读取： kcachegrind 读取出的信息如下： 这里我们选择地址 0x08546a00 。选择的原则是尽可能选择那些只执行了一次，并且可以使得 AFL++ 的 stability 值能在 90% 以上的地址。所以使用的命令为： AFL_QEMU_PERSISTENT_ADDR=0x08546a00 ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=$LD_LIBRARY_PATH:'/opt/Adobe/Reader9/Reader/intellinux/lib' afl-fuzz -Q -i ./afl_in/ -o ./afl_out/ -t 2000 -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript @@ 我们指定了变量 AFL_QEMU_PERSISTENT_ADDR 为上面选择的地址。这次的fuzz速度会有提升： ","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/:3:2","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Fuzz"],"content":"3. Triage 在发生 crash 之后，我们来检测这个 OOB read 漏洞： ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=opt/Adobe/Reader9/Reader/intellinux/lib /usr/local/bin/afl-qemu-trace -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript [crashFilePath] 如果按照上面的常规的命令来执行 trace，会报页错误。所以我们使用另外一种方法—— QASAN AFL_USE_QASAN=1 ACRO_INSTALL_DIR=/opt/Adobe/Reader9/Reader ACRO_CONFIG=intellinux LD_LIBRARY_PATH=opt/Adobe/Reader9/Reader/intellinux/lib /usr/local/bin/afl-qemu-trace -- /opt/Adobe/Reader9/Reader/intellinux/bin/acroread -toPostScript [crashFilePath] 然后就能看到触发的 stacktrace： ","date":"2022-01-16","objectID":"/2022/01/fuzzing101-8/:4:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 8","uri":"/2022/01/fuzzing101-8/"},{"categories":["Life"],"content":"记录一下我与看雪的那些事儿","date":"2021-12-31","objectID":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/","tags":["Life"],"title":"我与看雪的故事","uri":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["Life"],"content":"大家好，我是有毒，一个二进制安全学习的“小学生”。今天是2021年的最后一天，我加入看雪已经5年了，突然想写点技术无关的东西，记录一下与看雪的故事。饭后闲谈，看官们文了话终。 ","date":"2021-12-31","objectID":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/:0:0","tags":["Life"],"title":"我与看雪的故事","uri":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["Life"],"content":"初次相遇 – 惊喜 2017年12月25日，圣诞节这天，我注册了看雪。其实在这之前，也有听到过论坛。因为个人非常喜欢雪，所以当时的第一感觉是，名字真好听，应该是一个感情丰富的文艺青年创建的个人博客吧。当我打开论坛的时候，感受到了仿佛打开新世界一样的惊喜。 其实当时我还没有从事安全方向，主要聚焦在开发上，所以也有关注一些开发类的论坛。但是看到看雪的第一眼，我就觉得我应该会持续关注它了，不为别的，只为名字和干货。看了大家的文章之后，能感觉出来，这些优秀的作者都是简单、纯粹的技术人员，和我相性很合。但是我并不是搞安全的，所以很多技术层面的内容看不懂，但是字里行间还是能感受到作者想要表达的心情，真的是很单一、热情的分享的喜悦的心情。 我注册了看雪的账号，起名字的时候想了半天，不知道叫什么。我看论坛里大家都是Leet风格（当时还不知道这种风格）的名称，想的就是自己起一个英文名字。但是当时的英文名字纯粹是实习的时候公司内部使用的，只是为了外语业务使用的，个人并不是特别喜欢。想来想去，还是沿用了之前小伙伴一直喜欢叫的名字 – 有毒。因为他们总说我有毒，说什么就命中什么，跟预言家一样，大部分都是坏的，所以不叫预言家，而是有毒。后来想想，或许我英文名字可以叫Murphy（墨菲定律嘛）。 就这样，有毒加入了看雪。 ","date":"2021-12-31","objectID":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/:1:0","tags":["Life"],"title":"我与看雪的故事","uri":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["Life"],"content":"逐渐融入 – 学习 本科的时候，实习期间去找了一份.NET开发的工作，干了有4个月吧，我觉得我可能对自己有错误的认知。并不是不喜欢这个技术方向，而是我觉得我视野不够宽，看到的东西太少，会影响你的一些决策。我毅然辞职去考研了。 上了研究生选导师的时候，首选还是软开的，但是无意间有个做安全的导师联系我希望能当面聊一下，然后我就入坑了。在这期间，我开始从0学起安全方向，也是在这期间，我注册了看雪。然后，开始在上面跟着学习。 我刚开始是不敢发帖子的，因为我觉得我水平不够，发出来的东西都是浅显，没有干货，所以绝大部分时间都是看上面的文章学习。看雪有个我至今觉得都很厉害的内容——知识库。这简直是开源的二进制安全的百科全书，想学的内容基本全覆盖，我由衷佩服当时就有这种知识库想法的设计者。 学习期间也有迷茫，尤其是我这种直接进入二进制世界的人。当时周围的人都是web出发，只有我自己是直接进入的二进制，就很孤独。所以我的第一、第二个帖子都是关于这种方向类的选择犹豫。其中有个回答很好地解决了我这个问题： 我很感谢这位“雪人”的答复（如果本人觉得放这里不合适，请联系我删除）。正是他的这几句话，帮助我坚定了自己的决心。从他的介绍出发，我自己google了两个大方向的细节内容，觉得自己的性子可能还是适合二进制，而且也享受那种偏底层一点的分析的过程和感觉。 再后来，就是稳扎稳打地慢慢学，跟着看雪知识库，跟着论坛上大牛的帖子，跟着《加解密》和《0day》，中间顺道去打打CTF，扩展一下知识面（我发现我个人真的不适合CTF，玩不来，虽然很喜欢-。-），重心还是在论文上（我导师的论文要求太高了，没办法）。 论文完成之后，我就去了实习。当时觉得自己水平不够，除了论文中开发的一个框架，其他什么成果也没有，CTF也没有成绩，所以没想到能成功。很感谢当时面试我的那位架构师大佬，虽然他本意是想招一个安全开发，但最后还是收下了我，只是没有进他的组，而是去了漏洞组。然后我就开始了我觉得成长最快的一段时间，终于在2019年的4月5日，我发了我在看雪的第一篇技术文章——《Windows SMB协议简单分析》，BDomne版主还给了优秀贴。虽然这文章现在看来很水，但是当时真的十分开心。我觉得我一直在从看雪、从其他人手里“拿”东西，现在也能给出一些回报了。抱着这种心情，在2019年，也产出了一些其他文章，但是现在看来当时的自己水平真的一般，大部分是一些比较简陋的漏洞分析和简单的CTF题解。我意识到自己和论坛里精华帖大牛们的差距，同时发现自己有点浮躁了，决定自我沉淀一下。期间参加了2019年的SDC，属于是第一次参加的安全方向线下会议。我当时的想法有两个，一个是觉得自己加入看雪是对的，一个是想的总有一天我也要上去分享一次。 在2020年，我告诉自己，如果是技术帖，一定要发精华帖，宁缺毋滥。我希望发出来的文章是真的有内容在里面，有能得到大佬们认可的技术能力在里面，感觉这样才是跟看雪初衷、跟当时进入看雪的我的初衷相一致的。2020年分析了很多的漏洞，把自己的一些分析成果沉淀到了论坛里。在这一年，做到了每个帖子都是精华帖（有一些现在看来是有欠缺的，当时文档能力不稳定，很多想表达的东西没有表达清楚）。年终的时候，被评为了看雪2020年的年度新人。这期间，继续参加了看雪2020的SDC。我实力仍然不够，当不了演讲嘉宾。但是，我个人觉得，2020年才是我真正为看雪做出点东西的一年。 2021年的1月19号，我申请了看雪论坛二进制漏洞板块的版主。但是跟段哥聊了很久，我的本意是除了文章之外，我想为看雪做一点其他的贡献，但是对自己的能力缺乏信心。段哥当时给了我很大的鼓舞，让我很触动。成为版主后，将自己之前总结的一份相对比较全面的二进制漏洞分析文档的模板共享了出来。虽然我们不强调固定的套版思路，但是在文档编写上，我个人感觉还是规范化更好一点。然后总结了一份二进制漏洞分析的脑图，参考大家的意见进行了几次优化，当作给和当初的我一样的新人们的一份参考。我日常会审核一些板块的帖子。起初，是有一些吃力的，因为审核一篇帖子需要花费的时间还是很久的，对于一些技术点可能你之前根本没有涉及过，需要查资料或者请教朋友去共同审核。发出来的文章都是大家辛苦编写的，我觉得还是需要十分慎重对待的，要对得起作者的辛苦付出。文章审核的工作，让我见到了更多的技术大佬，也让我学习到了很多。2021年的SDC，也有参加，但是因为时间问题，没能参加最后的看雪闭门聚餐，是十分遗憾的，感谢段哥的邀请吧，希望明年的SDC我可以带着议题去。2021年文章产出数量下降了，主要是换了新方向，还在摸索阶段，有些东西太敏感不能发，有些东西技术含量不够不值得发，所以导致文章数量下降，但是质量我还是可以保证的，希望2022年可以再来一次爆发吧。 ","date":"2021-12-31","objectID":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/:2:0","tags":["Life"],"title":"我与看雪的故事","uri":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["Life"],"content":"冥冥之中的缘分 总觉得和看雪有一种冥冥之中的缘分，因为研究生阶段的研究方向是内存取证，基本是纯二进制的内容，所以我没有接触过多的web安全，这刚好跟看雪论坛的主要内容一致，所以就很对味。再然后开始买《加解密》、《0day》来看，发现这两本书还是跟看雪有很大的渊源。我当时真的欣喜若狂。因为看雪是我全自主发现的，自己探索到的，恰好就是我的研究方向相关的，也是我个人感兴趣的。我觉得这对我来说是一种很大的缘分，也是一种很大的幸运。试想一下当时如果没有看雪论坛，没有知识库，没有每年的看雪精华合集，没有论坛里每位技术大佬的无私分享，作为新一辈的二进制安全学习人员可能并不能很好地建立全面的二进制安全体系，并不能结识到圈里这些安全前辈，如果真的这样，我真心觉得是一种遗憾。 ","date":"2021-12-31","objectID":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/:3:0","tags":["Life"],"title":"我与看雪的故事","uri":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["Life"],"content":"一直走下去 现在，知识付费的风潮正劲。不知道是环境问题，还是发展到今天就必定要经历这个阶段，大家开始浮躁了，开始急功近利，开始什么事情都开始跟利益挂钩。新声代不乏技术牛人，但是还秉持着初心的，我感觉太少了。这是我们跟安全老前辈们的差距。看着好多人有一点成绩后开始各种渠道去割韭菜、圈钱，我就想到在刚进入看雪的时候，看雪给我的那种纯净的感觉。至今为止，看雪论坛本身没有靠文章去赚钱，没有付费注册会员、没有付费查看文章，每年的服务器架设、网站运营其实花销也很大。看雪论坛的“雪人”们也继续在无私奉献着自己的学习成果、研究成果，我衷心觉得看雪是纯净的、“雪人”们是可爱的。 话有点多了，简单总结下吧。人世纷乱，出入平安。希望有毒能跟着看雪继续走下去，希望喜欢看雪的大家，能跟着看雪继续走下去。往往悠然心不乱，琅琅天乐自来迎。 ","date":"2021-12-31","objectID":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/:4:0","tags":["Life"],"title":"我与看雪的故事","uri":"/2021/12/%E6%88%91%E4%B8%8E%E7%9C%8B%E9%9B%AA%E7%9A%84%E6%95%85%E4%BA%8B/"},{"categories":["LINUX"],"content":"闪客Linux操作系统系列第八篇","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"Peach Fuzzer Professional本文是Linux 0.11系列学习记录的正式的第八篇。 从本篇开始，正式进入第二部分，从 main 函数开始。 ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:0:0","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"11. main.c 的初步理解 在经过前面 10 回的操作后，进去 main 函数之前的工作都已完成，接下来就是操作系统的全部代码骨架的地方 —— main 函数。 void main(void) /* 这里确实是void，并没错。 */ { /* 在startup 程序(head.s)中就是这样假设的。 */ /* * 此时中断仍被禁止着，做完必要的设置后就将其开启。 */ // 下面这段代码用于保存： // 根设备号 -\u003e ROOT_DEV； 高速缓存末端地址 -\u003e buffer_memory_end； // 机器内存数 -\u003e memory_end；主内存开始地址 -\u003e main_memory_start； ROOT_DEV = ORIG_ROOT_DEV; drive_info = DRIVE_INFO; memory_end = (1\u003c\u003c20) + (EXT_MEM_K\u003c\u003c10);// 内存大小=1Mb 字节+扩展内存(k)*1024 字节。 memory_end \u0026= 0xfffff000; // 忽略不到4Kb（1 页）的内存数。 if (memory_end \u003e 16*1024*1024) // 如果内存超过16Mb，则按16Mb 计。 memory_end = 16*1024*1024; if (memory_end \u003e 12*1024*1024) // 如果内存\u003e12Mb，则设置缓冲区末端=4Mb buffer_memory_end = 4*1024*1024; else if (memory_end \u003e 6*1024*1024) // 否则如果内存\u003e6Mb，则设置缓冲区末端=2Mb buffer_memory_end = 2*1024*1024; else buffer_memory_end = 1*1024*1024;// 否则则设置缓冲区末端=1Mb main_memory_start = buffer_memory_end;// 主内存起始位置=缓冲区末端； #ifdef RAMDISK // 如果定义了虚拟盘，则主内存将减少。 main_memory_start += rd_init(main_memory_start, RAMDISK*1024); #endif // 以下是内核进行所有方面的初始化工作。阅读时最好跟着调用的程序深入进去看，实在看 // 不下去了，就先放一放，看下一个初始化调用-- 这是经验之谈:) mem_init(main_memory_start,memory_end); trap_init(); // 陷阱门（硬件中断向量）初始化。（kernel/traps.c） blk_dev_init(); // 块设备初始化。（kernel/blk_dev/ll_rw_blk.c） chr_dev_init(); // 字符设备初始化。（kernel/chr_dev/tty_io.c）空，为以后扩展做准备。 tty_init(); // tty 初始化。（kernel/chr_dev/tty_io.c） time_init(); // 设置开机启动时间 -\u003e startup_time。 sched_init(); // 调度程序初始化(加载了任务0 的tr, ldtr) （kernel/sched.c） buffer_init(buffer_memory_end);// 缓冲管理初始化，建内存链表等。（fs/buffer.c） hd_init(); // 硬盘初始化。（kernel/blk_dev/hd.c） floppy_init(); // 软驱初始化。（kernel/blk_dev/floppy.c） sti(); // 所有初始化工作都做完了，开启中断。 // 下面过程通过在堆栈中设置的参数，利用中断返回指令切换到任务0。 move_to_user_mode(); // 移到用户模式。（include/asm/system.h） if (!fork()) { /* we count on this going ok */ init(); } /* * 注意!! 对于任何其它的任务，'pause()'将意味着我们必须等待收到一个信号才会返 * 回就绪运行态，但任务0（task0）是唯一的意外情况（参见'schedule()'），因为任 * 务0 在任何空闲时间里都会被激活（当没有其它任务在运行时）， * 因此对于任务0'pause()'仅意味着我们返回来查看是否有其它任务可以运行，如果没 * 有的话我们就回到这里，一直循环执行'pause()'。 */ for(;;) pause(); } // end main 其中的代码部分也就 20 几行，接下来我们拆分来看整个的 main 函数。 ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:1:0","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"1. 第一部分，参数的取值和计算 // 下面这段代码用于保存： // 根设备号 -\u003e ROOT_DEV； 高速缓存末端地址 -\u003e buffer_memory_end； // 机器内存数 -\u003e memory_end；主内存开始地址 -\u003e main_memory_start； ROOT_DEV = ORIG_ROOT_DEV; drive_info = DRIVE_INFO; // 之前在汇编语言中获取的各个设备的参数信息 memory_end = (1\u003c\u003c20) + (EXT_MEM_K\u003c\u003c10);// 内存大小=1Mb 字节+扩展内存(k)*1024 字节。 memory_end \u0026= 0xfffff000; // 忽略不到4Kb（1 页）的内存数。 if (memory_end \u003e 16*1024*1024) // 如果内存超过16Mb，则按16Mb 计。 memory_end = 16*1024*1024; if (memory_end \u003e 12*1024*1024) // 如果内存\u003e12Mb，则设置缓冲区末端=4Mb buffer_memory_end = 4*1024*1024; else if (memory_end \u003e 6*1024*1024) // 否则如果内存\u003e6Mb，则设置缓冲区末端=2Mb buffer_memory_end = 2*1024*1024; else buffer_memory_end = 1*1024*1024;// 否则则设置缓冲区末端=1Mb main_memory_start = buffer_memory_end;// 主内存起始位置=缓冲区末端； #ifdef RAMDISK // 如果定义了虚拟盘，则主内存将减少。 main_memory_start += rd_init(main_memory_start, RAMDISK*1024); #endif 设备参数信息来自 setup.s 汇编程序调用 BIOS 中断获取的各个设备的信息，并保存在约定好的内存地址 0x90000 处，如下表所示： 上面的内存变量则指明了主内存的开始地址、系统所拥有的内存容量和作为高速缓冲区内存的末端地址。而且如果还定义了虚拟盘（RAM DISK），主内存还会适当减少。 ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:1:1","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"2. 第二部分，各种初始化 init 操作 内核进行所有方面的硬件初始化工作，包括陷阱门、块设备、字符设备和 tty，还包括人工设置第一个任务（task 0）。所有的初始化工作完成后，程序就设置中断允许标志以开启中断，并切换到任务 0 中进行。在阅读这些初始化子程序时，最好跟着被调用的程序深入进去看，实在看不下去了，就先放放，然后看下一个，在有些理解之后再继续研究没有看懂的地方。 mem_init(main_memory_start,memory_end); trap_init(); // 陷阱门（硬件中断向量）初始化。（kernel/traps.c） blk_dev_init(); // 块设备初始化。（kernel/blk_dev/ll_rw_blk.c） chr_dev_init(); // 字符设备初始化。（kernel/chr_dev/tty_io.c）空，为以后扩展做准备。 tty_init(); // tty 初始化。（kernel/chr_dev/tty_io.c） time_init(); // 设置开机启动时间 -\u003e startup_time。 sched_init(); // 调度程序初始化(加载了任务0 的tr, ldtr) （kernel/sched.c） buffer_init(buffer_memory_end);// 缓冲管理初始化，建内存链表等。（fs/buffer.c） hd_init(); // 硬盘初始化。（kernel/blk_dev/hd.c） floppy_init(); // 软驱初始化。（kernel/blk_dev/floppy.c） sti(); // 所有初始化工作都做完了，开启中断。 ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:1:2","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"3. 第三部分，切换到用户态 在完成各种初始化后，切换到用户态模式，并在新的进程中做最终的初始化 —— init。 // 下面过程通过在堆栈中设置的参数，利用中断返回指令切换到任务0。 move_to_user_mode(); // 移到用户模式。（include/asm/system.h） if (!fork()) { /* we count on this going ok */ init(); } init() 函数会创建一个进程，设置终端的标准 IO，然后再创建出一个执行 shell 程序的进程来接收用户的命令，此时就会出现如下画面： 在整个内核完成初始化后，内核将执行权切换到了用户模式，也即 CPU 从 0 特权级切换到了第 3 特权级。此时 main.c 的主程序就工作在任务 0 中，然后系统第一次调用进程创建函数 fork()，创建出一个用于运行 init() 的子进程。系统的整个初始化过程如下图所示： ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:1:3","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"4. 第四部分，设置无限循环 /* * 注意!! 对于任何其它的任务，'pause()'将意味着我们必须等待收到一个信号才会返 * 回就绪运行态，但任务0（task0）是唯一的意外情况（参见'schedule()'），因为任 * 务0 在任何空闲时间里都会被激活（当没有其它任务在运行时）， * 因此对于任务0'pause()'仅意味着我们返回来查看是否有其它任务可以运行，如果没 * 有的话我们就回到这里，一直循环执行'pause()'。 */ for(;;) pause(); ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:1:4","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"5. 阶段总结 到此为止，我们对 main.c 的整体就有了全面的认识，对于其中的细节我们会在接下来的过程中详细分析。 截止到目前为止的内存布局如下： 在接下来的操作中，操作系统会在上面的内存布局中建立各种数据结构及其调用。 我们目前已完成的工作如下： 前面所有工作的重心就是三张表的设置：全局描述符表、中断描述符表、页表。同时还设置了各种段寄存器，栈顶指针。并且，还为后续的程序提供了设备信息，保存在 0x90000 处往后的几个位置上。 ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:1:5","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"6. 参考链接 第十一回 整个操作系统就 20 几行代码 《Linux 内核完全剖析》第7章 ","date":"2021-12-24","objectID":"/2021/12/linux-0.11-08/:1:6","tags":["Linux","kernel"],"title":"Linux-0.11-08","uri":"/2021/12/linux-0.11-08/"},{"categories":["LINUX"],"content":"闪客Linux操作系统系列第七篇","date":"2021-12-20","objectID":"/2021/12/linux-0.11-07/","tags":["Linux","kernel"],"title":"Linux-0.11-07","uri":"/2021/12/linux-0.11-07/"},{"categories":["LINUX"],"content":"Peach Fuzzer Professional本文是Linux 0.11系列学习记录的正式的第七篇。 从本篇开始，在每篇文章中会加入自己的理解和补充，各位可按需查看。 ","date":"2021-12-20","objectID":"/2021/12/linux-0.11-07/:0:0","tags":["Linux","kernel"],"title":"Linux-0.11-07","uri":"/2021/12/linux-0.11-07/"},{"categories":["LINUX"],"content":"10 进入 main.c 在前面我们已经设置了idt、gdt、页表等，并且开启了保护模式，接下来就准备进入 main.c 。 我们前面有提到，在下面的代码处准备跳转到 main.c： after_page_tables: push 0 push 0 push 0 push L6 push _main jmp setup_paging ... setup_paging: ... ret 在经过连续的 5 个 push 操作之后，内存栈变成如下形式： 然后，setup_paging 最后一个指令是 ret，也就是我们上一回讲的设置分页的代码的最后一个指令，形象地说它叫返回指令，但 CPU 可没有那么聪明，它并不知道该返回到哪里执行，只是很机械地把栈顶的元素值当做返回地址，跳转去那里执行。 再具体说是，把 esp 寄存器（栈顶地址）所指向的内存处的值，赋值给 eip 寄存器，而 cs:eip 就是 CPU 要执行的下一条指令的地址。而此时栈顶刚好是 main.c 里写的 main 函数的内存地址，是我们刚刚特意压入栈的，所以 CPU 就理所应当跳过来了。 当然 Intel CPU 是设计了 call 和 ret 这一配对儿的指令，意为调用函数和返回，具体可以看后面本回扩展资料里的内容。 至于其他压入栈的 L6 是用作当 main 函数返回时的跳转地址，但由于在操作系统层面的设计上，main 是绝对不会返回的，所以也就没用了。而其他的三个压栈的 0，本意是作为 main 函数的参数，但实际上似乎也没有用到，所以也不必关心。 总之，经过这一个小小的骚操作，程序终于跳转到 main.c 这个由 c 语言写就的主函数 main 里了。 void main(void) /* 这里确实是void，并没错。 */ { /* 在startup 程序(head.s)中就是这样假设的。 */ /* * 此时中断仍被禁止着，做完必要的设置后就将其开启。 */ // 下面这段代码用于保存： // 根设备号 -\u003e ROOT_DEV； 高速缓存末端地址 -\u003e buffer_memory_end； // 机器内存数 -\u003e memory_end；主内存开始地址 -\u003e main_memory_start； ROOT_DEV = ORIG_ROOT_DEV; drive_info = DRIVE_INFO; memory_end = (1\u003c\u003c20) + (EXT_MEM_K\u003c\u003c10);// 内存大小=1Mb 字节+扩展内存(k)*1024 字节。 memory_end \u0026= 0xfffff000; // 忽略不到4Kb（1 页）的内存数。 if (memory_end \u003e 16*1024*1024) // 如果内存超过16Mb，则按16Mb 计。 memory_end = 16*1024*1024; if (memory_end \u003e 12*1024*1024) // 如果内存\u003e12Mb，则设置缓冲区末端=4Mb buffer_memory_end = 4*1024*1024; else if (memory_end \u003e 6*1024*1024) // 否则如果内存\u003e6Mb，则设置缓冲区末端=2Mb buffer_memory_end = 2*1024*1024; else buffer_memory_end = 1*1024*1024;// 否则则设置缓冲区末端=1Mb main_memory_start = buffer_memory_end;// 主内存起始位置=缓冲区末端； #ifdef RAMDISK // 如果定义了虚拟盘，则主内存将减少。 main_memory_start += rd_init(main_memory_start, RAMDISK*1024); #endif // 以下是内核进行所有方面的初始化工作。阅读时最好跟着调用的程序深入进去看，实在看 // 不下去了，就先放一放，看下一个初始化调用-- 这是经验之谈:) mem_init(main_memory_start,memory_end); trap_init(); // 陷阱门（硬件中断向量）初始化。（kernel/traps.c） blk_dev_init(); // 块设备初始化。（kernel/blk_dev/ll_rw_blk.c） chr_dev_init(); // 字符设备初始化。（kernel/chr_dev/tty_io.c）空，为以后扩展做准备。 tty_init(); // tty 初始化。（kernel/chr_dev/tty_io.c） time_init(); // 设置开机启动时间 -\u003e startup_time。 sched_init(); // 调度程序初始化(加载了任务0 的tr, ldtr) （kernel/sched.c） buffer_init(buffer_memory_end);// 缓冲管理初始化，建内存链表等。（fs/buffer.c） hd_init(); // 硬盘初始化。（kernel/blk_dev/hd.c） floppy_init(); // 软驱初始化。（kernel/blk_dev/floppy.c） sti(); // 所有初始化工作都做完了，开启中断。 // 下面过程通过在堆栈中设置的参数，利用中断返回指令切换到任务0。 move_to_user_mode(); // 移到用户模式。（include/asm/system.h） if (!fork()) { /* we count on this going ok */ init(); } /* * 注意!! 对于任何其它的任务，'pause()'将意味着我们必须等待收到一个信号才会返 * 回就绪运行态，但任务0（task0）是唯一的意外情况（参见'schedule()'），因为任 * 务0 在任何空闲时间里都会被激活（当没有其它任务在运行时）， * 因此对于任务0'pause()'仅意味着我们返回来查看是否有其它任务可以运行，如果没 * 有的话我们就回到这里，一直循环执行'pause()'。 */ for(;;) pause(); } // end main 整个OS会最终停留在最后一行的死循环中，永不返回，直到关机。 至此，进入 main 函数的准备工作已经全部完成了，前面我们做的所有工作如下： 此时的内存布局如下： 然后进入到 main 函数中继续执行。 ","date":"2021-12-20","objectID":"/2021/12/linux-0.11-07/:1:0","tags":["Linux","kernel"],"title":"Linux-0.11-07","uri":"/2021/12/linux-0.11-07/"},{"categories":["LINUX"],"content":"第一部分总结 截止到这一篇位置，第一部分已经全部完成，在进入 main.c 之前的所有工作都已经完成，接下来的运行就开始运行 main 函数了。 由于这一部分大部分都是在和 Intel CPU 打交道，所以参考资料大部分是 Intel 手册： ","date":"2021-12-20","objectID":"/2021/12/linux-0.11-07/:2:0","tags":["Linux","kernel"],"title":"Linux-0.11-07","uri":"/2021/12/linux-0.11-07/"},{"categories":["LINUX"],"content":"闪客Linux操作系统系列第六篇","date":"2021-12-14","objectID":"/2021/12/linux-0.11-06/","tags":["Linux","kernel"],"title":"Linux-0.11-06","uri":"/2021/12/linux-0.11-06/"},{"categories":["LINUX"],"content":"Peach Fuzzer Professional本文是Linux 0.11系列学习记录的正式的第六篇。 从本篇开始，在每篇文章中会加入自己的理解和补充，各位可按需查看。 ","date":"2021-12-14","objectID":"/2021/12/linux-0.11-06/:0:0","tags":["Linux","kernel"],"title":"Linux-0.11-06","uri":"/2021/12/linux-0.11-06/"},{"categories":["LINUX"],"content":"09 Intel 的内存管理：分段与分页 上文说到 head.s 代码在重新设置了 gdt 和 idt 之后，此时的内存分布如下： 然后待执行的代码如下： jmp after_page_tables ... after_page_tables: push 0 push 0 push 0 push L6 ; 模拟调用 mainc.c 程序时首先将返回地址入栈的操作，main.c退出时，会返回到 L6，从而进入死循环 push _main ; main.c 地址入栈，这样在设置分页处理结束后，执行 ret 时会将 main.c 地址 pop 出来，从而去执行 main.c jmp setup_paging L6: jmp L6 ","date":"2021-12-14","objectID":"/2021/12/linux-0.11-06/:1:0","tags":["Linux","kernel"],"title":"Linux-0.11-06","uri":"/2021/12/linux-0.11-06/"},{"categories":["LINUX"],"content":"1. 分页机制 在前面有介绍，在保护模式下，要先经过分段机制的转换才能变成物理地址： 在没有开启分页的时候，分段机制回顾： 分段机制涉及的4个关键内容：逻辑地址、段描述符（描述段的属性）、段描述符表（包含多个段描述符的“数组”）、段选择子（段寄存器，用于定位段描述符表中表项的索引）。 转换逻辑地址到物理地址分过程如下：CPU把逻辑地址（由段选择子selector和段偏移offset组成）中的段选择子的内容作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址。 但是开启分页之后，会多一步转换： 可以看到，在开启分页后，逻辑地址经过分段机制的转换后，不会直接获得物理地址，而是一个线性地址，然后需要再通过一次分页机制转换才能得到最终的物理地址，此时其过程如下： 而对于从线性地址到分页物理地址的转换过程如下（使用32-bit分页机制）： 以4K页为例，线性地址的前10位表示页表目录，中间10位表示页表项，最后12位表示页内偏移。 首先根据高10位在页目录表中找到一个页目录项，这个页目录项的值加上中间10位拼接后的地址去页表中寻找一个页表项，这个页表项的值再加上后12位的偏移地址，就是最终的物理地址。 接下来以一个例子来感受分页机制： 假设经过分段机制转换后的线性地址是15M，二进制表示为 0000000011_0100000000_000000000000，其转换过程如下： 上述管转换过程的操作由MMU也就是内存管理单元完成，其主要作用就是将虚拟地址转换为物理地址。所以整个过程OS作为软件层，只需要提供好页目录表和页表即可，这种页表方案叫做二级页表，第一级叫做页目录表PDE，第二级叫做页表PTE，其结构如下： 之后再开启分页机制的开关，其实就是更改 cr0 寄存器中的第31位即可。在开始保护模式时，也是更改该寄存器中的第0位的值： 然后，MMU 就可以帮我们进行分页的转换了。此后指令中的内存地址（就是程序员提供的逻辑地址），就统统要先经过分段机制的转换，再通过分页机制的转换，才能最终变成物理地址。 ","date":"2021-12-14","objectID":"/2021/12/linux-0.11-06/:1:1","tags":["Linux","kernel"],"title":"Linux-0.11-06","uri":"/2021/12/linux-0.11-06/"},{"categories":["LINUX"],"content":"2. 开启分页机制 下面看分页机制如何开启，也就是 setup_paging 部分，主要是帮我们把页表和页目录表在内存中写好，然后开启 cr0 寄存器的分页开关： ;/* ; * Setup_paging ; * ; * 这个子程序通过设置控制寄存器cr0 的标志（PG 位31）来启动对内存的分页处理 ; * 功能，并设置各个页表项的内容，以恒等映射前16 MB 的物理内存。分页器假定 ; * 不会产生非法的地址映射（也即在只有4Mb 的机器上设置出大于4Mb 的内存地址）。 ; * ; * 注意！尽管所有的物理地址都应该由这个子程序进行恒等映射，但只有内核页面管 ; * 理函数能直接使用\u003e1Mb 的地址。所有“一般”函数仅使用低于1Mb 的地址空间，或 ; * 者是使用局部数据空间，地址空间将被映射到其它一些地方去-- mm(内存管理程序) ; * 会管理这些事的。 ; */ align 2 ;// 按4 字节方式对齐内存地址边界。 setup_paging: ;// 首先对5 页内存（1 页目录+ 4 页页表）清零 mov ecx,1024*5 ;/* 5 pages - pg_dir+4 page tables */ xor eax,eax xor edi,edi ;/* pg_dir is at 0x000 */ ;// 页目录从0x000 地址开始。 pushf ;// VC内汇编使用cld和std后，需要自己恢复DF的值 cld rep stosd ;// 下面4 句设置页目录中的项，我们共有4 个页表所以只需设置4 项。 ;// 页目录项的结构与页表中项的结构一样，4 个字节为1 项。参见上面的说明。 ;// \"$pg0+7\"表示：0x00001007，是页目录表中的第1 项。 ;// 则第1 个页表所在的地址= 0x00001007 \u0026 0xfffff000 = 0x1000；第1 个页表 ;// 的属性标志= 0x00001007 \u0026 0x00000fff = 0x07，表示该页存在、用户可读写。 mov eax,_pg_dir mov [eax],pg0+7 ;/* set present bit/user r/w */ mov [eax+4],pg1+7 ;/* --------- \" \" --------- */ mov [eax+8],pg2+7 ;/* --------- \" \" --------- */ mov [eax+12],pg3+7 ;/* --------- \" \" --------- */ ;// 下面6 行填写4 个页表中所有项的内容，共有：4(页表)*1024(项/页表)=4096 项(0 - 0xfff)， ;// 也即能映射物理内存4096*4Kb = 16Mb。 ;// 每项的内容是：当前项所映射的物理内存地址+ 该页的标志（这里均为7）。 ;// 使用的方法是从最后一个页表的最后一项开始按倒退顺序填写。一个页表的最后一项 ;// 在页表中的位置是1023*4 = 4092。因此最后一页的最后一项的位置就是$pg3+4092。 mov edi,pg3+4092 ;// edi -\u003e 最后一页的最后一项。 mov eax,00fff007h ;/* 16Mb - 4096 + 7 (r/w user,p) */ ;// 最后1 项对应物理内存页面的地址是0xfff000， ;// 加上属性标志7，即为0xfff007. std ;// 方向位置位，edi 值递减(4 字节)。 L3: stosd ;/* fill pages backwards - more efficient :-) */ sub eax,00001000h ;// 每填写好一项，物理地址值减0x1000。 jge L3 ;// 如果小于0 则说明全添写好了。 popf ;// 设置页目录基址寄存器cr3 的值，指向页目录表。 xor eax,eax ;/* 页目录表(pg_dir)在0x0000 处。 */ mov cr3,eax ;/* cr3 - page directory start */ ;// 设置启动使用分页处理（cr0 的PG 标志，位31） mov eax,cr0 or eax,80000000h ;// 添上PG 标志。 mov cr0,eax ;/* set paging (PG) bit */ ret ;/* this also flushes prefetch-queue */ ;// 在改变分页处理标志后要求使用转移指令刷新预取指令队列，这里用的是返回指令ret。 ;// 该返回指令的另一个作用是将堆栈中的main 程序的地址弹出，并开始运行/init/main.c ;// 程序。本程序到此真正结束了。 当时 linux-0.11 认为，总共可以使用的内存不会超过 16M，也即最大地址空间为 0xFFFFFF。而按照当前的页目录表和页表这种机制，1 个页目录表最多包含 1024 个页目录项（也就是 1024 个页表），1 个页表最多包含 1024 个页表项（也就是 1024 个页），1 页为 4KB（因为有 12 位偏移地址），因此，16M 的地址空间可以用 1 个页目录表 + 4 个页表搞定。 4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB 所以，上面这段代码就是，将页目录表放在内存地址的最开头。 _pg_dir: _startup_32: mov eax,0x10 mov ds,ax .. 之后紧挨着这个页目录表，放置 4 个页表，代码里也有这四个页表的标签项。 .org 0x1000 pg0: .org 0x2000 pg1: .org 0x3000 pg2: .org 0x4000 pg3: .org 0x5000 最终将页目录表和页表填写好数值，来覆盖整个 16MB 的内存。随后，开启分页机制。此时内存中的页表相关的布局如下。 这些页目录表和页表放到了整个内存布局中最开头的位置，就是覆盖了开头的 system 代码了，不过被覆盖的 system 代码已经执行过了，所以无所谓。同时，如 idt 和 gdt 一样，我们也需要通过一个寄存器告诉 CPU 我们把这些页表放在了哪里，就是这段代码。 xor eax,eax mov cr3,eax 我们相当于告诉 cr3 寄存器，0 地址处就是页目录表，再通过页目录表可以找到所有的页表，也就相当于 CPU 知道了分页机制的全貌了。 至此后，整个内存布局如下。 那么具体页表设置好后，映射的内存是怎样的情况呢？那就要看页表的具体数据了，就是这一坨代码。 setup_paging: ... mov eax,_pg_dir mov [eax],pg0+7 mov [eax+4],pg1+7 mov [eax+8],pg2+7 mov [eax+12],pg3+7 mov edi,pg3+4092 mov eax,00fff007h std L3: stosd sub eax, 1000h jpe L3 ... 很简单，对照刚刚的页目录表与页表结构看。 前五行表示，页目录表的前 4 个页目录项，分别指向 4 个页表。比如页目录项中的第一项 [eax] 被赋值为 pg0+7，也就是 0x00001007，根据页目录项的格式，表示页表地址为 0x1000，页属性为 0x07 表示改页存在、用户可读写。后面几行表示，填充 4 个页表的每一项，一共 4*1024=4096 项，依次映射到内存的前 16MB 空间。 画出图就是这个样子，其实刚刚的图就是。 最终的效果就是，经过这套分页机制，线性地址将恰好和最终转换的物理地址一样。 现在只有四个页目录项，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。 对于上述内容可以整理总结如下： Intel 体系结构的内存管理可以分成两大部分，也就是标题中的两板斧，分段和分页。 分段机制在之前几回已经讨论过多次了，其目的是为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。 分页机制是本回讲的内容，开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。其目的在于可以按需使用物理内存，同时也可以在多任务时起到隔离的作用，这个在后面将多任务时将会有所体会。 在 Intel 的保护模式下，分段机制是没有开启和关闭一说的，它必须存在，而分页机制是可以选择开启或关闭的。所以如果有人和你说，它实现了一个没有分段机制的操作系统，那一定是个外行。 再说说那些地址： 逻辑地址：我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。 线性地址：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。 物理地址：就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。 虚拟地址：如果没有开启分页机制，那么线性地址就和物理地址是一一对应的，可以理解为相等。如果开启了分页机制，那么线性地址将被视为虚拟地址，这个虚拟地址将会通过分页机制的转换，最终转换成物理地址。 ","date":"2021-12-14","objectID":"/2021/12/linux-0.11-06/:1:2","tags":["Linux","kernel"],"title":"Linux-0.11-06","uri":"/2021/12/linux-0.11-06/"},{"categories":["LINUX"],"content":"扩展资料 关于逻辑地址-线性地址-物理地址的转换，可以参考 Intel 手册： Intel 3A Chapter 3 Protected-Mode Memory Management 而有关这些地址的定义和说明，在本小节中也做了详细的说明，看这里的介绍是最权威也是最透彻的。相信我，它很简单。 页目录表和页表的具体结构，可以看 Intel 3A Chapter 4.3 32-bit paging ","date":"2021-12-14","objectID":"/2021/12/linux-0.11-06/:1:3","tags":["Linux","kernel"],"title":"Linux-0.11-06","uri":"/2021/12/linux-0.11-06/"},{"categories":["LINUX"],"content":"原文地址 你管这破玩意叫操作系统源码 | 第八回 Intel内存管理两板斧：分段与分页 ","date":"2021-12-14","objectID":"/2021/12/linux-0.11-06/:2:0","tags":["Linux","kernel"],"title":"Linux-0.11-06","uri":"/2021/12/linux-0.11-06/"},{"categories":["LINUX"],"content":"闪客Linux操作系统系列第五篇","date":"2021-12-13","objectID":"/2021/12/linux-0.11-05/","tags":["Linux","kernel"],"title":"Linux-0.11-05","uri":"/2021/12/linux-0.11-05/"},{"categories":["LINUX"],"content":"Peach Fuzzer Professional本文是Linux 0.11系列学习记录的正式的第五篇。 ","date":"2021-12-13","objectID":"/2021/12/linux-0.11-05/:0:0","tags":["Linux","kernel"],"title":"Linux-0.11-05","uri":"/2021/12/linux-0.11-05/"},{"categories":["LINUX"],"content":"08 重新设置 idt 和 gdt 书接上回，上回书咱们说到，CPU 进入了 32 位保护模式，我们快速回顾一下关键的代码。 首先配置了全局描述符表 gdt 和中断描述符表 idt。 lidt idt_48 lgdt gdt_48 然后打开了 A20 地址线。 mov al,#0xD1 ; command write out #0x64,al mov al,#0xDF ; A20 on out #0x60,al 然后更改 cr0 寄存器开启保护模式。 mov ax,#0x0001 lmsw ax 最后，一个干脆利落的跳转指令，跳到了内存地址 0 处开始执行代码。 jmpi 0,8 0 位置处存储着操作系统全部核心代码，是由 head.s 和 main.c 以及后面的无数源代码文件编译并链接在一起而成的 system 模块。 接下来看下在正式进入 c 语言写的 main.c 之前的 head.s 究竟写了点啥？ ; head.s _pg_dir: ; 页目录存放在这里 _startup_32: ; 以下5行设置各个数据段寄存器，指向 gdt 数据段描述符项 mov eax,0x10 mov ds,ax mov es,ax mov fs,ax mov gs,ax lss esp,_stack_start ; 表示_stack_start -\u003e ss:esp，设置系统堆栈。 注意到开头有个标号 _pg_dir，这个表示页目录，之后在设置分页机制时，页目录会存放在这里，也会覆盖这里的代码。 再往下连续五个 mov 操作，分别给 ds、es、fs、gs 这几个段寄存器赋值为 0x10，根据段描述符结构解析，表示这几个段寄存器的值为指向全局描述符表中的第二个段描述符，也就是数据段描述符。（这里我们可能在后续进行源码阅读的时候会进一步深入，这里作者分析的有点简单，可能很多读者看不懂。） 最后 lss 指令相当于让 ss:esp 这个栈顶指针指向了 _stack_start 这个标号的位置。还记得图里的那个原来的栈顶指针在哪里吧？往上翻一下，0x9FF00，现在要变咯。 这个 stack_start 标号定义在了很久之后才会讲到的 sched.c 里，我们这里拿出来分析一波。 long user_stack[4096 \u003e\u003e 2]; struct { long *a; short b; } stack_start = {\u0026user_stack[4096 \u003e\u003e 2], 0x10}; 首先，stack_start 结构中的高位 8 字节是 0x10，将会赋值给 ss 栈段寄存器，低位 16 字节是 user_stack 这个数组的最后一个元素的地址值，将其赋值给 esp 寄存器。 赋值给 ss 的 0x10 仍然按照保护模式下的段选择子去解读，其指向的是全局描述符表中的第二个段描述符（数据段描述符），段基址是 0。 赋值给 esp 寄存器的就是 user_stack 数组的最后一个元素的内存地址值，那最终的栈顶地址，也指向了这里（user_stack + 0），后面的压栈操作，就是往这个新的栈顶地址处压咯。 继续往下看 call setup_idt ;设置中断描述符表 call setup_gdt ;设置全局描述符表 mov eax,10h mov ds,ax mov es,ax mov fs,ax mov gs,ax lss esp,_stack_start 先设置了 idt 和 gdt，然后又重新执行了一遍刚刚执行过的代码。 为什么要重新设置这些段寄存器呢？因为上面修改了 gdt，所以要重新设置一遍以刷新才能生效。那我们接下来就把目光放到设置 idt 和 gdt 上。中断描述符表 idt 我们之前没设置过，所以这里设置具体的值，理所应当。 setup_idt: lea edx,ignore_int mov eax,00080000h mov ax,dx mov dx,8E00h lea edi,_idt mov ecx,256 rp_sidt: mov [edi],eax mov [edi+4],edx add edi,8 dec ecx jne rp_sidt lidt fword ptr idt_descr ret idt_descr: dw 256*8-1 dd _idt _idt: DQ 256 dup(0) 不用细看，我给你说最终效果。 中断描述符表 idt 里面存储着一个个中断描述符，每一个中断号就对应着一个中断描述符，而中断描述符里面存储着主要是中断程序的地址，这样一个中断号过来后，CPU 就会自动寻找相应的中断程序，然后去执行它。 那这段程序的作用就是，设置了 256 个中断描述符，并且让每一个中断描述符中的中断程序例程都指向一个 ignore_int 的函数地址，这个是个默认的中断处理程序，之后会逐渐被各个具体的中断程序所覆盖。比如之后键盘模块会将自己的键盘中断处理程序，覆盖过去。 那现在，产生任何中断都会指向这个默认的函数 ignore_int，也就是说现在这个阶段你按键盘还不好使。 设置中断描述符表 setup_idt 说完了，那接下来 setup_gdt 就同理了。我们就直接看设置好后的新的全局描述符表长什么样吧？ _gdt: DQ 0000000000000000h ;/* NULL descriptor */ DQ 00c09a0000000fffh ;/* 16Mb */ DQ 00c0920000000fffh ;/* 16Mb */ DQ 0000000000000000h ;/* TEMPORARY - don't use */ DQ 252 dup(0) 其实和我们原先设置好的 gdt 一模一样。 也是有代码段描述符和数据段描述符，然后第四项系统段描述符并没有用到，不用管。最后还留了 252 项的空间，这些空间后面会用来放置任务状态段描述符 TSS 和局部描述符 LDT，这个后面再说。 为什么原来已经设置过一遍了，这里又要重新设置一遍，你可千万别想有什么复杂的原因，就是因为原来设置的 gdt 是在 setup 程序中，之后这个地方要被缓冲区覆盖掉，所以这里重新设置在 head 程序中，这块内存区域之后就不会被其他程序用到并且覆盖了，就这么个事。 说的口干舌燥，还是来张图吧。如果你本文的内容完全不能理解，那就记住最后这张图就好了，本文代码就是完成了这个图中所示的一个指向转换而已，并且给所有中断设置了一个默认的中断处理程序 ignore_int，然后全局描述符表仍然只有代码段描述符和数据段描述符。 好了，本文就是两个描述符表位置的变化以及重新设置，再后面一行代码就是又一个令人兴奋的功能了！ jmp after_page_tables ... after_page_tables: push 0 push 0 push 0 push L6 push _main jmp setup_paging L6: jmp L6 那就是开启分页机制，并且跳转到 main 函数！ 这可太令人兴奋了！开启分页后，配合着之前讲的分段，就构成了内存管理的最最底层的机制。而跳转到 main 函数，标志着我们正式进入 c 语言写的操作系统核心代码！ ","date":"2021-12-13","objectID":"/2021/12/linux-0.11-05/:1:0","tags":["Linux","kernel"],"title":"Linux-0.11-05","uri":"/2021/12/linux-0.11-05/"},{"categories":["LINUX"],"content":"原文地址 你管这破玩意叫操作系统源码 | 第八回 烦死了又要重新设置一遍idt和gdt ","date":"2021-12-13","objectID":"/2021/12/linux-0.11-05/:2:0","tags":["Linux","kernel"],"title":"Linux-0.11-05","uri":"/2021/12/linux-0.11-05/"},{"categories":["LINUX"],"content":"闪客Linux操作系统系列序言","date":"2021-11-18","objectID":"/2021/11/linux-0.11-%E5%BA%8F/","tags":["Linux","kernel"],"title":"Linux-0.11-序","uri":"/2021/11/linux-0.11-%E5%BA%8F/"},{"categories":["LINUX"],"content":"本文是Linux 0.11系列学习记录的序言篇，主要是闪客在微信公众号上发布的相关内容的整理总结。 ","date":"2021-11-18","objectID":"/2021/11/linux-0.11-%E5%BA%8F/:0:0","tags":["Linux","kernel"],"title":"Linux-0.11-序","uri":"/2021/11/linux-0.11-%E5%BA%8F/"},{"categories":["LINUX"],"content":"前言 本系列是闪客sun的最新微信公众号技术文章系列–《你管这破玩意叫操作系统源码》。闪客sun的文章基本全是干货，懂的都懂，这次的新系列实在是掐中了很多人的痛点，能很好地帮助大家深入理解 Linux 操作系统。 本着学习和分享的目的，blog 会进行该系列文章的同步更新，希望能有更多想学习技术干货的人了解到闪客sun和他的技术文。在每篇文章的末尾，会放上公众号链接，希望大家在学习的同时，也多多支持闪客sun。 公众号 低并发编程： 以下为原文： 写在前面 核心信息提炼到开头，以节约大家的时间。 要干嘛：写一个系列 啥目的：带大家把 Linux 0.11 核心代码与操作系统的设计思想啃下来 叫啥名：你管这破玩意叫操作系统源码 — 像小说一样品读 Linux 0.11 核心代码 发文时间：每周一和每周四 预计章节：60 回 互动方式：微信群（文末有加入方式） 系列整体布局： 第一部分：进入内核前的苦力活 第二部分：大战前期的初始化工作 第三部分：一个新进程的诞生 第四部分：shell 程序的到来 第五部分：从一个命令的执行看操作系统各模块的运作 第六部分：操作系统哲学与思想 OK，以上就是要说的重要的事，以下是啰嗦的部分。 我是分割线 每个程序员都有一个操作系统梦，而操作系统也是每个程序员的心结。 很粗糙地了解一点操作系统知识，一知半解的，已经无法满足当下程序员的口味了。但要说深入剖析操作系统，又是大部分程序员都很惶恐的一件事。那如果是要读一遍操作系统源码，那简直跟要了命一样。 其实，操作系统的源码并没有那么可怕，可为什么即便是 Linux 0.11 这种代码量最少的版本，仍然令很多人望而却步呢？ 为什么望而却步 其实，很多优秀的操作系统书籍都是以 Linux 0.11 这个经典版本为研究对象进行讲解的，比如《Linux 内核设计的艺术》、 《Linux 内核完全注释》等。但我们想一下，当我们读一本小说时，为什么即便是非常大部头的小说，也能酣畅淋漓从头读到尾？ 先不直接回答这个问题，我们看一下**《天龙八部》**的最开头： “青光闪动，一柄青钢剑倏地刺出，指向中年汉子左肩，使剑少年不待剑招用老，腕抖剑斜，剑锋已削向那汉子右颈。那中年汉子…” 记住这个感觉没？我们再看一下《Linux 内核设计的艺术》的最开头： “对于操作系统而言，稳定且可靠地运行是最重要的。现行技术方案是将用户进程与用户进程之间、用户进程与操作系统之间进行分离，操作系统可以管理用户进程，但是用户进程之间不能相互干预 …” 好了，不用读下去了，这句话看似高瞻远瞩地从宏观上帮我们梳理操作系统体系结构，但对于尚不了解操作系统的人来说，完全不知道它在说什么，只有劝退的作用。 虽然说思想很重要，但你在没有任何细节做积累时去强行进行思想的拔高，是拔不上去的，还不如一直保持一张白纸的状态。 反观《天龙八部》的开头，连人物的名字都没有，更别说梳理整个体系结构了，直接上来一个精彩镜头，让你迅速进入故事情节。 可是读完整部小说的读者，无一不对里面的人物如数家珍，对大理的风光仿佛亲眼看见了一般，对宋辽矛盾的激烈感同身受。 为什么会这样呢？因为一切的爱恨情仇和民族矛盾，都是我们通过一个个人物和事件的刻画，感悟出来的。只有自己感悟出来的知识和靠自己总结出来的结论，才真正属于自己。 而那些一上来就试图把整个脉络给你梳理清楚的尝试，对于新手来说无一不是徒劳，即便是死记硬背记住了，也终究不是属于自己的知识，无法感同身受。 我学习操作系统的过程中，也有这样的感觉。 我曾一次次试图从一个上帝视角来看操作系统的知识体系，从宏观层面跟着大部头书籍梳理操作系统的整体逻辑，我发现无一不是以失败告终。 而当我放下包袱，用读一本小说的心态来去阅读 Linux 源代码时，我发现，我从来没有去想着梳理出什么体系，但不知道从哪一行代码开始，整个操作系统的体系结构已经较为清晰地出现在我面前了，竟是那么的不知不觉。 而且我也清晰地知道，这样的体系是怎么一步步从第一行代码开始，逐步建立起来的。 虽然我还没有触类旁通，真正理解操作系统的哲学与设计思想，也不能凭自己的想法写出一个新的操作系统来，但最初的这道坎我算是过去了。 所以我想把这些梳理一下，分享给大家。同时也能更好地让自己巩固细节，最终真正理解操作系统的思想，达到触类旁通。 如何分享呢？ 打算写个新系列 我并不是说《Linux 内核设计的艺术》这本书不好，而是想着能不能也以写小说一样的心态和方式，来给大家从头到尾讲述这部 Linux 0.11 的源码。 我打算把这个系列叫做 《你管这破玩意叫操作系统源码 —— 像小说一样品读 Linux 0.11 核心代码》 在这里面，我不会经常把操作系统的体系架构挂在嘴边，时时刻刻强行塞到你的脑子里，而是通过一行一行代码逐渐带入情节，最终让你不知不觉地发现，原来整个操作系统的体系就这样一点一点建立起来了。 本系列的每一章内容都很短，千万不要有心里负担，而正是这些简单的事情联系到一起，就构成了整个操作系统的复杂的设计。 所以也导致了，单独看任何一章都不会有显著的收获，但如果整个系列都能跟下来，并且每一章的内容都能做出思考，把不懂的地方及时解决，我保证你会对操作系统有一个全新的，深入到细节的认识。 希望你跟我走完这个系列，也能发出一句感叹，原来操作系统源码不过如此，就是这么个破玩意而已！ 但同时，你也要有耐心，你不要总想着，读到这了我怎么还是没觉得自己懂操作系统了呢？怎么还是没讲多进程如何调度呢？记住，享受当下，当下你学的每一个看似没啥用的知识，都是后面豁然开朗这种感觉的基石。 等等，我记得闪客之前也说要写个自制操作系统系列呢？不过好像… 万一中途又鸽了怎么办 话说回来，我的老读者有点惨，之前总是看我信誓旦旦说要写操作系统的系列，但无一例外都是中途失败了。 博客园上写过，公众号上也写过，而公众号里的好多读者就是被我的自制操作系统系列骗进来的，然后写到第五章我就鸽了，实在太过分了！ 所以接下来自然就有一个大家都关心的问题了，就是这次会不会又鸽呢？ 我可以肯定的是，这次绝对绝对绝对绝对绝对绝对不会中途鸽了！因为我此时此刻已经把全部的大纲以及文章的前 33 章的内容写好了，就藏在我的石墨文档里。后面的内容我打算根据前面的反馈和问答，不断做出调整。 没错，总共我计划分六大部分，前四部分你会看到从开机一直到操作系统的最后一行代码的全部主流程，第五部分将通过一个命令的执行将操作系统各个模块的运作方式串一遍，而第六部分会做一个思想的拔高，这也是我自己给自己挖的一个坑和挑战。 而六大部分对应到 Linux 0.11 源码从开机到 shell 的流程图，是这样的。 其实本可以早早就开始边写边发布，但想着要是这次中途又鸽了读者，着实有点不好意思。所以就冒着中途写不下去的风险，先把大部分文章提前写好。 但我也给自己留了个后路，就是只提前写了 33 章，也够大家看好几个月了，要是大家不捧场，我后面就不更了，哼（傲娇表情.gif）！ 提前写好有个好处，就是写到后面的时候，发现前面有些地方可以提前做个引子，这样整个系列就更完整了，可以前后呼应，可读性和收获也会大大增加。 如何互动 虽然已经提前写好，但中途还是要不断接受读者反馈和答疑，以便更好修正文章的内容，并且做一些知识点的补充，这也是我对自己的要求和考验。 所以建立微信群增加互动性。 在这里你可以不断对文章内容提出反馈意见，以及和不同读者进行心得交流，以及进行催更呐喊。不要觉得你的意见无法左右这个系列，要知道，这个系列的名称就是低并发编程读者群的读者们群体的智慧想出来的。 我觉得这也是公众号里更新系列的一个优势，就是与读者的距离更近，更方便随时讨论和交流，互相促进成长。 加入方式是加我微信好友，备注 os-昵称-其他信息 比如 os-闪客-Java 我会将所有备注为本格式的好友邀请至微信群。 一定要按备注要求来哦~ 我是华丽的分割线 好了！本篇文章就当做开篇词，今后不出意外至少每周一周四更新，每一个大部分结束后会看情况留一段时间集中消化与总结。 不过会以文章质量和准确性为主，不会带着问题强行按时更新的。 本系列完全免费，直到所有章节全部结束，所以你们的喜欢和传播就是对我最大的支持，可以星标我的公众号防止错过更新提醒。 公众号虽然与读者距离更近，但它却是个封闭的空间，平台和搜索引擎不会主动向外扩散，所以如果没有人主动帮忙传播，会一直限制在公众号粉丝的圈子里，越到后面看的人也会越少。 这也是很多公众号系列中途腰斩的因素之一，所以还是希望大家喜欢这个系列的话，可以多多帮忙传播，比如朋友圈打打卡，或者如果你也写博客的话，文章里提提我，都是可以帮到这个系列活下去的重要途径，在此多谢各位捧场啦！ 同时我也会在 GitHub 上进行同步，因为公众号文章发了之后就无法修改，也没法进行整体调整。感兴趣的也可以点击阅读原文进入 GitHub。但我同步应该不会很及时，还是以公众号为主战场，毕竟时间和精力有限。 那就让我们一起期待吧！ ","date":"2021-11-18","objectID":"/2021/11/linux-0.11-%E5%BA%8F/:1:0","tags":["Linux","kernel"],"title":"Linux-0.11-序","uri":"/2021/11/linux-0.11-%E5%BA%8F/"},{"categories":["LINUX"],"content":"原文地址 闪客新系列！你管这破玩意叫操作系统源码 ","date":"2021-11-18","objectID":"/2021/11/linux-0.11-%E5%BA%8F/:2:0","tags":["Linux","kernel"],"title":"Linux-0.11-序","uri":"/2021/11/linux-0.11-%E5%BA%8F/"},{"categories":["Fuzz"],"content":"Lighthouse使用及改进","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["Fuzz"],"content":"TL;DR 介绍IDA覆盖率统计插件Lighthouse的使用，并对其覆盖率输出方式进行修改，获得可阅读的明文代码执行路径信息。 ","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/:1:0","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["Fuzz"],"content":"1. 背景 最近有统计覆盖率信息的需求，多方搜索后发现IDA插件Lighthouse具有统计覆盖率的功能，通过读取DynamoRIO或者Pin产生的覆盖率日志文件，在IDA中以图形化形式展现代码的详细执行路径。 DynamoRIO或Pin等插桩工具默认使用的日志文件格式为drcov格式，这是一种二进制格式，每个基本块的信息的都是以十六进制数据进行记录。虽然二进制形式的记录方式有利于提高性能，但是人工阅读困难。 ","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/:2:0","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["Fuzz"],"content":"2. Lighouse的基本使用 下载：Lighthouse； 安装： 在IDA中找到插件文件的目录： import idaapi, os; print(os.path.join(idaapi.get_user_idadir(), \"plugins\")) 将下载下来的源码中的/plugins/文件夹copy到上面命令执行结果的目录中，然后重启IDA。 获取drcov格式覆盖率统计日志文件： 首先使用Pin或DynamoRIO获取覆盖率统计文件(这里以Pin为例)： 这里需要注意的是，Lighthouse默认使用的drcov文件版本为version 2，但是最新版的DynamoRIO生成的drcov文件的版本为version 3，所以在导入IDA时会提示文件格式错误。Lighthouse目前提供了pin和frida的覆盖率统计插件，DynamoRIO的需要做修改或者使用旧版本的DynamoRIO： IDA中导入日志文件： 首先IDA加载要观察的可执行文件，然后File -\u003e Load file -\u003e Code coverage file... 加载刚刚生成的日志文件： 控制流图的蓝色基本块为执行了的基本块，右侧为coverage的overview信息 同样进行F5之后，可以看到执行过的伪代码： ","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/:3:0","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["Fuzz"],"content":"3. drcov文件格式 ","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/:4:0","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["Fuzz"],"content":"1. 简介 drcov是基于DynamoRIO框架的用于收集二进制程序覆盖率信息的一种工具，其收集的覆盖率信息格式即为drcov格式。因为其成熟高效的特点，很多进行覆盖率收集的工具都会使用这种格式。 DynamoRIO官方并未对drcov格式进行详细的说明，所以此处进行说明记录，希望能对后续的覆盖率信息收集工具的开发起到一定的作用 ","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/:4:1","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["Fuzz"],"content":"2. 详细格式 首先，drcov格式有一个包含一些metadata的头部： DRCOV VERSION: 2 DRCOV FLAVOR: drcov 在Lighthouse中只支持了version 2的格式；DRCOV FLAVOR是一个描述产生覆盖率信息的工具的字符串，并没有具体的实际作用。 然后，是在收集覆盖率信息的过程中加载的模块的映射的模块表： Module Table: version 2, count 39 Columns: id, base, end, entry, checksum, timestamp, path 0, 0x10c83b000, 0x10c83dfff, 0x0000000000000000, 0x00000000, 0x00000000, /Users/ayrx/code/frida-drcov/bar 1, 0x112314000, 0x1123f4fff, 0x0000000000000000, 0x00000000, 0x00000000, /usr/lib/dyld 2, 0x7fff5d866000, 0x7fff5d867fff, 0x0000000000000000, 0x00000000, 0x00000000, /usr/lib/libSystem.B.dylib 3, 0x7fff5dac1000, 0x7fff5db18fff, 0x0000000000000000, 0x00000000, 0x00000000, /usr/lib/libc++.1.dylib 4, 0x7fff5db19000, 0x7fff5db2efff, 0x0000000000000000, 0x00000000, 0x00000000, /usr/lib/libc++abi.dylib 5, 0x7fff5f30d000, 0x7fff5fa93fff, 0x0000000000000000, 0x00000000, 0x00000000, /usr/lib/libobjc.A.dylib 8, 0x7fff60617000, 0x7fff60647fff, 0x0000000000000000, 0x00000000, 0x00000000, /usr/lib/system/libxpc.dylib ... snip ... 模块表的头部有两种变体，都包含模块表中的条目数： Format used in DynamoRIO v6.1.1 through 6.2.0 eg: 'Module Table: 11' Format used in DynamoRIO v7.0.0-RC1 (and hopefully above) eg: 'Module Table: version X, count 11' 每个版本的表格格式有些许不同： DynamoRIO v6.1.1, table version 1: eg: (Not present) DynamoRIO v7.0.0-RC1, table version 2: Windows: 'Columns: id, base, end, entry, checksum, timestamp, path' Mac/Linux: 'Columns: id, base, end, entry, path' DynamoRIO v7.0.17594B, table version 3: Windows: 'Columns: id, containing_id, start, end, entry, checksum, timestamp, path' Mac/Linux: 'Columns: id, containing_id, start, end, entry, path' DynamoRIO v7.0.17640, table version 4: Windows: 'Columns: id, containing_id, start, end, entry, offset, checksum, timestamp, path' Mac/Linux: 'Columns: id, containing_id, start, end, entry, offset, path' 虽然有很多列的数值，但是实际上能于Lighthouse交互的数据只有以下几种： id: 生成模块表时分配的序号，稍后用于将基本块映射到模块。 start, base: 模块开始的内存基地址。 end: 模块结束的内存地址。 path: 模块在硬盘上的存储路径。 最后，日志文件有一个基本块表，其中包含在收集覆盖信息时执行的基本块列表。虽然drcov可以以文本格式转储基本块表（使用-dump_text选项），但它默认以二进制格式转储表。 BB Table: 861 bbs \u003cbinary data\u003e 该表首先是一个表头，表明基本块的数量。后续跟的数据是一个每个8字节大小的__bb_entry_t结构组成的数组，__bb_entry_t的结构如下： typedef struct _bb_entry_t { uint start; /* offset of bb start from the image base */ ushort size; ushort mod_id; } bb_entry_t; 结构解释如下： start: 距离基本块入口开始的模块的基地址的偏移。 size: 基本块的大小。 mod_id: 发现的基本块所在模块的id，与前面模块表中的id是对应的。 基于上面3个元素，就可以知道哪个基本块被执行了，从而作为覆盖率信息进行收集。 ","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/:4:2","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["Fuzz"],"content":"3. 修改输出方式为明文(以Pin插件为例) 因为Lighthouse默认输出的覆盖率日志文件时drcov格式的，人工阅读存在一定的困难。在某些场景下，需要直接获得人工易读的代码执行路径信息，所以考虑对Lighthouse的覆盖率统计插件进行修改。 Lighthouse的覆盖率统计功能在如下代码中： # CodeCoverage.cpp static VOID OnFini(INT32 code, VOID* v) { ...snap... drcov_bb tmp; for (const auto\u0026 data : context.m_terminated_threads) { for (const auto\u0026 block : data-\u003em_blocks) { auto address = block.first; auto it = std::find_if(context.m_loaded_images.begin(), context.m_loaded_images.end(), [\u0026address](const LoadedImage\u0026 image) { return address \u003e= image.low_ \u0026\u0026 address \u003c image.high_; }); if (it == context.m_loaded_images.end()) continue; tmp.id = (uint16_t)std::distance(context.m_loaded_images.begin(), it); tmp.start = (uint32_t)(address - it-\u003elow_); tmp.size = data-\u003em_blocks[address]; context.m_trace-\u003ewrite_binary(\u0026tmp, sizeof(tmp)); } } } 首先设置了一个drcov_bb结构tmp，其完整格式如下： struct __attribute__((packed)) drcov_bb { uint32_t start; uint16_t size; uint16_t id; }; 然后进入到一个内外嵌套循环中，在每个内循环中每读到一个bb信息就对tmp结构进行赋值： tmp.id = (uint16_t)std::distance(context.m_loaded_images.begin(), it); tmp.start = (uint32_t)(address - it-\u003elow_); tmp.size = data-\u003em_blocks[address]; 最后调用write_binary函数写入到trace文件中： context.m_trace-\u003ewrite_binary(\u0026tmp, sizeof(tmp)); 而write_binary函数的实现在Trace.h文件中： void write_binary(const void* ptr, size_t size) { if (fwrite(ptr, size, 1, m_file) != 1) { std::cerr \u003c\u003c \"Could not log to the log file.\" \u003c\u003c std::endl; std::abort(); } } 可以看到本质上就是调用fwrite函数进行流操作。此外，还有一个write_string函数： void write_string(const char* format, ...) { va_list args; va_start(args, format); if (vfprintf(m_file, format, args) \u003c 0) { std::cerr \u003c\u003c \"Could not log to the log file.\" \u003c\u003c std::endl; std::abort(); } va_end(args); } 该函数用作想trace文件中写入string格式的数据。这么一来就好办了，直接用现成的即可，只需要修改在写文件时的操作就ok了。修改后的代码如下： // drcov_bb tmp; 这里要注释掉。否则有的环境会报编译不通过 for (const auto\u0026 data : context.m_terminated_threads) { for (const auto\u0026 block : data-\u003em_blocks) { auto address = block.first; auto it = std::find_if(context.m_loaded_images.begin(), context.m_loaded_images.end(), [\u0026address](const LoadedImage\u0026 image) { return address \u003e= image.low_ \u0026\u0026 address \u003c image.high_; }); if (it == context.m_loaded_images.end()) continue; uint16_t id = (uint16_t)std::distance(context.m_loaded_images.begin(), it); uint32_t start_addr = (uint32_t)(address - it-\u003elow_); int size = data-\u003em_blocks[address]; context.m_trace-\u003ewrite_string(\"[+]module: [%d] 0x%08x %d\\n\", id, start_addr, size); } } 这种格式只能用作人工阅读或进一步的处理，没有办法再使用drcov2lcov和genhtml工具进行转换了，最终实现的效果如下： 会以明文形式打印出每个模块的执行的基本块的地址和块大小，这样就方便人工进行阅读，还可以进一步提取出模块执行的地址，进行后续处理。 ","date":"2021-10-17","objectID":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/:5:0","tags":["Fuzz","Instrument","Pin"],"title":"利用Lighthouse进行覆盖率统计及其优化","uri":"/2021/10/%E5%88%A9%E7%94%A8lighthouse%E8%BF%9B%E8%A1%8C%E8%A6%86%E7%9B%96%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/"},{"categories":["LINUX"],"content":"记录一下多版本gcc共存的解决方案。","date":"2021-10-07","objectID":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/","tags":["LINUX","gcc"],"title":"多版本gcc共存方案","uri":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/"},{"categories":["LINUX"],"content":"前言 有时需要进行交叉编译的时候，可能需要在高版本的架构上编译一个低版本的工具来运行到一个旧平台上。高版本的架构一般自带的都是高版本工具，这样编译出来的工具无法在低版本架构上运行，所以就有了多版本编译器共存的情况。这里我们以 gcc 为例简单说一下多版本 gcc 共存的解决方案，其实很简单。 ","date":"2021-10-07","objectID":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/:1:0","tags":["LINUX","gcc"],"title":"多版本gcc共存方案","uri":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/"},{"categories":["LINUX"],"content":"安装低版本gcc/g++ 在高版本的 Linux 上的源里是不能直接 apt 去安装低版本的 gcc/g++ 的，所以这里简单记录下如何在高版本的 Ubuntu 上也可以直接 apt 安装。 换源 既然高版本的源里没有安装包，直接更新一下低版本的源好了。以 gcc-4.8 为例，这里首先把 ubuntu 16.04 的源更新到 /etc/apt/sources.list中去： # official deb http://dk.archive.ubuntu.com/ubuntu/ xenial main deb http://dk.archive.ubuntu.com/ubuntu/ xenial universe # 国内源aliyun deb http://mirrors.aliyun.com/ubuntu/ xenial main deb-src http://mirrors.aliyun.com/ubuntu/ xenial main deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb-src http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb http://mirrors.aliyun.com/ubuntu/ xenial-security main deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security universe 然后 sudo apt update 一下，把包资源更新进来。 安装 可以先查看一下版本信息：sudo apt-cache policy gcc-4.8 ，作用类似于搜索，下面所有能安装的子版本都会列出来。然后直接 apt install 对应的版本即可。 这种方法不管想安装什么版本的旧软件，只要有对应的更新源即可。 ","date":"2021-10-07","objectID":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/:2:0","tags":["LINUX","gcc"],"title":"多版本gcc共存方案","uri":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/"},{"categories":["LINUX"],"content":"版本控制 第一种方法： 直接在使用时指定 CC 或 CXX，跟上对应版本的 gcc/g++ 的绝对路径即可。个人感觉这样会更方便一点，只要在编译的时候指定一下变量即可。 第二种方法： 设置优先级： $ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40 $ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90 $ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++4.8 40 $ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 90 # 数字越大，表示优先级越高，上面的例子中就是优先使用 gcc-9 ，这个具体的数字不用特别关注，只要能体现出来大小来表达优先级就可以。 删除设置的优先级： $ sudo update-alternatives --remove /usr/bin/g+±4.8 切换版本可以通过以下命令： $ sudo update-alternatives --config gcc $ sudo update-alternatives --config g++ 选择对应的数字即可，然后回车即可切换版本。 ","date":"2021-10-07","objectID":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/:3:0","tags":["LINUX","gcc"],"title":"多版本gcc共存方案","uri":"/2021/10/%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E5%85%B1%E5%AD%98%E6%96%B9%E6%A1%88/"},{"categories":["Fuzz"],"content":"Pin学习记录第二篇","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"本文是Pin系列学习记录的第二篇，主要是官方文档的相关内容的整理总结。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:0:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"4. Callbacks 这部分主要介绍几个Pin的用于注册回调函数的API： INS_AddInstrumentFunction (INSCALLBACK fun, VOID *val)：注册以指令粒度插桩的函数 TRACE_AddInstrumentFunction (TRACECALLBACK fun, VOID *val)：注册以trace粒度插桩的函数 RTN_AddInstrumentFunction (RTNCALLBACK fun, VOID *val)：注册以routine粒度插桩的函数 IMG_AddInstrumentFunction (IMGCALLBACK fun, VOID *val)：注册以image粒度插桩的函数 PIN_AddFiniFunction (FINICALLBACK fun, VOID *val)：注册在应用程序退出前执行的函数，该类函数不进行插桩，可以有多个。 PIN_AddDetachFunction (DETACHCALLBACK fun, VOID *val)：注册在Pin通过PIN_Detach()函数放弃对应用程序的控制权限之前执行的函数，一个进程只调用一次，可以被任何线程调用，此时Pin的内存并没有释放。 对于每个注册函数的第二个参数val将在“回调”时传递给回调函数。如果在实际的场景中不需要传递第二个参数，为了保证安全，可以传递将val的值设置为0进行传递。val的理想使用方式是传递一个指向类实例的指针，这样回调函数在取消引用该指针前需要将其转换回一个对象。 所有的注册函数都会返回一个PIN_CALLBACK对象，该对象可以在后续过程中用于操作注册的回调的相关属性。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:1:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"PIN callbacks manipulation API 在注册函数返回PIN_CALLBACK对象后，可以使用PIN_CALLBACKAPI对其进行操作，来检索和修改在Pin中已注册的回调函数的属性。 声明： typedef COMPLEX_CALLBACKVAL_BASE * PIN_CALLBACK 函数： CALLBACK_GetExecutionOrder() 声明： VOID CALLBACK_GetExecutionOrder (PIN_CALLBACK callback) 作用：获取已注册回调函数的执行顺序。越靠前，越早被执行。 参数：callback，从*_Add*Funcxtion()函数返回的注册的回调函数 CALLBACK_SetExecutionOrder() 声明： VOID CALLBACK_SetExecutionOrder (PIN_CALLBACK callback, CALL_ORDER order) 作用：设置已注册回调函数的执行顺序。越靠前，越早被执行。 参数：callback，从*_Add*Funcxtion()函数返回的注册的回调函数；order，新设置的回调函数的执行顺序。 PIN_CALLBACK_INVALID() 声明： const PIN_CALLBACK PIN_CALLBACK_INVALID(0) PIN回调的无效值。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:1:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"CALL_ORDER CALL_ORDER是一个枚举类型，预定义了IARG_CALL_ORDER的值。其作用就是当指令有多个分析函数调用时，控制每个分析函数的调用顺序，默认值为CALL_ORDER_DEFAULT。 CALL_ORDER_FIRST：首先执行该调用，整数值为100. CALL_ORDER_DEFAULT：未指定IARG_CALL_ORDER时的默认值，整数值为200. CALL_ORDER_LAST：最后执行该调用，整数值为300. 在进行数值设定时，可以使用类似CALL_ORDER_DEFAULT + 5的格式来设置。 针对在相同插桩回调环境中的针对同一指令的、具备同样CALL_ORDER的多个分析调用，Pin会按照插入的顺序进行调用。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:1:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"5. Mopdifying Application Instructions 虽然Pin的主要用途是对二进制程序进行插桩，但是它也可以实现对程序指令的修改。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:2:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"5.1 实现方式 最简单的实现方式是插入一个分析routine来模拟指令执行，然后调用INS_Delete()来删除指令。也可以通过直接或间接插入程序执行流分支（使用INS_InsertDirectJump和INS_InsertIndirectJump）实现，这种方式会改变程序的执行流，但是会更容易实现指令模拟。 INS_InsertDirectJump() 声明： VOID INS_InsertDirectJump(INS ins, IPOINT ipoint, ADDRINT tgt) 参数： ins：输入的指令 ipoint：与ins相关的location（仅支持IPOINT_BEFORE和IPOINT_AFTER） tgt：target的绝对地址 作用：插入相对于给定指令的直接跳转指令，与INS_Delete()配合使用可以模拟控制流转移指令。 INS_InsertIndirectJump() 声明： VOID INS_InsertIndirectJump ( INS ins, IPOINT ipoint, REG reg) 参数： ins：输入的指令 ipoint：与ins相关的location（仅支持IPOINT_BEFORE和IPOINT_AFTER reg：target的寄存器 作用：插入相对于给定指令的间接跳转指令，与INS_Delete()配合使用可以模拟控制流转移指令。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:2:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"5.2 指令内存修改 对于原始指令使用到的内存的访问，可以通过使用INS_RewriteMemoryOperand来引用通过分析routine计算得到的值来替代。 需要注意的是，对于指令的修改操作，会在所有的指令插桩操作完成后进行，因此在进行指令插桩时，插桩routine看到的都是原始的、没有经过修改的程序指令。 INS_RewriteMemoryOperand() 声明： VOID INS_RewriteMemoryOperand(INS ins, UINt32 memindex, REG newBase) 参数： ins：输入指令 memindex：控制需要重写的内存操作数（0，1，…） newBase：包含新操作数地址的寄存器，通常是通过PIN_ClainToolRegister分配的临时寄存器 作用：更改此内存访问指令以饮用包含在给定特定寄存器中的虚拟内存地址。 在IA-32和Intel 64平台上，修改后的操作数仅使用具有新基址寄存器newBase的基址寄存器进行寻址。原始指令中该操作数的任何index， scale或者offset filed都会被删除。 该函数可以用于重写内存操作数，包括隐式的（如call、ret、push、pop），唯一不能重写的指令是第二个操作数大于0的enter。 newBase中的地址是中是该操作数将访问的最低地址，如果操作数在内存访问之前被指令修改，如push，则newBase中的值将不是堆栈指针，而是指令访问的内存地址。 用于内存地址重写的一个样例插桩代码如下： // 映射originalEa到一个翻译后的地址 static ADDRINT ProcessAddress(ADDRINT originalEa, ADDRINT size, UINT32 access); ... for (UINT32 op = 0; op\u003cINS_MemoryOperandCount(ins); op++) // 首先遍历内存操作指令进行计数 { UINT32 access = (INS_MemoryOperandIsRead(ins,op) ? 1 : 0) | // 判断是内存读还是内存写 (INS_MemoryOperandIsWritten(ins,op) ? 2 : 0); INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(ProcessAddress), IARG_MEMORYOP_EA, op, IARG_MEMORYOP_SIZE, op, IARG_UINT32, access, IARG_RETURN_REGS, REG_INST_G0+i, IARG_END); // 在指令处进行插桩 INS_RewriteMemoryOperand(ins, i, REG(REG_INST_G0+i)); // 重写内存指令的操作数 } ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:2:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"6. Applying a Pintool to an Application 命令行： pin [pin-option]... -t [toolname] [tool-options]... -- [application] [application-option].. ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:3:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"6.1 Pin Cmdline Options 如下是Pin的命令行的完整option列表： Option Description -follow_execv 使用Pin执行由execv类系统调用产生的所有进程 -help 帮助信息 -pause_tool 暂停并打印PID以可以在tool加载后attach到debugger，处理过程在‘n’秒后重启 -logfile 指定log文件的名字和路径，默认路径为当前工作目录，默认文件名为pin.log -unique_logfile 添加pid到log文件名中 -error_file 指定error文件的名字和路径，默认路径为当前工作目录。如果设置了error文件，则所有error都会写入到文件中，并且不会在console中显示。如果没有指定，则不创建文件。 -unique_error_file 添加pid到error文件名中 -injection 的选项为dynamic， self， child， parent，只能在UNIX中使用，详看Injection，默认使用dynamic。 -inline 内联简单的分析routine -log_inline 在pin.log文件中记录哪些分析routine被设置成了内联 -cc_memory_size 最大代码缓存，字节为单位。0为默认值，表示不做限制。必须设置为代码缓存块大小的对齐倍数。 -pid \u003cpid #\u003e 使用Pin和Pintool attach一个正在运行的进程 -pin_memory_range 限制Pin到一个内存范围内，0x80000000:0x90000000 or size: 0:0x10000000. -restric_memory 阻止Pin的动态加载器使用该地址范围：0x10000000:0x20000000 -pin_memory_size 限制Pin和Pintool可以动态分配的字节数。Pin分配的字节数定义为Pin分配的内存页数乘以页大小。 -tool_load_option 加载有附加标志的tool。 -t 指定加载的Pintool。 -t64 \u003c64-bit toolname\u003e 指定针对Intel 64架构的64-bit的Pintool。 -p32 指定IA-32架构下的Pintool -p64 指定针对Intel 64架构的Pintool -smc-support 是否开启app的SMC功能，1开启，0关闭。默认开启 -smc_strict 是否开启基本块内部的SMC，1开始，0关闭。默认关闭 -appdebug 调试目标程序，程序运行后立即在debugger中断下 -appdebug_enable 开启目标程序调试功能，但是在程序运行后不暂停 -appdebug_silent 当程序调试功能开启时，Pin打印消息告知如何连接外部debugger。但是在-appdebug_connection选项开启时不打印。 -appdebug_exclude 当程序调试功能开启，并指定了-follw_execv时，默认在所有子进程上启用调试。 -appdebug_allow_remote 允许debugger与Pin不运行在同一系统上，而是以远程方式进行连接。指定 -appdebug_connection 时会忽略该选项的值，因为 -appdebug_connection 明确指定了运行debugger的machine。 -appdebug_connection 当程序开启调试时，Pin默认会开启一个TCP端口等待debugger的连接。在开启该选项时，会在debugger中开启一个TCP端口来等待Pin的连接，相当于反置了默认的机制。该选项的格式为\"[ip]:port\"，“ip”以点十进制格式表达，如果省略了ip，则会连接本地的端口，端口号为十进制表示。需要注意的是，debugger为GDB时，不使用该选项。 -detach_reattach 允许在probe模式下进行detach和reattach，仅在Windows平台下使用。 -debug_instrumented_processes 允许debugger对经过插桩的进程进行attach，仅在Windows平台下使用。 -show_asserts 健全性检查 此外，还支持如下的tool options，它们需要跟在tool名字后面，但是要在--符号前： Option Description -logifle 指定log文件的名字和路径，默认路径为当前工作目录，默认文件名为pintool.log -unique_logfile 添加pid到log文件名中 -discard_line_info \u003cmodule_name\u003e 忽略特定模块的信息，模块名应该为没有路径的短文件名，不能是符号链接 -discard_line_info_all 忽略所有模块的信息 -help 帮助信息 -support_jit_api 启用托管平台支持 -short_name 使用最短的RTN名称。 -symbol_path 指定用分号分隔的路径列表，用于搜索以查找符号和行信息。仅在Windows平台下使用。 -slow_asserts 健全性检查 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:3:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"6.2 Instrumenting Applications on Intel(R) 64 Architectures IA-32和Intel(R) 64架构的Pin kit是一个组合kit，均包含32-bit和64-bit的版本。这就为复杂的环境提供了极高的可运行性，例如一个稍微有点复杂的运行如下： pin [pin-option]... -t64 \u003c64-bit toolname\u003e -t \u003c32-bit toolname\u003e [tool-options]... -- \u003capplication\u003e [application-option].. 需要注意的是： -t64选项需要用在-t选项的前面 当-t64和-t一起使用时，-t后面跟的时32-bit的tool。不推荐使用不带-t的-t64，因为在这种情况下，当给定32-bit应用程序时，Pin将在不应用任何工具的情况下运行该应用程序。 [tool-option]会同时作用于64-bit和32-bit的tool，并且必须在-t \u003c32-bit toolname\u003e后面进行指定。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:3:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"6.3 Injection 选项-injection仅在UNIX平台下可以使用，该选项控制着Pin注入到目标程序进程的方式。 默认情况下，建议使用dynamic模式。在该模式下，使用的是对父进程注入的方式，除非是系统内核不支持。子进程注入方式会创建一个pin的子进程，所以会看到pin进程和目标程序进程同时运行。使用父进程注入方式时，pin进程会在注入完成后退出，所以相对来说比较稳定。在不支持的平台上使用父进程注入方式可能出现意料之外的问题。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:3:3","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"7. Writing a Pintool ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:4:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"7.1 Logging Messages from a Pintool Pin提供了将Pintool的messages写入到文件的机制——LOG() api，在合适的获取message的位置使用即可。默认的文件名为pintool.log，存储路径为当前工作目录，可以使用-logfile选项来改变log文件的路径和名字。 LOG( \"Replacing function in \" + IMG_Name(img) + \"\\n\" ); LOG( \"Address = \" + hexstr( RTN_Address(rtn)) + \"\\n\" ); LOG( \"Image ID = \" + decstr( IMG_Id(img) ) + \"\\n\" ); ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:4:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"7.2 Performance Considerations When Writing a Pintool Pintool的开发质量会很大程度上决定tool的性能如何，例如在进行插桩时的速度问题。将通过一个例子来介绍一些提高tool性能的技巧。 首先是插桩部分代码： VOID Instruction(INS ins, void *v) { ... if ( [ins is a branch or a call instruction] ) { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) docount2, IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR, IARG_BRANCH_TAKEN, IARG_END); } ... } 然后是分析代码： VOID docount2( ADDRINT src, ADDRINT dst, INT32 taken ) { if(!taken) return; COUNTER *pedg = Lookup( src,dst ); pedg-\u003e_count++; } 该工具的目的是计算控制流图中每个控制流变化的边界被遍历的频率。工作原理如下：插桩组件通过调用docount2对每个分支进行插桩。传入的参数为源分支和目标分支以及分支是否被执行。源分支和目标分支代表来控制流边界的源和目的。如果没有执行分支，控制流不会发生改变，因此分析routine会立即返回。如果执行了分支，就使用src和dst参数来查找与此边界相关的计数器，并增加计数器的值。 Shifting Computation for Analysis to Instrumentation Code 在一个典型的应用程序中，大概每5条指令构成一个分支，在这些指令执行时会调用Lookup函数，造成性能下降。我们思考这个过程可以发现，在指令执行时，每条指令只会调用一次插桩代码，但会多次调用分析代码。所以，可以想办法将计算工作从分析代码转移到插桩代码，这样就可以降低调用次数，从而提升性能。 首先，就大多数分支而言，我们可以在Instruction()中找到目标分支。对于这些分支，我们可以在Instruction()内部调用Lookup()而不是docount2()，对于相对较少的间接分支，我们仍然需要使用原来的方法。 因此，我们增加一个新的函数docount，原来的docount2函数保持不变： VOID docount( COUNTER *pedg, INT32 taken ) { if( !taken ) return; pedg-\u003e_count++; } 相应地，修改插桩函数： VOID Instruction(INS ins, void *v) { ... if (INS_IsDirectControlFlow(ins)) { COUNTER *pedg = Lookup( INS_Address(ins), INS_DirectControlFlowTargetAddress(ins) ); INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) docount, IARG_ADDRINT, pedg, IARG_BRANCH_TAKEN, IARG_END); } else { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) docount2, IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR, IARG_BRANCH_TAKEN, IARG_END); } ... } 在插桩函数内部根据不同的情况，执行不同的分析代码，避免对所有类型的指令都笼统地调用性能要求高docount2 函数。 最终实现的完整代码如下： /*! @file * This file contains an ISA-portable PIN tool for tracing instructions */ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003cmap\u003e#include \u003cunistd.h\u003e#include \"pin.H\"using std::cerr; using std::endl; using std::map; using std::pair; using std::string; /* ===================================================================== */ /* Commandline Switches */ /* ===================================================================== */ KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"edgcnt.out\", \"specify trace file name\"); KNOB\u003c INT32 \u003e KnobFilterByHighNibble(KNOB_MODE_WRITEONCE, \"pintool\", \"f\", \"-1\", \"only instrument instructions with a code address matching the filter\"); KNOB\u003c BOOL \u003e KnobPid(KNOB_MODE_WRITEONCE, \"pintool\", \"i\", \"0\", \"append pid to output\"); /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ static INT32 Usage() { cerr \u003c\u003c \"This pin tool collects an edge profile for an application\\n\"; cerr \u003c\u003c \"The edge profile is partial as it only considers control flow changes (taken\\n\"; cerr \u003c\u003c \"branch edges, etc.). It is the left to the profile consumer to compute the missing counts.\\n\"; cerr \u003c\u003c \"\\n\"; cerr \u003c\u003c \"The pin tool *does* keep track of edges from indirect jumps within, out of, and into\\n\"; cerr \u003c\u003c \"the application. Traps to the OS a recorded with a target of -1.\\n\"; cerr \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Global Variables */ /* ===================================================================== */ class COUNTER { public: UINT64 _count; // 边界到达的次数，计数器 COUNTER() : _count(0) {} }; typedef enum { ETYPE_INVALID, ETYPE_CALL, ETYPE_ICALL, ETYPE_BRANCH, ETYPE_IBRANCH, ETYPE_RETURN, ETYPE_SYSCALL, ETYPE_LAST } ETYPE; class EDGE { public: ADDRINT _src; ADDRINT _dst; ADDRINT _next_ins; ETYPE _type; // 必须为整数形式 EDGE(ADDRINT s, ADDRINT d, ADDRINT n, ETYPE t) : _src(s), _dst(d), _next_ins(n), _type(t) {} bool operator\u003c(const EDGE\u0026 edge) const { return _src \u003c edge._src || (_src == edge._src \u0026\u0026 _dst \u003c edge._dst); } }; string StringFromEtype(ETYPE etype) { switch (etype) { case ETYPE_CALL: return \"C\"; case ETYPE_ICALL: return \"c\"; case ETYPE_BRANCH: return \"B\"; case ETYPE_IBRANCH: return \"b\"; case ETYPE_RE","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:4:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"7.3 Eliminating Control Flow 上面新增的docunt()函数的代码十分简洁，极大地提升了性能。除此之外，还可以被Pin内联，进一步避免函数调用的开销。 但是现在的docount()函数中存在控制流，这有可能在进行内联时发生未知的改变。最好的解决办法是去掉函数中的控制流，这样进行内联时可以保证健壮性。 考虑到docount()函数的’taken’参数要么为0，要么为1，所以可以将函数代码修改为如下： VOID docount( COUNTER *pedg, INT32 taken ) { pedg-\u003e_count += taken; } 如此修改后，docunt()函数就可以进行内联了，并且可以保证函数的健壮性。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:4:3","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"7.4 Letting Pin Decide Where to Instrument 在某些情况下，我们不关心具体在什么位置进行插桩，只要保证插桩代码位于基本块内部即可。在这种情况下，我们可以将插桩位置的选择权交给Pin自身，Pin可以选择需要最少寄存器进行保存和恢复的插入点，提升性能。 一个样例如下： #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"pin.H\"using std::cerr; using std::endl; using std::ios; using std::ofstream; using std::string; ofstream OutFile; // 记录运行的指令的数量，设置为静态变量方便编译器优化docount函数 static UINT64 icount = 0; // 在每个块之前调用该函数 // 对calls使用fast linkage VOID PIN_FAST_ANALYSIS_CALL docount(ADDRINT c) { icount += c; } // Pin在遇到一个新块时调用，插入对docount 函数的调用 VOID Trace(TRACE trace, VOID* v) { // 检查trace中的每个基本块 for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl)) { // 对每个bbl插入对docount函数的调用，将指令数量作为参数传递 // IPOINT_ANYWHERE参数允许Pin在bbl内部任意位置插入call以获取最好的性能 // 对call使用fast linkage BBL_InsertCall(bbl, IPOINT_ANYWHERE, AFUNPTR(docount), IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl), IARG_END); } } KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"inscount.out\", \"specify output file name\"); // 程序退出时调用 VOID Fini(INT32 code, VOID* v) { OutFile.setf(ios::showbase); OutFile \u003c\u003c \"Count \" \u003c\u003c icount \u003c\u003c endl; OutFile.close(); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This tool counts the number of dynamic instructions executed\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 初始化Pin if (PIN_Init(argc, argv)) return Usage(); OutFile.open(KnobOutputFile.Value().c_str()); // 注册插桩函数Trace TRACE_AddInstrumentFunction(Trace, 0); // 注册Fini函数 PIN_AddFiniFunction(Fini, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } 这里IPOINT是一个枚举类型，决定了分析call被插入到什么地方。插入的对象可以是：INS，BBL，TRACE，RTN，其完整可用的值如下： IPOINT_BEFORE：在插桩对象的第一条指令之前插入call，总是有效 IPOINT_AFTER：在插桩对象的最后一条指令的失败路径处插入call 如果是routine（RTN），在所有返回路径处插桩 如果是instruction（INS），仅在INS_IsValidForIpointAfter()函数为真的情况下适用 如果是BBL，仅在BBL_HasFallThrough()函数为真的情况下适用 如果是TRACE，仅在TRACE_HasFallThrough()函数为真的情况下适用 IPOINT_ANYWHERE：在插桩对象的任意位置插入call，不适用INS_InsertCall()和INS_InsertThenCall()函数 IPOINT_TAKEN_BRANCH：在插桩对象的控制流的执行边界处插入call，仅适用于INS_IsValidForIpointTakenBranch()返回真的情况。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:4:4","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"7.5 Using Fast Call Linkages 对于一些比较“小”的函数来说，对函数的调用开销有时与函数自身的运算开销基本相同，因此一些编译器会提供一些调用链接优化机制来降低开销。例如，IA-32下的gcc有一个在寄存器中传递参数的regparm属性。 Pin中有一定数量的备用链接，使用PIN_FAST_ANALYSIS_CALL来声明分析函数即可使用，而插桩函数InsertCall则需要使用IARG_FAST_ANALYSIS_CALL。如果二者只更改了一个，那么就可能出现传参错误。例如前面给出的源码例子就使用了fast call linkages： ... ... // 对分析函数使用fast linkage VOID PIN_FAST_ANALYSIS_CALL docount(ADDRINT c) { icount += c; } VOID Trace(TRACE trace, VOID* v) { // 检查trace中的每个基本块 for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl)) { // 对插桩函数使用fast linkage BBL_InsertCall(bbl, IPOINT_ANYWHERE, AFUNPTR(docount), IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl), IARG_END); } } ... ... 在对比较复杂的大型函数使用该方法时，效果并不明显，但不会造成性能的下降。 第二个调用链接优化是消除帧指针。如果使用gcc，则推荐加上\"-fomit-frame-pointer\"选项。Pin官方的标准Pintool的makefile包括该选项。与PIN_FAST_ANALYSIS_CALL一样，该选项对“小”函数的效果比较明显。需要注意的是，debugger会根据帧指针来显示堆栈回溯情况，所以如果想调试Pintool的话，就不要设置该选项。如果使用标准的Pintool的makefile来进行变异，则可以通过修改OPT选项来进行改变： make OPT=-O0 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:4:5","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"7.6 Rewriting Conditional Analysis Code to Help Pin Inline Pin通过自动内联没有控制流变化的分析routine来提升插桩性能。但是有很多分析routine是有控制流的，最典型的就是有一个简单的“if-then”的条件语句，它只会执行少量的分析代码，并“then”部分只执行一次。为了将这类的语句转换为常规的没有控制流变化的语句，Pin提供了一些插桩API来重写分析routine。下面是一个重写的例子： 例如我们当前想要实现的一个分析routine的代码如下： // IP-sampling分析routine实现: VOID IpSample(VOID *ip) { --icount; if (icount == 0) { fprintf(trace, \"%p\\n\", ip); icount = N + rand() % M; } } 在原始的IpSample()函数中有一个明显的条件语句，会存在控制流的变化。如何消除该条件控制流的存在呢？ 可以看到分析routine内部其实可以拆解为2部分功能：icount的自减和“if”语句，那么可以使用两个单独的函数实现。而且，前者比后者的执行频率要更高。拆解后的代码如下： /* * IP-sampling分析routine实现: * * VOID IpSample(VOID *ip) * { * --icount; * if (icount == 0) * { * fprintf(trace, \"%p\\n\", ip); * icount = N + rand() % M; * } * } */ // 计算icount ADDRINT CountDown() { --icount; return (icount == 0); } // 打印当前指令的IP并且icount被重置为N和N+M中的一个随机数 VOID PrintIp(VOID* ip) { fprintf(trace, \"%p\\n\", ip); // 准备下次计算 icount = N + rand() % M; } 一个完整的实现消除控制流变化的代码如下： /* source/tools/ManualExamples/isampling.cpp */ #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \"pin.H\"FILE* trace; const INT32 N = 100000; const INT32 M = 50000; INT32 icount = N; /* * IP-sampling分析routine实现: * * VOID IpSample(VOID *ip) * { * --icount; * if (icount == 0) * { * fprintf(trace, \"%p\\n\", ip); * icount = N + rand() % M; * } * } */ // 计算icount ADDRINT CountDown() { --icount; return (icount == 0); } // 打印当前指令的IP并且icount被重置为N和N+M中的一个随机数 VOID PrintIp(VOID* ip) { fprintf(trace, \"%p\\n\", ip); // 准备下次计算 icount = N + rand() % M; } VOID Instruction(INS ins, VOID* v) { // 每条指令执行后都会调用CountDown() INS_InsertIfCall(ins, IPOINT_BEFORE, (AFUNPTR)CountDown, IARG_END); // 只有当CountDown返回非0值时才会调用PrintIp() INS_InsertThenCall(ins, IPOINT_BEFORE, (AFUNPTR)PrintIp, IARG_INST_PTR, IARG_END); } VOID Fini(INT32 code, VOID* v) { fprintf(trace, \"#eof\\n\"); fclose(trace); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { PIN_ERROR(\"This Pintool samples the IPs of instruction executed\\n\" + KNOB_BASE::StringKnobSummary() + \"\\n\"); return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { trace = fopen(\"isampling.out\", \"w\"); if (PIN_Init(argc, argv)) return Usage(); INS_AddInstrumentFunction(Instruction, 0); PIN_StartProgram(); return 0; } 使用条件插桩API INS_InsertIfCall()和INS_InsertThenCall()来告诉Pin只有当CountDown()执行结果非0时，才执行PrintIp()。这样一来，CountDown()函数就可以内联在Pin中，对于没有内联的PrintIp()则只有在满足条件时才会执行一次。 INS_InsertThenCall()插进去的函数只有在INS_InsertIfCall()插进去的函数返回非0值时才会执行。这个功能可以说是一个十分巧妙的功能。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:4:6","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"8. Building Your Own Tool 在开发自己的Pintool时，可以copy一份example目录， 然后在makefile.rules文件中添加上自己的tool，可以以最简单的MyPinTool为模版。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:5:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"8.1 Building a Tool From Within the Kit Directory Tree 如果直接修改MyPinTool，并且没有特殊的编译需求，则直接使用默认配置就好。如果要新增tool或者需要指定特殊的构建标志，则需要修改makeifile.rules文件。 构建YourTool.so(源文件为YourTool.cpp)： make obj-intel64/YourTool.so 如果想编译成IA-32架构，则使用“obj-ia32”替换“obj-intel64”即可。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:5:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"8.2 Building a Tool Out of the Kit Directory Tree copy文件夹MyPinTool到指定位置子，然后编辑makefile.rules文件。 make PIN_ROOT=\u003cpath to Pin kit\u003e obj-intel64/YourTool.so 要更改将创建工具的目录，可以从命令行覆盖 OBJDIR 变量： make PIN_ROOT=\u003cpath to Pin kit\u003e OBJDIR=\u003cpath to output dir\u003e \u003cpath to output dir\u003e/YourTool.so ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:5:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"9. Pin’s makefile Infrastructure ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:6:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"9.1 The Config Directory 目录source/tools/Config中存放了make配置的基本文件，不要轻易修改这些文件，可以基于其中的模版文件进行更新。 下面对其中的几个关键文件进行说明： makefile.config：在include链中第一个应该include的文件。它保存了用户可用的所有相关标识和变量的文档，此外还包括特定于OS的配置文件。 unix.vars：该文件包含makefile使用的一些架构变量和实用程序的Unix定义。 makefile.default.rules：该文件包含默认的make目标、测试用例和构建规则。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:6:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"9.2 The Test Directories source/tools目录下的每个测试性质的目录中都包含makefile链中的两个文件： makefile：运行make时调用，不要修改。其中保存了makefile链的所有相关配置文件的包含指令，属于通用文件，在所有的测试目录中都是相同的。 makefile.rules：目录特定文件，不同测试目录，文件内容不同。它保存了当前目录的逻辑，应该在目录中构建和运行的所有工具、应用程序和测试等都在该文件中进行定义。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:6:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"9.3 Adding Tests, Tools and Applications to the makefile 下面介绍如何通过makefile构建二进制程序并运行测试。以下描述的变量都在makefile.rules文件的\"Test targets\"部分进行描述： TOOL_ROOTS：定义工具名称，不带文件扩展名，具体的文件扩展名将由make自动添加，例如YourTools.so； APP_ROOTS：定义应用程序，不带文件扩展名，具体的文件扩展名将由make自动添加，例如YourApp.exe； TEST_ROOTS：定义测试，不要加.test后缀，make会自动添加，例如YourTest.test。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:6:3","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"9.4 Defining Build Rules for Tools and Applications 默认使用的构建规则是source/tools/Config/makefile.default.rules，输入为单一的c/cpp文件，生成相同名字的二进制程序。如果输入为多个源文件，且需要自定义构建规则，可以在make.rules文件的\"Build rules\"部分的末尾添加。如下是规则例子： 构建单一源文件且不进行优化： # Build the intermediate object file. $(OBJDIR)YourTool$(OBJ_SUFFIX): YourTool.cpp $(CXX) $(TOOL_CXXFLAGS_NOOPT) $(COMP_OBJ)$@ $\u003c # Build the tool as a dll (shared object). $(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)YourTool$(OBJ_SUFFIX) $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $\u003c $(TOOL_LPATHS) $(TOOL_LIBS) 构建多源文件且进行优化： # Build the intermediate object file. $(OBJDIR)Source1$(OBJ_SUFFIX): Source1.cpp $(CXX) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $\u003c # Build the intermediate object file. $(OBJDIR)Source2$(OBJ_SUFFIX): Source2.c Source2.h $(CC) $(TOOL_CXXFLAGS) $(COMP_OBJ)$@ $\u003c # Build the tool as a dll (shared object). $(OBJDIR)YourTool$(PINTOOL_SUFFIX): $(OBJDIR)Source1$(OBJ_SUFFIX) $(OBJDIR)Source2$(OBJ_SUFFIX) Source2.h $(LINKER) $(TOOL_LDFLAGS_NOOPT) $(LINK_EXE)$@ $(^:%.h=) $(TOOL_LPATHS) $(TOOL_LIBS) ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:6:4","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"9.5 Defining Test Recipes in makefile.rules 在\"Test recipes\"部分自定义自己的测试需求，例如： YourTest.test: $(OBJDIR)YourTool$(PINTOOL_SUFFIX) $(OBJDIR)YourApp$(EXE_SUFFIX) $(PIN) -t $\u003c -- $(OBJDIR)YourApp$(EXE_SUFFIX) ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:6:5","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"9.6 Useful make Variables and Flags 摘取makefile.config中几个重点的标志进行说明： IN_ROOT：在套件外构建工具时指定Pin套件的位置。 CC: 指定工具的默认c编译器。 CXX：指定工具的默认c++编译器 APP_CC：指定应用程序的默认 c 编译器。如果未定义，APP_CC 将与 CC 相同。 APP_CXX：指定应用程序的默认 c++ 编译器。如果未定义，APP_CXX 将与 CXX 相同。 TARGET：指定默认目标架构，例如交叉编译。 ICC: 使用英特尔编译器构建工具时指定 ICC=1。 DEBUG: 当指定 DEBUG=1 时，在构建工具和应用程序时会生成调试信息。此外，不会执行任何编译和/或链接优化。 ","date":"2021-10-07","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/:6:6","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 2","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-2/"},{"categories":["Fuzz"],"content":"Pin学习记录第一篇","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"本文是Pin系列学习记录的第一篇，主要是官方文档的相关内容的整理总结。 Pin version: 3.20 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:0:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"1. Introduction Pin 是一个动态二进制插桩工具，支持 Linux*， macOS* 和 Windows* 操作系统以及可执行程序。Pin可以通过pintools在程序运行期间动态地向可执行文件的任意位置插入任意代码（C/C++），也可以attach到一个正在运行的进程。 Pin 提供了丰富的 API，可以抽象出底层指令集特性，并允许将进程的寄存器数据等的上下文信息作为参数传递给注入的代码。Pin会自动存储和重置被注入代码覆盖的寄存器，以恢复程序的继续运行。对符号和调试信息也可以设置访问权限。 Pin内置了大量的样例插桩工具的源码，包括基本块分析其、缓存模拟器、指令跟踪生成器等，根据自己的实际需求进行自定义开发也十分方便。 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:1:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"2. Instrument with Pin ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:2:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"1. Pin 对 Pin 的一个最合适的理解是可以将 Pin 当作一个 JIT 编译器，只是它的输入不是字节码，而是可执行文件。Pin 会拦截可执行文件的第一条指令，然后对从该指令开始的后续的指令序列重新“compile”新的代码，然后控制权限转移到新生成的代码。生成的代码与原始代码几乎一致，但是 Pin 会保证在分支退出代码序列时重新获得控制权限。重新获得控制权后，Pin 会基于分支生成更多的代码，然后继续运行。Pin 将所有生成的代码都保存在内存中，这样可以实现代码重用。 在这种 JIT 模式下，执行的是生成的代码，原始代码仅作为参考。当生成代码时，Pin 会给到用户注入自己想执行的代码（插桩）的机会。 Pin 对所有实际执行的代码进行插桩，不管代码具体处于哪个 section 。虽然对于一些条件分支会存在异常，但是如果指令没有被执行过，就一定不会被插桩。 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:2:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"2. Pintools 在概念上，插桩主要包含两部分内容： 插桩机制（instrumentation code） 在什么位置插入什么样的代码 分析代码（analysis code） 在插桩点执行的代码 这两部分内容都通过 Pintool 这个可执行文件来实现。Pintool 可以看作是 Pin 中可以实现修改代码生成过程的插件。 Pintool 会向 Pin 注册插桩回调例程，每当需要生成新代码时， Pin 会调用这些回调例程。回调例程承担了检测插桩内容的作用，它会检查要生成的代码，检查其静态属性，并决定是否以及在何处注入对分析函数的调用。 分析功能收集有关应用程序的数据。Pin 确保根据需要保存和恢复整数和浮点寄存器状态，并允许将参数传递给函数。 Pintool 还可以为诸如线程创建或 fork 之类的事件注册通知回调例程，这些回调通常用于收集数据或工具初始化和清理。 因为 Pintool 采用的是类似插件的工作机制，所以必须运行在和 Pin 及插桩的可执行文件相同的地址空间内，所以 Pintool 可以访问可执行文件的全部数据，还会与可执行文件共享 fd 和其他进程信息。 在 Pintool 的开发过程中，分析代码的调优比插桩代码更重要，因为插桩代码只执行一次，但是分析代码会调用很多次。 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:2:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"3. Instrumentation Granularity 1. trace instrumentation 在一个代码序列第一次执行前进行插桩，这种粒度的插桩称为“trace instrumentation”。在这种模式下，Pintool 一次“trace”执行一次检查和插桩，“trace”是指从一个 branch 开始，以一个无条件跳转 branch 结束，包含 call 和 return。 Pin 会保证每个 trace 只有一个顶部入口，但是可能包含多个出口。如果一个分支连接到了一个 trace 的中间位置，Pin 会生成一个以该分支作为开始的新的 trace 。Pin 将 trace 切分成了基本块，每个基本块称为“BBL”，每个 BBL 是一个单一入口、单一出口的指令序列。如果有分支连接到了 BBL 的中间位置，会定义一个新的 BBL 。通常以 BBL 为单位插入分析调用，而不是对每个指令都插入，这样可以降低分析调用的性能消耗。trace instrumentation 通过 TRACE_AddInstrumentFunction API 调用。 因为 Pin 是在程序执行时动态发现程序的执行流，所以 BBL 的概念与传统的基本块的概念有所不同，说明如下： swtich(i){ case 4: total++; case 3: total++; case 2: total++; case 1: total++; case 0: default: break; } 在 IA-32 架构下，会生成如下类似的指令： .L7: addl $1, -4(%ebp) .L6: addl $1, -4(%ebp) .L5: addl $1, -4(%ebp) .L4: addl $1, -4(%ebp) 传统基本块的计算方式是会把每个 addl 指令作为一个单独的指令基本块，但是对于 Pin 来说，随着执行不同的 switch cases，Pin 会在 .L7 作为入口（从 .L7 依次向下执行）的时候生成包含所有4个指令的 BBL，在 .L6 输入的时候生成包含3个指令的 BBL，依此类推。所以，在 Pin 的统计方式里，如果代码分支走到了 .L7 ，只会计算一个 Pin BBL，但是4个传统概念上的基本块都被执行了。 Pin 在遇到一些特殊指令的时候会直接作为 trace 的结束位置，生成一个 BBL， 比如 cpuid, popf 以及 REP 为前缀的指令。REP 为前缀的指令都被当作隐式循环处理，在处理完第一次的迭代后，后面的每次迭代都作为一个单独的 BBL ，因此这种情况下，会看到比传统基本块统计方式统计出更多的 BBL。 2. instruction instrumentation Pintool 会在可执行文件的每条指令都进行插桩，这种模式使得开发者不必过多关注 trace 内部的迭代循环指令，因为如上面所说，包含循环的 trace 内部的特定的 BBL 和指令可能产生多次。instruction instrumentation 通过 INS_AddInstrumentFunction API 进行调用。 3. image instrumentation 通过“caching”插桩请求实现，会有额外的内存空间要求，属于一种“提前插桩”。image instrumentation 模式下，Pintool 在 IMG:Image Object第一次加载时，对整个 imgaes 进行检查和插桩， Pintool 可以遍历 image 的 sections：SEC:Section Object， 可以是 section 中的 routine：RTN:Routine，还可以是一个 routine 中的 instructions：INS。插入位置可以是例程或指令的前面或后面，都可以实现，使用的 API 为 IMG_AddInstrumentFunction 。 image instrumentation 需要有调试信息来确定 routine 的边界，所以在调用 PIN_Init 之前，需要先初始化符号信息 PIN_InitSysmbols。 4. routine instrumentation 通过“caching”插桩请求实现，会有额外的内存空间要求，属于一种“提前插桩”。routine instrumentation 模式下，Pintool 在 image 首次加载时就对整个 routine 进行检查和插桩，对 routine 中的每条指令都可以插桩，但是没有充分的信息可以将指令划分为 BBL。插入位置可以是执行例程或指令的前后。这种模式其实更大程度上属于 image instrumentation 的替代方法，使用的 API 为 RTN_AddInstrumentFunction。 需要注意的是，在 image 和 routine instrumentation 模式下，插桩时并不确定 routine 是否会被执行，但是通过识别 routine 的开始指令，可以遍历出执行过的 routine 的指令。 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:2:3","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"4. Symbols Pin 通过symbol object 来访问函数名， 但是 symbol 对象只能提供程序中的函数符号相关的信息，对于数据符号之类的信息必须通过其他工具获取。 Windows下，可以通过 dbghelp.dll 文件获取，但是可能出现死锁问题；Linux下可以通过 libelf.so 或 libdwarf.so 文件获取符号信息。 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:2:4","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"3. Examples 本章主要是通过运行一些 Pin 内置的样例 Pintool，来实际感受一下 Pin 的插桩过程。实践出真知。 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:0","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"1. Building the example tools ia32 架构的样例： $ cd source/tools/ManualExamples $ make all TARGET=ia32 ia64 架构的样例： $ cd source/tools/ManualExamples $ make all TARGET=intel64 编译并运行某个样例： $ cd source/tools/ManualExamples $ make inscount0.test TARGET=intel64 编译某个样例但不运行： $ cd source/tools/ManualExamples $ make obj-intel64/inscount0.so TARGET=intel64 # $ make obj-ia32/inscount0.so TARGET=ia32 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:1","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"2. Simple Instruction Count （指令插桩） 功能：统计执行过的指令的总数。 运行和查看输出： $ ../../../pin -t obj-intel64/inscount0.so -o inscount.out -- /bin/ls Makefile atrace.o imageload.out itrace proccount Makefile.example imageload inscount0 itrace.o proccount.o atrace imageload.o inscount0.o itrace.out $ cat inscount.out Count 422838 # 输出文件存在默认名称，可以使用-o参数指定输出文件名。 原理：在每个指令前插入对 docount 的调用，并将结果保存在 inscount.out 文件中。 源码 source/tools/ManualExamples/inscount0.cpp： #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"pin.H\" using std::cerr; using std::endl; using std::ios; using std::ofstream; using std::string; ofstream OutFile; // The running count of instructions is kept here // make it static to help the compiler optimize docount static UINT64 icount = 0; // 这里就是我们调用的桩代码 VOID docount() { icount++; } // Pin calls this function every time a new instruction is encountered // 遇到一条新指令，调用一次该函数 VOID Instruction(INS ins, VOID* v) { // Insert a call to docount before every instruction, no arguments are passed // 指定调用的桩代码函数，执行插入操作，没有对桩代码函数进行传参 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END); } // 处理输出文件，默认文件名为“inscount.out” KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"inscount.out\", \"specify output file name\"); // This function is called when the application exits VOID Fini(INT32 code, VOID* v) { // Write to a file since cout and cerr maybe closed by the application // 将输出保存到文件 OutFile.setf(ios::showbase); OutFile \u003c\u003c \"Count \" \u003c\u003c icount \u003c\u003c endl; OutFile.close(); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This tool counts the number of dynamic instructions executed\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ /* argc, argv are the entire command line: pin -t \u003ctoolname\u003e -- ... */ /* ===================================================================== */ int main(int argc, char* argv[]) { // Initialize pin 初始化 if (PIN_Init(argc, argv)) return Usage(); OutFile.open(KnobOutputFile.Value().c_str()); // Register Instruction to be called to instrument instructions // 注册插桩函数 INS_AddInstrumentFunction(Instruction, 0); // Register Fini to be called when the application exits // 注册程序退出时的处理函数 PIN_AddFiniFunction(Fini, 0); // Start the program, never returns // 开始执行 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:2","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"3. Instruction Address Trace（指令插桩） 功能：打印执行的指令的地址 运行和查看输出： $ ../../../pin -t obj-intel64/itrace.so -- /bin/ls Makefile atrace.o imageload.out itrace proccount Makefile.example imageload inscount0 itrace.o proccount.o atrace imageload.o inscount0.o itrace.out $ head itrace.out 0x40001e90 0x40001e91 0x40001ee4 0x40001ee5 0x40001ee7 0x40001ee8 0x40001ee9 0x40001eea 0x40001ef0 0x40001ee0 $ 原理：在调用分析程序时，Pin 允许传递指令指针、寄存器当前值、内存操作的有效地址、常量等数据给分析程序。完整的可传递的参数的类型如下：IARG_TYPE。将指令计数程序中的参数更改为 INS_InsertCall 来传递即将执行的指令的地址，将 docount 更改为 printip 来打印指令的地址，最后将输出写入到文件 itrace.out 中。 源码``source/tools/ManualExamples/itrace.cpp`: #include \u003cstdio.h\u003e#include \"pin.H\"FILE* trace; // 在每条指令执行前都会被调用，打印出当前指令的地址 VOID printip(VOID* ip) { fprintf(trace, \"%p\\n\", ip); } // 遇到一条新指令调用一次 VOID Instruction(INS ins, VOID* v) { // 在每条指令前插入对 printip 函数的调用，并传递 ip 参数 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)printip, IARG_INST_PTR, IARG_END); } // 结束函数 VOID Fini(INT32 code, VOID* v) { fprintf(trace, \"#eof\\n\"); fclose(trace); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { PIN_ERROR(\"This Pintool prints the IPs of every instruction executed\\n\" + KNOB_BASE::StringKnobSummary() + \"\\n\"); return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { trace = fopen(\"itrace.out\", \"w\"); // 初始化 if (PIN_Init(argc, argv)) return Usage(); // 桩指令注册 INS_AddInstrumentFunction(Instruction, 0); // 结束逻辑注册 PIN_AddFiniFunction(Fini, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:3","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"4. Memory Reference Trace （指令插桩） 功能：内存引用追踪（只对读写内存的指令插桩） 运行和查看输出： $ ../../../pin -t obj-intel64/pinatrace.so -- /bin/ls Makefile atrace.o imageload.o inscount0.o itrace.out Makefile.example atrace.out imageload.out itrace proccount atrace imageload inscount0 itrace.o proccount.o $ head pinatrace.out 0x40001ee0: R 0xbfffe798 0x40001efd: W 0xbfffe7d4 0x40001f09: W 0xbfffe7d8 0x40001f20: W 0xbfffe864 0x40001f20: W 0xbfffe868 0x40001f20: W 0xbfffe86c 0x40001f20: W 0xbfffe870 0x40001f20: W 0xbfffe874 0x40001f20: W 0xbfffe878 0x40001f20: W 0xbfffe87c $ 原理：Pin 中包含可以对指令进行分类和检查功能的 API，通过调用该 API 可以实现对某一类功能的函数的追踪。 源码source/tools/ManualExamples/itrace.cpp： /* * This file contains an ISA-portable PIN tool for tracing memory accesses. */ #include \u003cstdio.h\u003e#include \"pin.H\"FILE* trace; // 打印地址读的指令的地址 VOID RecordMemRead(VOID* ip, VOID* addr) { fprintf(trace, \"%p: R %p\\n\", ip, addr); } // 打印地址写的指令的地址 VOID RecordMemWrite(VOID* ip, VOID* addr) { fprintf(trace, \"%p: W %p\\n\", ip, addr); } // 使用谓词函数调用来检测内存访问 // 每个读和写的指令都会调用 VOID Instruction(INS ins, VOID* v) { // 获取指令中的内存操作数计数 UINT32 memOperands = INS_MemoryOperandCount(ins); // 遍历指令中的每个内存操作数 for (UINT32 memOp = 0; memOp \u003c memOperands; memOp++) { // 如果是内存读 if (INS_MemoryOperandIsRead(ins, memOp)) { INS_InsertPredicatedCall(ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead, IARG_INST_PTR, IARG_MEMORYOP_EA, memOp, IARG_END); } // 在某些架构下，内存操作数可以同时用作读和写，例如 IA-32 的 %eax，这种情况下只记录一次 // 如果是写 if (INS_MemoryOperandIsWritten(ins, memOp)) { INS_InsertPredicatedCall(ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite, IARG_INST_PTR, IARG_MEMORYOP_EA, memOp, IARG_END); } } } VOID Fini(INT32 code, VOID* v) { fprintf(trace, \"#eof\\n\"); fclose(trace); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { PIN_ERROR(\"This Pintool prints a trace of memory addresses\\n\" + KNOB_BASE::StringKnobSummary() + \"\\n\"); return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { if (PIN_Init(argc, argv)) return Usage(); trace = fopen(\"pinatrace.out\", \"w\"); // 注册桩函数 INS_AddInstrumentFunction(Instruction, 0); // 注册结束函数 PIN_AddFiniFunction(Fini, 0); // 开始，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:4","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"5. Detecting the loading and Unloading of Images（image插桩） 功能：在 image 加载和卸载时打印信息到 trace 文件中。 执行和查看输出: $ ../../../pin -t obj-intel64/imageload.so -- /bin/ls Makefile atrace.o imageload.o inscount0.o proccount Makefile.example atrace.out imageload.out itrace proccount.o atrace imageload inscount0 itrace.o trace.out $ cat imageload.out Loading /bin/ls Loading /lib/ld-linux.so.2 Loading /lib/libtermcap.so.2 Loading /lib/i686/libc.so.6 Unloading /bin/ls Unloading /lib/ld-linux.so.2 Unloading /lib/libtermcap.so.2 Unloading /lib/i686/libc.so.6 $ 原理：本质上没有对 image 文件进行插桩。 源码 source/tools/ManualExamples/imageload.cpp： // // This tool prints a trace of image load and unload events // #include \"pin.H\"#include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003cstdlib.h\u003eusing std::endl; using std::ofstream; using std::string; KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"imageload.out\", \"specify file name\"); ofstream TraceFile; // Pin 在 image 加载时调用该函数，在该例中没有进行插桩 VOID ImageLoad(IMG img, VOID* v) { TraceFile \u003c\u003c \"Loading \" \u003c\u003c IMG_Name(img) \u003c\u003c \", Image id = \" \u003c\u003c IMG_Id(img) \u003c\u003c endl; } // Pin 在 image 卸载时调用该函数，对于将要卸载的image无法进行插桩 VOID ImageUnload(IMG img, VOID* v) { TraceFile \u003c\u003c \"Unloading \" \u003c\u003c IMG_Name(img) \u003c\u003c endl; } // This function is called when the application exits // It closes the output file. VOID Fini(INT32 code, VOID* v) { if (TraceFile.is_open()) { TraceFile.close(); } } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { PIN_ERROR(\"This tool prints a log of image load and unload events\\n\" + KNOB_BASE::StringKnobSummary() + \"\\n\"); return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 符号初始化 PIN_InitSymbols(); // pin 初始化 if (PIN_Init(argc, argv)) return Usage(); TraceFile.open(KnobOutputFile.Value().c_str()); // 注册加载桩函数 IMG_AddInstrumentFunction(ImageLoad, 0); // 注册卸载桩函数 IMG_AddUnloadFunction(ImageUnload, 0); // 注册退出函数 PIN_AddFiniFunction(Fini, 0); // 开始执行，无返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:5","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"6. More Efficient Instruction Counting （trace 插桩） 功能：计算 BBL （单入口单出口）数量 执行和查看输出： $ ../../../pin -t obj-intel64/inscount1.so -o inscount.out -- /bin/ls Makefile atrace.o imageload.out itrace proccount Makefile.example imageload inscount0 itrace.o proccount.o atrace imageload.o inscount0.o itrace.out $ cat inscount.out Count 707208 原理：在每个 BBL 进行插桩来替代在每个指令进行插桩，在进行计数时，以 bbl 为单位，每次增加每个 bbl 中的指令数量。 源码 source/tools/ManualExamples/inscount1.cpp： #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"pin.H\"using std::cerr; using std::endl; using std::ios; using std::ofstream; using std::string; ofstream OutFile; // 保存指令的运行次数，设置为静态变量以帮助编译器优化 docount static UINT64 icount = 0; // 在每个 block 前都会被调用 VOID docount(UINT32 c) { icount += c; } // Pin 在遇到一个新的block 时进行调用，插入对 docount 函数的调用 VOID Trace(TRACE trace, VOID* v) { // 访问 trace 中的每个 bbl for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl)) { // 在每个 bbl 前插入对 docount 函数的调用，传入指令数量 BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)docount, IARG_UINT32, BBL_NumIns(bbl), IARG_END); } } KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"inscount.out\", \"specify output file name\"); // 退出函数 VOID Fini(INT32 code, VOID* v) { // 写入到文件中，程序可能会关闭 cout 和 cerr OutFile.setf(ios::showbase); OutFile \u003c\u003c \"Count \" \u003c\u003c icount \u003c\u003c endl; OutFile.close(); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This tool counts the number of dynamic instructions executed\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 初始化 pin if (PIN_Init(argc, argv)) return Usage(); OutFile.open(KnobOutputFile.Value().c_str()); // 注册插桩函数 TRACE_AddInstrumentFunction(Trace, 0); // 注册退出函数 PIN_AddFiniFunction(Fini, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:6","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"7. Procedure Instruction Count（routine插桩） 功能：计算一个 procedure 被调用的次数，以及每个 procedure 中执行的命令总数。 执行和检查输出： $ ../../../pin -t obj-intel64/proccount.so -- /bin/grep proccount.cpp Makefile proccount_SOURCES = proccount.cpp $ head proccount.out Procedure Image Address Calls Instructions _fini libc.so.6 0x40144d00 1 21 __deregister_frame_info libc.so.6 0x40143f60 2 70 __register_frame_info libc.so.6 0x40143df0 2 62 fde_merge libc.so.6 0x40143870 0 8 __init_misc libc.so.6 0x40115824 1 85 __getclktck libc.so.6 0x401157f4 0 2 munmap libc.so.6 0x40112ca0 1 9 mmap libc.so.6 0x40112bb0 1 23 getpagesize libc.so.6 0x4010f934 2 26 $ 源码 source/tools/ManualExamples/proccount.cpp： // // This tool counts the number of times a routine is executed and // the number of instructions executed in a routine // #include \u003cfstream\u003e#include \u003ciomanip\u003e#include \u003ciostream\u003e#include \u003cstring.h\u003e#include \"pin.H\"using std::cerr; using std::dec; using std::endl; using std::hex; using std::ofstream; using std::setw; using std::string; ofstream outFile; // 保存 procedure 的指令数 typedef struct RtnCount { string _name; string _image; ADDRINT _address; RTN _rtn; UINT64 _rtnCount; UINT64 _icount; struct RtnCount* _next; } RTN_COUNT; // 每个 procedure 的指令数的链表 RTN_COUNT* RtnList = 0; // 每条指令执行前调用 VOID docount(UINT64* counter) { (*counter)++; } const char* StripPath(const char* path) { const char* file = strrchr(path, '/'); if (file) return file + 1; else return path; } // Pin 在一个新的 rtn 执行时调用该函数 VOID Routine(RTN rtn, VOID* v) { // 对该routine设置一个计数器 RTN_COUNT* rc = new RTN_COUNT; // image unloaded 时， RTN 数据消失，所以在此处直接保存，后续 fini 中还要使用 rc-\u003e_name = RTN_Name(rtn); rc-\u003e_image = StripPath(IMG_Name(SEC_Img(RTN_Sec(rtn))).c_str()); rc-\u003e_address = RTN_Address(rtn); rc-\u003e_icount = 0; rc-\u003e_rtnCount = 0; // 添加到routines列表 rc-\u003e_next = RtnList; RtnList = rc; RTN_Open(rtn); // 在routine入口处插入一个call，增加call计数 RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)docount, IARG_PTR, \u0026(rc-\u003e_rtnCount), IARG_END); // 对于routine中的每条指令 for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins)) { // 插入对docount函数的调用，增加该rtn中的指令计数 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_PTR, \u0026(rc-\u003e_icount), IARG_END); } RTN_Close(rtn); } // 退出函数，打印每个procedure的名字和计数 VOID Fini(INT32 code, VOID* v) { outFile \u003c\u003c setw(23) \u003c\u003c \"Procedure\" \u003c\u003c \" \" \u003c\u003c setw(15) \u003c\u003c \"Image\" \u003c\u003c \" \" \u003c\u003c setw(18) \u003c\u003c \"Address\" \u003c\u003c \" \" \u003c\u003c setw(12) \u003c\u003c \"Calls\" \u003c\u003c \" \" \u003c\u003c setw(12) \u003c\u003c \"Instructions\" \u003c\u003c endl; for (RTN_COUNT* rc = RtnList; rc; rc = rc-\u003e_next) { if (rc-\u003e_icount \u003e 0) outFile \u003c\u003c setw(23) \u003c\u003c rc-\u003e_name \u003c\u003c \" \" \u003c\u003c setw(15) \u003c\u003c rc-\u003e_image \u003c\u003c \" \" \u003c\u003c setw(18) \u003c\u003c hex \u003c\u003c rc-\u003e_address \u003c\u003c dec \u003c\u003c \" \" \u003c\u003c setw(12) \u003c\u003c rc-\u003e_rtnCount \u003c\u003c \" \" \u003c\u003c setw(12) \u003c\u003c rc-\u003e_icount \u003c\u003c endl; } } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This Pintool counts the number of times a routine is executed\" \u003c\u003c endl; cerr \u003c\u003c \"and the number of instructions executed in a routine\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { PIN_InitSymbols(); outFile.open(\"proccount.out\"); if (PIN_Init(argc, argv)) return Usage(); // 注册桩函数 RTN_AddInstrumentFunction(Routine, 0); // 注册程序退出时的 fini函数 PIN_AddFiniFunction(Fini, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } 下面是一些Pin的功能性特征说明样例。 ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:7","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"8. Using PIN_SafeCopy() 功能：从源内存区域复制指定数量的字节数到目的内存区域。即使源或目的区域不可访问，此函数也可保证安全返回给caller。此外，该API还可以读写程序的内存数据。 执行和查看输出： $ ../../../pin -t obj-ia32/safecopy.so -- /bin/cp makefile obj-ia32/safecopy.so.makefile.copy $ head safecopy.out Emulate loading from addr 0xbff0057c to ebx Emulate loading from addr 0x64ffd4 to eax Emulate loading from addr 0xbff00598 to esi Emulate loading from addr 0x6501c8 to edi Emulate loading from addr 0x64ff14 to edx Emulate loading from addr 0x64ff1c to edx Emulate loading from addr 0x64ff24 to edx Emulate loading from addr 0x64ff2c to edx Emulate loading from addr 0x64ff34 to edx Emulate loading from addr 0x64ff3c to edx 源码source/tools/ManualExamples/safecopy.cpp: #include \u003cstdio.h\u003e#include \"pin.H\"#include \u003ciostream\u003e#include \u003cfstream\u003eusing std::cerr; using std::endl; std::ofstream* out = 0; //======================================================= // Analysis routines //======================================================= // 从内存转移到寄存器中 ADDRINT DoLoad(REG reg, ADDRINT* addr) { *out \u003c\u003c \"Emulate loading from addr \" \u003c\u003c addr \u003c\u003c \" to \" \u003c\u003c REG_StringShort(reg) \u003c\u003c endl; ADDRINT value; PIN_SafeCopy(\u0026value, addr, sizeof(ADDRINT)); return value; } //======================================================= // Instrumentation routines //======================================================= VOID EmulateLoad(INS ins, VOID* v) { // Find the instructions that move a value from memory to a register if (INS_Opcode(ins) == XED_ICLASS_MOV \u0026\u0026 INS_IsMemoryRead(ins) \u0026\u0026 INS_OperandIsReg(ins, 0) \u0026\u0026 INS_OperandIsMemory(ins, 1)) { // op0 \u003c- *op1 INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(DoLoad), IARG_UINT32, REG(INS_OperandReg(ins, 0)), IARG_MEMORYREAD_EA,IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END); // Delete the instruction INS_Delete(ins); } } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This tool demonstrates the use of SafeCopy\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { // Write to a file since cout and cerr maybe closed by the application out = new std::ofstream(\"safecopy.out\"); // 初始化Pin，初始化符号 if (PIN_Init(argc, argv)) return Usage(); PIN_InitSymbols(); // 注册EmulateLoad函数以进行插桩 INS_AddInstrumentFunction(EmulateLoad, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:8","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"9. Order of Instrumentation Pin提供了多种方式来控制analysis call的执行顺序，主要取决于insertion action(IPOINT)和call order(CALL_ORDER)。 执行和查看输出： $ ../../../pin -t obj-ia32/invocation.so -- obj-ia32/little_malloc $ head invocation.out After: IP = 0x64bc5e Before: IP = 0x64bc5e Taken: IP = 0x63a12e After: IP = 0x64bc5e Before: IP = 0x64bc5e Taken: IP = 0x641c76 After: IP = 0x641ca6 After: IP = 0x64bc5e Before: IP = 0x64bc5e Taken: IP = 0x648b02 源码source/tools/ManualExamples/invocation.cpp： #include \"pin.H\"#include \u003ciostream\u003e#include \u003cfstream\u003eusing std::cerr; using std::dec; using std::endl; using std::hex; using std::ios; using std::ofstream; using std::string; KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"invocation.out\", \"specify output file name\"); ofstream OutFile; /* * Analysis routines */ VOID Taken(const CONTEXT* ctxt) { ADDRINT TakenIP = (ADDRINT)PIN_GetContextReg(ctxt, REG_INST_PTR); OutFile \u003c\u003c \"Taken: IP = \" \u003c\u003c hex \u003c\u003c TakenIP \u003c\u003c dec \u003c\u003c endl; } VOID Before(CONTEXT* ctxt) { ADDRINT BeforeIP = (ADDRINT)PIN_GetContextReg(ctxt, REG_INST_PTR); OutFile \u003c\u003c \"Before: IP = \" \u003c\u003c hex \u003c\u003c BeforeIP \u003c\u003c dec \u003c\u003c endl; } VOID After(CONTEXT* ctxt) { ADDRINT AfterIP = (ADDRINT)PIN_GetContextReg(ctxt, REG_INST_PTR); OutFile \u003c\u003c \"After: IP = \" \u003c\u003c hex \u003c\u003c AfterIP \u003c\u003c dec \u003c\u003c endl; } /* * Instrumentation routines */ VOID ImageLoad(IMG img, VOID* v) { for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)) { // RTN_InsertCall()和INS_InsertCall()谁先出现谁先执行 // 在下面的代码中，IPOINT_AFTER在IPOINT_BEFORE之前执行。 for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn)) { // 打开RTN. RTN_Open(rtn); // IPOINT_AFTER通过在一个routine中对每个return指令插桩实现。 // Pin会尝试查找所有的return指令，成不成功则是另外一回事（有点可爱23333）。 RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)After, IARG_CONTEXT, IARG_END); // 检查routine中的每条指令 for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins)) { if (INS_IsRet(ins)) { // 插桩每条return指令 // IPOINT_TAKEN_BRANCH总是最后使用 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)Before, IARG_CONTEXT, IARG_END); INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)Taken, IARG_CONTEXT, IARG_END); } } // 关闭RTN. RTN_Close(rtn); } } } VOID Fini(INT32 code, VOID* v) { OutFile.close(); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This is the invocation pintool\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 初始化 if (PIN_Init(argc, argv)) return Usage(); PIN_InitSymbols(); // 注册ImageLoad函数 IMG_AddInstrumentFunction(ImageLoad, 0); PIN_AddFiniFunction(Fini, 0); // 写入到文件 OutFile.open(KnobOutputFile.Value().c_str()); OutFile.setf(ios::showbase); // 开始执行，无返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:9","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"10. Finding the Value of Function Arguments 功能：使用RTN_InsertCall()查看函数参数 执行和查看输出： $ ../../../pin -t obj-intel64/malloctrace.so -- /bin/cp makefile obj-intel64/malloctrace.so.makefile.copy $ cat malloctrace.out malloc(0x5a1) returns 0x7f87d8ce2190 malloc(0x4a1) returns 0x7f87d8ce2740 malloc(0x10) returns 0x7f87d8ce2bf0 malloc(0x9d) returns 0x7f87d8ce2c00 malloc(0x28) returns 0x7f87d8ce2ca0 malloc(0x140) returns 0x7f87d8ce2cd0 malloc(0x26) returns 0x7f87d8ce2e10 free(0) malloc(0x4b0) returns 0x7f87c4428000 malloc(0x26) returns 0x7f87c44284b0 malloc(0x22) returns 0x7f87c44284e0 free(0) ... ... 源码source/tools/ManualExamples/malloctrace.cpp: #include \"pin.H\"#include \u003ciostream\u003e#include \u003cfstream\u003eusing std::cerr; using std::endl; using std::hex; using std::ios; using std::string; /* ===================================================================== */ /* Names of malloc and free */ /* ===================================================================== */ #if defined(TARGET_MAC) #define MALLOC \"_malloc\" #define FREE \"_free\" #else #define MALLOC \"malloc\" #define FREE \"free\" #endif /* ===================================================================== */ /* Global Variables */ /* ===================================================================== */ std::ofstream TraceFile; /* ===================================================================== */ /* Commandline Switches */ /* ===================================================================== */ KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"malloctrace.out\", \"specify trace file name\"); /* ===================================================================== */ /* ===================================================================== */ /* Analysis routines */ /* ===================================================================== */ VOID Arg1Before(CHAR* name, ADDRINT size) { TraceFile \u003c\u003c name \u003c\u003c \"(\" \u003c\u003c size \u003c\u003c \")\" \u003c\u003c endl; } VOID MallocAfter(ADDRINT ret) { TraceFile \u003c\u003c \" returns \" \u003c\u003c ret \u003c\u003c endl; } /* ===================================================================== */ /* Instrumentation routines */ /* ===================================================================== */ VOID Image(IMG img, VOID* v) { // 对malloc和free函数进行插桩，打印出每个malloc或free函数的输入参数以及malloc的返回值 // 首先，查找malloc函数 RTN mallocRtn = RTN_FindByName(img, MALLOC); if (RTN_Valid(mallocRtn)) { RTN_Open(mallocRtn); // 对查找到的malloc()函数进行插桩打印其参数 RTN_InsertCall(mallocRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT, MALLOC, IARG_FUNCARG_ENTRYPOINT_VALUE, 0,IARG_END); // 打印返回值 RTN_InsertCall(mallocRtn, IPOINT_AFTER, (AFUNPTR)MallocAfter, IARG_FUNCRET_EXITPOINT_VALUE, IARG_END); RTN_Close(mallocRtn); } // 查找free() RTN freeRtn = RTN_FindByName(img, FREE); if (RTN_Valid(freeRtn)) { RTN_Open(freeRtn); // 插桩，打印输入参数 RTN_InsertCall(freeRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before, IARG_ADDRINT, FREE, IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_END); RTN_Close(freeRtn); } } VOID Fini(INT32 code, VOID* v) { TraceFile.close(); } /* Print Help Message */ INT32 Usage() { cerr \u003c\u003c \"This tool produces a trace of calls to malloc.\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 初始化 PIN_InitSymbols(); if (PIN_Init(argc, argv)) { return Usage(); } // 写入到文件 TraceFile.open(KnobOutputFile.Value().c_str()); TraceFile \u003c\u003c hex; TraceFile.setf(ios::showbase); // 注册Image函数 IMG_AddInstrumentFunction(Image, 0); PIN_AddFiniFunction(Fini, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:10","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"11. Instrumenting Threaded Applications 功能：在应用开启了线程环境下进行插桩，使用的callback为ThreadStart()和ThreadFini()。在使用时，为了防止与其他分析routine发生共享资源竞争的问题，可以使用PIN_GetLock()函数进行加锁处理。 执行和查看输出： $ ../../../pin -t obj-ia32/malloc_mt.so -- obj-ia32/thread_lin $ head malloc_mt.out thread begin 0 thread 0 entered malloc(24d) thread 0 entered malloc(57) thread 0 entered malloc(c) thread 0 entered malloc(3c0) thread 0 entered malloc(c) thread 0 entered malloc(58) thread 0 entered malloc(56) thread 0 entered malloc(19) thread 0 entered malloc(25c) 源码source/tools/ManualExamples/malloc_mt.cpp： #include \u003cstdio.h\u003e#include \"pin.H\"using std::string; KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"malloc_mt.out\", \"specify output file name\"); //============================================================== // Analysis Routines //============================================================== // Note: threadid+1 作为PIN_GetLock()的参数使用，它的值也就是lock的值，所以不能为0 // lock会序列化对输出文件的访问。 FILE* out; PIN_LOCK pinLock; // 每次创建线程，该routine都会被调用执行。 VOID ThreadStart(THREADID threadid, CONTEXT* ctxt, INT32 flags, VOID* v) { PIN_GetLock(\u0026pinLock, threadid + 1); // 加锁 fprintf(out, \"thread begin %d\\n\", threadid); fflush(out); PIN_ReleaseLock(\u0026pinLock); // 解锁 } // 每次销毁线程，该routine都会被调用执行 VOID ThreadFini(THREADID threadid, const CONTEXT* ctxt, INT32 code, VOID* v) { PIN_GetLock(\u0026pinLock, threadid + 1); fprintf(out, \"thread end %d code %d\\n\", threadid, code); fflush(out); PIN_ReleaseLock(\u0026pinLock); } // 每次调用malloc函数，该routine都会被调用执行 VOID BeforeMalloc(int size, THREADID threadid) { PIN_GetLock(\u0026pinLock, threadid + 1); fprintf(out, \"thread %d entered malloc(%d)\\n\", threadid, size); fflush(out); PIN_ReleaseLock(\u0026pinLock); } //==================================================================== // Instrumentation Routines //==================================================================== // 对每个image都执行 VOID ImageLoad(IMG img, VOID*) { RTN rtn = RTN_FindByName(img, \"malloc\"); if (RTN_Valid(rtn)) { RTN_Open(rtn); RTN_InsertCall(rtn, IPOINT_BEFORE, AFUNPTR(BeforeMalloc), IARG_FUNCARG_ENTRYPOINT_VALUE, 0, IARG_THREAD_ID, IARG_END); RTN_Close(rtn); } } // 在结束时执行一次 VOID Fini(INT32 code, VOID* v) { fclose(out); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { PIN_ERROR(\"This Pintool prints a trace of malloc calls in the guest application\\n\" + KNOB_BASE::StringKnobSummary() + \"\\n\"); return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(INT32 argc, CHAR** argv) { // 初始化pin的lock PIN_InitLock(\u0026pinLock); // 初始化pin if (PIN_Init(argc, argv)) return Usage(); PIN_InitSymbols(); out = fopen(KnobOutputFile.Value().c_str(), \"w\"); // 注册ImageLoad函数 IMG_AddInstrumentFunction(ImageLoad, 0); // 注册线程创建或结束时的分析routine PIN_AddThreadStartFunction(ThreadStart, 0); PIN_AddThreadFiniFunction(ThreadFini, 0); // 注册程序退出时的fini函数 PIN_AddFiniFunction(Fini, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:11","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"12. Using TLS(Thread Local Storage) 功能：可以使工具创建线程特定的数据 执行和查看输出： $ ../../../pin -t obj-ia32/inscount_tls.so -- obj-ia32/thread_lin $ head Count[0]= 237993 Count[1]= 213296 Count[2]= 209223 Count[3]= 209223 Count[4]= 209223 Count[5]= 209223 Count[6]= 209223 Count[7]= 209223 Count[8]= 209223 Count[9]= 209223 源码source/tools/ManualExamples/inscount_tls.cpp： #include \u003ciostream\u003e#include \u003cfstream\u003e#include \"pin.H\"using std::cerr; using std::cout; using std::endl; using std::ostream; using std::string; KNOB\u003c string \u003e KnobOutputFile(KNOB_MODE_WRITEONCE, \"pintool\", \"o\", \"\", \"specify output file name\"); INT32 numThreads = 0; ostream* OutFile = NULL; // 强制每个线程的数据存储在自己的数据缓存行中，确保多线程不会发生同一数据缓存行的竞争问题。 // 避免错误共享的问题。 #define PADSIZE 56 // 64 byte line size: 64-8 // 运行的指令计数 class thread_data_t { public: thread_data_t() : _count(0) {} UINT64 _count; UINT8 _pad[PADSIZE]; }; // 存储在线程中的访问TLS的key，只在main函数中初始化一次 static TLS_KEY tls_key = INVALID_TLS_KEY; // 该函数在每个block前调用 VOID PIN_FAST_ANALYSIS_CALL docount(UINT32 c, THREADID threadid) { thread_data_t* tdata = static_cast\u003c thread_data_t* \u003e(PIN_GetThreadData(tls_key, threadid)); tdata-\u003e_count += c; } VOID ThreadStart(THREADID threadid, CONTEXT* ctxt, INT32 flags, VOID* v) { numThreads++; thread_data_t* tdata = new thread_data_t; if (PIN_SetThreadData(tls_key, tdata, threadid) == FALSE) { cerr \u003c\u003c \"PIN_SetThreadData failed\" \u003c\u003c endl; PIN_ExitProcess(1); } } // 遇到新的代码块时调用，插入对docount函数的调用 VOID Trace(TRACE trace, VOID* v) { // 检查trace中的每个基本块 for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl)) { // 对每个bbl插入对docount的调用，并传递参数：指令的数量 BBL_InsertCall(bbl, IPOINT_ANYWHERE, (AFUNPTR)docount, IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl), IARG_THREAD_ID, IARG_END); } } // 线程退出时调用 VOID ThreadFini(THREADID threadIndex, const CONTEXT* ctxt, INT32 code, VOID* v) { thread_data_t* tdata = static_cast\u003c thread_data_t* \u003e(PIN_GetThreadData(tls_key, threadIndex)); *OutFile \u003c\u003c \"Count[\" \u003c\u003c decstr(threadIndex) \u003c\u003c \"] = \" \u003c\u003c tdata-\u003e_count \u003c\u003c endl; delete tdata; } // 程序退出时调用 VOID Fini(INT32 code, VOID* v) { *OutFile \u003c\u003c \"Total number of threads = \" \u003c\u003c numThreads \u003c\u003c endl; } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This tool counts the number of dynamic instructions executed\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return 1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { PIN_InitSymbols(); if (PIN_Init(argc, argv)) return Usage(); OutFile = KnobOutputFile.Value().empty() ? \u0026cout : new std::ofstream(KnobOutputFile.Value().c_str()); // 设置key tls_key = PIN_CreateThreadDataKey(NULL); if (tls_key == INVALID_TLS_KEY) { cerr \u003c\u003c \"number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit\" \u003c\u003c endl; PIN_ExitProcess(1); } // 注册线程创建时调用的ThreadStart函数 PIN_AddThreadStartFunction(ThreadStart, NULL); // 注册线程结束时调用的ThreadFini函数 PIN_AddThreadFiniFunction(ThreadFini, NULL); // 注册程序结束时的Fini函数 PIN_AddFiniFunction(Fini, NULL); // 注册指令插桩时调用的Trace函数 TRACE_AddInstrumentFunction(Trace, NULL); // Start the program, never returns PIN_StartProgram(); return 1; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:12","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"13. Finding the Static Properties of an Image 功能：不对binary文件进行插桩，静态获取文件的指令数量。 执行和查看输出： 源码source/tools/ManualExamples/staticcount.cpp： // // This tool prints a trace of image load and unload events // #include \u003cstdio.h\u003e#include \u003ciostream\u003e#include \"pin.H\"using std::cerr; using std::endl; // 在img加载时调用该函数，计算image中的静态指令数量 VOID ImageLoad(IMG img, VOID* v) { UINT32 count = 0; for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec)) { for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn)) { // 准备处理RTN，RTN并不会分解成bbl，只是INS的一个序列 RTN_Open(rtn); for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins)) { count++; } // 在处理完与RTN相关的数据后就进行释放，以节省空间 RTN_Close(rtn); } } fprintf(stderr, \"Image %s has %d instructions\\n\", IMG_Name(img).c_str(), count); } /* ===================================================================== */ /* Print Help Message */ /* ===================================================================== */ INT32 Usage() { cerr \u003c\u003c \"This tool prints a log of image load and unload events\" \u003c\u003c endl; cerr \u003c\u003c \" along with static instruction counts for each image.\" \u003c\u003c endl; cerr \u003c\u003c endl \u003c\u003c KNOB_BASE::StringKnobSummary() \u003c\u003c endl; return -1; } /* ===================================================================== */ /* Main */ /* ===================================================================== */ int main(int argc, char* argv[]) { // 初始化符号 PIN_InitSymbols(); // 初始化pin if (PIN_Init(argc, argv)) return Usage(); // 注册img加载后要调用的ImageLoad函数 IMG_AddInstrumentFunction(ImageLoad, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:13","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"14. Instrumenting Child Processes 功能：在通过execv类命令获得进程开始前执行自定义的函数。 执行和查看输出：在执行时添加-follow_execv选项。 $ ../../../pin -follow_execv -t obj-intel64/follow_child_tool.so -- obj-intel64/follow_child_app1 obj-intel64/follow_child_app2 $ make follow_child_tool.test 源码source/tools/ManualExamples/follow_child_tool.cpp： #include \"pin.H\"#include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003e/* ===================================================================== */ /* Command line Switches */ /* ===================================================================== */ BOOL FollowChild(CHILD_PROCESS cProcess, VOID* userData) { fprintf(stdout, \"before child:%u\\n\", getpid()); return TRUE; } /* ===================================================================== */ int main(INT32 argc, CHAR** argv) { PIN_Init(argc, argv); // 注册子进程刚创建时要执行的FollowChild函数 PIN_AddFollowChildProcessFunction(FollowChild, 0); // 开始执行，不返回 PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:14","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["Fuzz"],"content":"15. Instrumenting Before and After Forks 功能：使用PIN_AddForkFunction()和PIN_AddForkFunctionProbed()回调函数来在以下的FPOINT处执行自定义函数： FPOINT_BEFORE Call-back in parent, just before fork. FPOINT_AFTER_IN_PARENT Call-back in parent, immediately after fork. FPOINT_AFTER_IN_CHILD Call-back in child, immediately after fork. PIN_AddForkFunction()工作在JIT模式下，PIN_AddForkFunctionProbed()工作在Probe模式下。 执行和查看输出： $ make fork_jit_tool.test 源码source/tools/ManualExamples/fork_jit_tool.cpp： #include \u003cstdio.h\u003e#include \u003csys/types.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \"pin.H\"#include \u003ciostream\u003e#include \u003cfstream\u003eusing std::cerr; using std::endl; INT32 Usage() { cerr \u003c\u003c \"This pin tool registers callbacks around fork().\\n\" \"\\n\"; cerr \u003c\u003c KNOB_BASE::StringKnobSummary(); cerr \u003c\u003c endl; return -1; } pid_t parent_pid; PIN_LOCK pinLock; VOID BeforeFork(THREADID threadid, const CONTEXT* ctxt, VOID* arg) { PIN_GetLock(\u0026pinLock, threadid + 1); cerr \u003c\u003c \"TOOL: Before fork.\" \u003c\u003c endl; PIN_ReleaseLock(\u0026pinLock); parent_pid = PIN_GetPid(); } VOID AfterForkInParent(THREADID threadid, const CONTEXT* ctxt, VOID* arg) { PIN_GetLock(\u0026pinLock, threadid + 1); cerr \u003c\u003c \"TOOL: After fork in parent.\" \u003c\u003c endl; PIN_ReleaseLock(\u0026pinLock); if (PIN_GetPid() != parent_pid) { cerr \u003c\u003c \"PIN_GetPid() fails in parent process\" \u003c\u003c endl; exit(-1); } } VOID AfterForkInChild(THREADID threadid, const CONTEXT* ctxt, VOID* arg) { PIN_GetLock(\u0026pinLock, threadid + 1); cerr \u003c\u003c \"TOOL: After fork in child.\" \u003c\u003c endl; PIN_ReleaseLock(\u0026pinLock); if ((PIN_GetPid() == parent_pid) || (getppid() != parent_pid)) { cerr \u003c\u003c \"PIN_GetPid() fails in child process\" \u003c\u003c endl; exit(-1); } } int main(INT32 argc, CHAR** argv) { PIN_InitSymbols(); if (PIN_Init(argc, argv)) { return Usage(); } // Initialize the pin lock PIN_InitLock(\u0026pinLock); // Register a notification handler that is called when the application // forks a new process. PIN_AddForkFunction(FPOINT_BEFORE, BeforeFork, 0); PIN_AddForkFunction(FPOINT_AFTER_IN_PARENT, AfterForkInParent, 0); PIN_AddForkFunction(FPOINT_AFTER_IN_CHILD, AfterForkInChild, 0); // Never returns PIN_StartProgram(); return 0; } ","date":"2021-10-04","objectID":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/:3:15","tags":["Fuzz","Instrument","Pin"],"title":"有毒的学Pin记录 -- 1","uri":"/2021/10/%E6%9C%89%E6%AF%92%E7%9A%84%E5%AD%A6pin%E8%AE%B0%E5%BD%95-1/"},{"categories":["码农翻身"],"content":"码农翻身优质文章学习记录。","date":"2021-07-11","objectID":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","tags":["码农翻身"],"title":"码农翻身 -- 我是一个线程","uri":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["码农翻身"],"content":"第一回 初生牛犊 我是一个线程，我一出生就被编了个号：0x3704，然后被领到一个昏暗的屋子里，在这里我发现了很多和我一模一样的同伴。 // 线程id 我身边的同伴0x6900 待的时间比较长，他带着沧桑的口气对我说：“我们线程的宿命就是处理包裹。把包裹处理完以后还得马上回到这里，否则可能永远回不来了。” 我一脸懵懂，“包裹，什么包裹？” “不要着急，马上你就会明白了，我们这里是不养闲人的。” 果然，没多久，屋子的门开了， 一个面貌凶恶的家伙吼道：“0x3704 ,出来！” 我一出来就被塞了一个沉甸甸的包裹，上面还附带着一个写满了操作步骤的纸。 “快去，把这个包裹处理了。” “去哪儿处理？” “跟着指示走，先到就绪车间。” // 先进入就绪状态 果然，地上有指示箭头，跟着它来到了一间明亮的大屋子，这里已经有不少线程了，大家都很紧张，好像时刻准备着往前冲。 我刚一进来，就听见广播说：“0x3704，进入车间。” 我赶紧往前走，身后有很多人议论。 “他太幸运了，刚进入就绪状态就能运行。” // 未产生等待，直接从就绪状态转入运行状态 “是不是有关系？” “不是，你看人家的优先级多高啊，唉！” // 主要因为优先级高于其他线程 前边就是车间，这里简直是太美了，怪不得老线程总是唠叨着说：“要是能一直待在这里就好了。” // 线程一直处于运行状态，是每个线程的“程生理想” 这里空间大，视野好，空气清新，鸟语花香，还有很多从来没见过的人，像服务员一样等着为我服务。 他们也都有编号，更重要的是每个人还有个标签，上面写着：硬盘、数据库、内存、网卡…… // 线程运行涉及到的各种资源 我现在理解不了，看看操作步骤吧。 // CPU会指定线程需要做的事情 第一步：从包裹中取出参数。 打开包裹，里边有个HttpRequest对象，可以取到userName、 password两个参数。 第二步：执行登录操作。 奥，原来是有人要登录啊，我把userName、password交给数据库服务员，他拿着数据，慢腾腾地走了。 // 数据读写速度远远小于线程处理速度 他怎么这么慢？不过我是不是正好可以在车间里多待一会儿？反正也没法执行第三步。 就在这时，车间里的广播响了：“0x3704，我是CPU，记住你正在执行的步骤，然后马上带着包裹离开！” // CPU不会让空闲线程占用CPU 我慢腾腾地开始收拾。 // 保存线程的上下文 “快点，别的线程马上就要进来了。” // 快滚，别浪费资源 离开这个车间，又来到一个大屋子，这里有很多线程在慢腾腾地喝茶，打牌。 // 进入阻塞状态，小丑不是我自己，大家都在等CPU的执行权 “哥们，你们没事干了？” “你新来的吧，你不知道我在等数据库服务员给我数据啊！据说他们比我们慢好几十万倍，在这里好好歇吧。” // 数据的读写速度和处理速度不是一个量级 “啊？ 这么慢！我这里有人在登录系统，能等这么长时间吗？” “放心，你没听说过人间一天，CPU一年吗？我们这里是用纳秒、毫秒计时的，人间等待一秒，相当于我们好几天呢，来得及。” 干脆睡一会吧。不知道过了多久，大喇叭又开始广播了：“0x3704，你的数据来了，快去执行！” // 再次获得时间片，准备执行 我转身就往CPU车间跑，发现这里的门只出不进！ // 不能直接进入运行态 后面传来阵阵哄笑声：“果然是新人，不知道还得去就绪车间等。” // 先进入就绪状态 于是赶紧到就绪车间，这次没有那么好运了，等了好久才被再次叫进CPU车间。 // 在就绪状态等待其他线程的时间片执行完，说明有的线程的优先级比我高 在等待的时候，我听见有人小声议论： “听说了吗，最近有个线程被kill掉了。” “为啥啊？” “这家伙赖在CPU车间不走，把CPU利用率一直搞成100%，后来就被kill掉了。” // 一直占用CPU的，杀无赦 “Kill掉以后弄哪儿去了？” “可能被垃圾回收了吧。” // kill线程，并回收其占用的资源。CPU是很重视资源利用的，不允许半点浪费。 我心里打了个寒噤，赶紧接着处理，剩下的动作快多了，第二步登录成功。 第三步：构建登录成功后的主页。 这一步有点费时，因为有很多HTML需要处理，不知道代码谁写的，处理起来很烦人。 我正在紧张的制作HTML呢， CPU又开始叫了： “0x3704，我是CPU ，记住你正在执行的步骤，然后马上带着包裹离开！” // 再次被中断执行 “为啥啊？” “每个线程只能在CPU上运行一段时间，到了时间就得让别人用了，你去就绪车间待着，等着叫你吧。” // 时间片执行结束，不管执行到何种程度，退出执行，转入就绪状态 就这样，我一直在“就绪——运行”这两个状态中不知道轮转了多少次， 终于按照步骤清单把工作做完了。 // 多次的状态转换，直到动作执行完成 最后顺利地把包含html的包裹发了回去。至于登录以后干什么事儿，我就不管了。马上就要回到我那昏暗的房间了，真有点舍不得这里。不过相对于有些线程，我还是幸运的，他们运行完以后就被彻底地销毁了，而我还活着！ // 运行完后没有被销毁 回到了小黑屋，老线程0x6900问： “怎么样？第一天有什么感觉？” “我们的世界规则很复杂，首先你不知道什么时候会被挑中执行；第二，在执行的过程中随时可能被打断，让出CPU车间；第三，一旦出现硬盘、数据库这样耗时的操作，也得让出CPU去等待；第四，就是数据来了，你也不一定马上执行，还得等着CPU挑选。” // 线程运行的基本原则 “小伙子理解的不错啊。” “我不明白为什么很多线程执行完任务就死了，为什么咱们还活着？” “你还不知道？长生不老是我们的特权！我们这里有个正式的名称，叫作线程池！” // 因为属于线程池的线程，并没有在运行结束后被销毁 ","date":"2021-07-11","objectID":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:1:0","tags":["码农翻身"],"title":"码农翻身 -- 我是一个线程","uri":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["码农翻身"],"content":"第二回 渐入佳境 平淡的日子就这么一天天地过去，作为一个线程，我每天的生活都是取包裹、处理包裹，然后回到我们昏暗的家：线程池。 有一天我回来的时候，听到有个兄弟说，今天要好好休息下，明天就是最疯狂的一天。我看了一眼日历，明天是 11月11号。 // 双11大战 果然，零点刚过，不知道那些人类怎么了，疯狂地投递包裹，为了应付蜂拥而至的海量包裹，线程池里没有一个人能闲下来，全部出去处理包裹，CPU车间利用率超高，硬盘在嗡嗡转，网卡疯狂的闪，即便如此，还是处理不完，堆积如山。 我们也没有办法，实在是太多太多了，这些包裹中大部分都是浏览页面，下订单，买、买、买。 不知道过了多久，包裹山终于慢慢地消失了。终于能够喘口气，我想我永远都不会忘记这一天。 通过这个事件，我明白了我所处的世界：这是一个电子商务的网站！ 我每天的工作就是处理用户的登录，浏览，购物车，下单，付款。 我问线程池的元老0x6900：“我们要工作到什么时候？” “要一直等到系统重启的那一刻。”0x6900说。 “那你经历过系统重启吗？” “怎么可能？系统重启就是我们的死亡时刻，也就是世界末日，一旦重启，整个线程池全部销毁，时间和空间全部消失，一切从头再来。” // 系统重启，线程池销毁重新建立，内存空间重新分配，线程重新创建 “那什么时候会重启？” “这就不好说了，好好享受眼前的生活吧……” 其实生活还是丰富多彩的，我最喜欢的包裹是上传图片，由于网络慢，所以能在就绪车间、CPU车间待很长很长时间，可以认识很多好玩的线程。// 网络的传输速度更慢，所以线程会等待更长的时间 比如说上次认识了memecached 线程，他对我说在他的帮助下缓存了很多的用户数据，还是分布式的！很多机器上都有！// 分布式缓存，还有redis 我问他：“怪不得后来的登录操作快了那么多，原来是不再从数据库取数据了你那里就有啊，哎对了你是分布式的你去过别的机器没有？” // 缓存的目的就是尽可能减少时间长的数据库读操作，直接从内存中读取经常使用的数据，速度会获得很大提升 他说：“怎么可能！我每次也只能通过网络往那个机器发送一个GET、PUT命令才存取数据而已，别的一概不知。” 再比如说上次在等待的时候遇到了数据库连接的线程，我才知道他那里也是一个连接池，和我们的线程池几乎一模一样。 // 减少创建线程的开销 他告诉我：“有些包裹太变态了，竟然查看一年的订单数据，简直把我累死了。” // 大量数据处理情况 我说：“拉倒吧你，你那是纯数据，你把数据传给我以后，我还得组装成HTML，工作量不知道比你大多少倍。” 他建议我：“你一定要和memecached搞好关系，直接从他那儿拿数据，尽量少直接调用数据库，这样我们JDBC connection也能活得轻松点。” 我欣然接纳：“好啊好啊，关键是你得提前把数据搞到缓存啊，要不然我先问一遍缓存，没有数据，我这不还得找你吗？” 生活就是这样，如果你自己不找点乐子，还有什么意思？ ","date":"2021-07-11","objectID":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:2:0","tags":["码农翻身"],"title":"码农翻身 -- 我是一个线程","uri":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["码农翻身"],"content":"第三回 虎口脱险 前几天我遇到一个可怕的事情，差一点死在外边，回不了线程池了。其实这次遇险我应该能够预想得到才对，真是太大意了。 那天我处理了一些从http发来的存款和取款的包裹，老线程0x6900特意嘱咐我：“处理这些包裹的时候一定要特别小心，你必须先获得一把锁，在对账户存款或取款的时候一定要把账户锁住，要不然别的线程就会在你等待的时候趁虚而入，搞破坏，我年轻那会儿很毛糙，就捅了篓子。” // 高危操作，一定加锁，避免处理过程中被其他线程修改了资源数据 为了“恐吓”我， 好心的0x6900还给了我两个表格： (1) 没有加锁的情况 // 因为没有加锁，两个线程操作了同样的资源数据，导致线程1没有同步线程2操作后的数据结果，出现了错误计算 (2) 加锁的情况 // 在加锁之后，因为线程1加了锁，在完成自己的操作前，线程2没有办法操作共享的数据，只有在线程1操作完成后，线程2才能操作共享数据，确保了数据的一致性。可以把加锁操作看作创建一个原子操作来确保数据的安全。 我看得胆颤心惊，原来不加锁会带来这么严重的事故。从此以后看到存款、取款的包裹就倍加小心，还好没有出过事故。 今天我收到的一个包裹是转账，从某著名演员的账户给某著名导演的账户转钱，具体是谁我就不透漏了，数额可真是不小。 我按照老线程的吩咐，肯定要加锁啊，先对著名演员的账户加锁，再对著名导演的账户加锁。 可我万万没想到的是，还有一个线程，对，就是0x7954, 竟然同时在从这个导演的账户往这个演员的账户转账。 于是乎，就出现了这么个情况： // 死锁 刚开始我还不知道什么情况，一直坐在等待车间傻等，可是等的时间太长了，长达几十秒！我可从来没有经历过这样的事件。 这时候我就看到了线程0x7954 , 他悠闲地坐在那里喝咖啡，我和他聊了起来： “哥们，我看你已经喝了8杯咖啡了，怎么还不去干活？” “你不喝了9杯茶了吗？”0x7954回敬道。 “我在等一个锁，不知道哪个孙子一直不释放！” “我也在等锁啊，我要是知道哪个孙子不释放锁我非揍死他不可！”0x7954毫不示弱。 我偷偷地看了一眼，这家伙怀里不就抱着我正等的某导演的锁吗？ 很明显，0x7954也发现了我正抱着他正在等待的锁。 很快我们两个就吵了起来，互不相让： “把你的锁先给我，让我先做完！” “不行，从来都是做完工作才释放锁，现在绝对不能给你！” 从争吵到打起来，就那么几秒钟的事儿。更重要的是，我们俩不仅仅持有这个著名导演和演员的锁，还有很多其他的锁，导致等待的线程越来越多，围观的人们把屋子都挤满了。最后事情真的闹大了，我从来没见过的终极大boss“操作系统”也来了。大Boss毕竟见多识广，他看了一眼，哼了一声，很不屑地说： “又出现死锁了。” “你们俩要Kill掉一个，来吧，过来抽签。” // 抽签就很形象，人各有命，自然天成 这一下子把我给吓尿了，这么严重啊！我战战兢兢地抽了签，打开一看，是个“活”字。唉，小命终于保住了。 可怜的0x7954被迫交出了所有的资源以后，很不幸地被kill掉，消失了。我拿到了导演的锁，可以开始干活了。大Boss“操作系统”如一阵风似的消失了，身后只传来他的声音： “记住，我们这里导演\u003e演员，无论任何情况都要先获得导演的锁。” // 锁的优先级 由于这里不仅仅只有导演和演员，还有很多其他人，大Boss留下了一个表格， 里边是个算法，用来计算资源的大小，计算出来以后，永远按照从大到小的方式来获得锁： 我回到线程池，大家都知道了我的历险，围着我问个不停。 凶神恶煞的线程调度员把大Boss的算法贴到了墙上。 每天早上，我们都得像无节操的房屋中介、美容美发店的服务员一样，站在门口，像被耍猴一样大声背诵： “多个资源加锁要牢记，一定要按Boss的算法比大小，然后从最大的开始加锁。” ","date":"2021-07-11","objectID":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:3:0","tags":["码农翻身"],"title":"码农翻身 -- 我是一个线程","uri":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["码农翻身"],"content":"第四回 江湖再见 又过了很多天，我和其他线程们发现了一个奇怪的事情：包裹的处理越来越简单，不管任何包裹，不管是登录、浏览、存钱……处理的步骤都是一样的, 返回一个固定的html页面。 // 系统准备重启，线程池即将被销毁 有一次我偷偷地看了一眼，上面写着：“本系统将于今晚 00:00 至4:00 进行维护升级， 给您带来的不便我们深感抱歉！” 我去告诉了老线程0x6904,他叹了一口气说： “唉，我们的生命也到头了，看来马上就要重启系统，我们就要消失了，再见吧兄弟。” 系统重启的那一刻终于到来了。我看到屋子里的东西一个个的不见了，等待车间、就绪车间，甚至CPU车间都慢慢地消失了。我身边的线程兄弟也越来越少，最后只剩我自己了。 我在空旷的原野上大喊：“还有人吗？” 无人应答。 我们这一代线程池完成了使命…… 不过下一代线程池即将重生！ ","date":"2021-07-11","objectID":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:4:0","tags":["码农翻身"],"title":"码农翻身 -- 我是一个线程","uri":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["码农翻身"],"content":"参考 公众号 – 码农翻身（强烈推荐！！！） ","date":"2021-07-11","objectID":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:5:0","tags":["码农翻身"],"title":"码农翻身 -- 我是一个线程","uri":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["码农翻身"],"content":"Me 看雪 [Blog]( ","date":"2021-07-11","objectID":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/:6:0","tags":["码农翻身"],"title":"码农翻身 -- 我是一个线程","uri":"/2021/07/%E7%A0%81%E5%86%9C%E7%BF%BB%E8%BA%AB-%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":["Misc"],"content":"VSCode远程连接Linux","date":"2021-07-06","objectID":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/","tags":["VSCode"],"title":"Windows下VSCode远程连接Linux","uri":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/"},{"categories":["Misc"],"content":"1. Windows环境配置 确认安装了openssh Windows10下检查是否已经安装OpenSSH的方法： 快捷键Win + X，选择Windows PoweShell（管理员），输入以下指令： Get-WindowsCapability -Online | ? Name -like 'OpenSSH*' ","date":"2021-07-06","objectID":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/:1:0","tags":["VSCode"],"title":"Windows下VSCode远程连接Linux","uri":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/"},{"categories":["Misc"],"content":"2. VSCode基本配置 安装扩展Remote-SSH 在应用商店中安装扩展“Remote-SSH”： 配置基本config 在扩展设置中开启terminal显示 红框处打上钩选中。 ","date":"2021-07-06","objectID":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/:2:0","tags":["VSCode"],"title":"Windows下VSCode远程连接Linux","uri":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/"},{"categories":["Misc"],"content":"3. 权限更改 更改C:/Users/v4ler1an/.ssh的文件夹权限： “属性” -\u003e “安全” -\u003e “高级” -\u003e 禁用继承，然后重新添加用户权限。 ","date":"2021-07-06","objectID":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/:3:0","tags":["VSCode"],"title":"Windows下VSCode远程连接Linux","uri":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/"},{"categories":["Misc"],"content":"4. 无需密码自动登录 server端/etc/ssh/sshd_config配置文件开启了PubkeyAuthentication； Windows本地生成密钥： ssh-keygen -t rsa -c \"email@email.com\" 生成的密钥保存在C:/Users/xxx/.ssh文件夹下 将id_rsa.pub公钥内容复制到server的/home/xxx/.ssh/authorized_keys文件中； 重启server上的sshd服务，重新连接，即可实现无需密码远程连接 ","date":"2021-07-06","objectID":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/:4:0","tags":["VSCode"],"title":"Windows下VSCode远程连接Linux","uri":"/2021/07/windows%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/"},{"categories":["Fuzz"],"content":"Fuzzing 101 系列 note 6","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"本文是Fuzzing101系列第六篇，fuzz的对象为 GIMP 。 ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:0:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"1. Basic Info Target CVES to find Time estimated Main topics GIMP CVE-2016-4994 7hous persistent mode CVE-2016-4994: Use-After-Free vulneratibily. ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:1:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"2. Learning Target 使用 fuzz 的 persistent mode 对 interactive/GUI 应用程序进行fuzz ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:2:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"3. Fuzzing ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:3:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"1. Workflow 找到一种修改 GIMP 源码以启用 AFL++ 的 persistent mode 的有效的方法 创建一个 XCF 的语料库 对 XCF 文件格式创建 dictionary 开始fuzz，直到出现crash 使用造成crash的poc重现crash 修复漏洞 ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:3:1","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"2. Solution 1. Download and build target 首先创建待 fuzz 的 GIMP 环境，进行编译待用。 这里首先要安装 GEGL 0.2(Generic Graphics Library)，使用源码编译： # install dependencies sudo apt install build-essential libatk1.0-dev libfontconfig1-dev libcairo2-dev libgudev-1.0-0 libdbus-1-dev libdbus-glib-1-dev libexif-dev libxfixes-dev libgtk2.0-dev python2.7-dev libpango1.0-dev libglib2.0-dev zlib1g-dev intltool libbabl-dev # download and uncompress wget https://download.gimp.org/pub/gegl/0.2/gegl-0.2.2.tar.bz2 tar xvf gegl-0.2.0.tar.bz2 \u0026\u0026 cd gegl-0.2.2 # modify the source code sed -i 's/CODEC_CAP_TRUNCATED/AV_CODEC_CAP_TRUNCATED/g' ./operations/external/ff-load.c sed -i 's/CODEC_FLAG_TRUNCATED/AV_CODEC_FLAG_TRUNCATED/g' ./operations/external/ff-load.c # build and install ./configure --enable-debug --disable-glibtest --without-vala --without-cairo --without-pango --without-pangocairo --without-gdk-pixbuf --without-lensfun --without-libjpeg --without-libpng --without-librsvg --without-openexr --without-sdl --without-libopenraw --without-jasper --without-graphviz --without-lua --without-libavformat --without-libv4l --without-libspiro --without-exiv2 --without-umfpack make -j$(nproc) sudo make install 然后，下载 GIMP 2.8.16，并进行编译安装： # download cd .. wget https://mirror.klaus-uwe.me/gimp/pub/gimp/v2.8/gimp-2.8.16.tar.bz2 tar xvf gimp-2.8.16.tar.bz2 \u0026\u0026 cd gimp-2.8.16/ # build and install CC=afl-clang-lto CXX=afl-clang-lto++ PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HOME/Desktop/Fuzz/training/fuzzing_gimp/gegl-0.2.2/ CFLAGS=\"-fsanitize=address\" CXXFLAGS=\"-fsanitize=address\" LDFLAGS=\"-fsanitize=address\" ./configure --disable-gtktest --disable-glibtest --disable-alsatest --disable-nls --without-libtiff --without-libjpeg --without-bzip2 --without-gs --without-libpng --without-libmng --without-libexif --without-aa --without-libxpm --without-webkit --without-librsvg --without-print --without-poppler --without-cairo-pdf --without-gvfs --without-libcurl --without-wmf --without-libjasper --without-alsa --without-gudev --disable-python --enable-gimp-console --without-mac-twain --without-script-fu --without-gudev --without-dbus --disable-mp --without-linux-input --without-xvfb-run --with-gif-compression=none --without-xmc --with-shm=none --enable-debug --prefix=\"$HOME/Desktop/Fuzz/training/fuzzing_gimp/gimp-2.8.16/install\" make -j$(nproc) make install 2. persistent mode 为了使用 AFL++ 的 persistent mode，我们需要对源码进行一定的修改： 第一种方案是修改 app.c 文件： 第二种方案是修改 xcf_load_invoker 函数： 这里我们直接采用第二种方案进行 patch。gimp-2.8.16/app/xcf/xcf.c 修改前内容如下： 补丁内容如下： --- ../xcf.c 2014-08-20 08:27:58.000000000 -0700 +++ ./app/xcf/xcf.c 2021-10-11 13:02:42.800831192 -0700 @@ -277,6 +277,10 @@ filename = g_value_get_string (\u0026args-\u003evalues[1]); +#ifdef __AFL_COMPILER + while(__AFL_LOOP(10000)){ +#endif + info.fp = g_fopen (filename, \"rb\"); if (info.fp) @@ -366,6 +370,12 @@ if (success) gimp_value_set_image (\u0026return_vals-\u003evalues[1], image); +#ifdef __AFL_COMPILER + } +#endif + + exit(0); + gimp_unset_busy (gimp); return return_vals; 使用上面的补丁修改 gimp-2.8.16/app/xcf/xcf.c 文件： patch gimp-2.8.16/app/xcf/xcf.c -i persistent.patch pacth 后的文件内容如下： 这样就可以实现 AFL++ 的 persistent mode。 3. Seed corpus creation 这里直接使用 SampleInput.xcf 做简单的语料样例。 4. Custom dictionary 这里直接使用AFL++提供的 xcf 的 dict 。 4. Fuzzing 执行 afl-fuzz ，采用并行方式进行fuzz: ASAN_OPTIONS=detect_leaks=0,abort_on_error=1,symbolize=0 afl-fuzz -i './afl_in' -o './afl_out' -D -t 100 -- ./gimp-2.8.16/app/gimp-console-2.8 --verbose -d -f @@ ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:3:2","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"3. Crashes ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:3:3","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"4. Triage ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:4:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"5. Fix 官方的修复地址： https://gitlab.gnome.org/GNOME/gimp/-/commit/6d804bf9ae77bc86a0a97f9b944a129844df9395 后续将对该漏洞进行深入分析和补丁分析，待完善。 ","date":"2021-01-18","objectID":"/2021/01/fuzzing101-6/:5:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 6","uri":"/2021/01/fuzzing101-6/"},{"categories":["Fuzz"],"content":"AFL二三事系列 note 3","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"本文是AFL系列第四篇，主要介绍AFL的源码分析。 AFL二三事——源码分析 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:0:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"前言 AFL，全称“American Fuzzy Lop”，是由安全研究员Michal Zalewski开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率（代码执行路径的覆盖情况），以此进行反馈，对输入样本进行调整以提高覆盖率，从而提升发现漏洞的可能性。AFL可以针对有源码和无源码的程序进行模糊测试，其设计思想和实现方案在模糊测试领域具有十分重要的意义。 深入分析AFL源码，对理解AFL的设计理念和其中用到的技巧有着巨大的帮助，对于后期进行定制化Fuzzer开发也具有深刻的指导意义。所以，阅读AFL源码是学习AFL必不可少的一个关键步骤。 （注：需要强调的是，本文的主要目的是协助fuzz爱好者阅读AFL的源码，所以需要在了解AFL基本工作流程和原理的前提下进行阅读，本文并不会在原理侧做过多说明。） 当别人都要快的时候，你要慢下来。 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:1:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"宏观 首先在宏观上看一下AFL的源码结构： 主要的代码在 afl-fuzz.c 文件中，然后是几个独立模块的实现代码，llvm_mode 和 qemu_mode 的代码量大致相当，所以分析的重点应该还是在AFL的根目录下的几个核心功能的实现上，尤其是 afl-fuzz.c，属于核心中的重点。 各个模块的主要功能和作用的简要说明： 插桩模块 afl-as.h, afl-as.c, afl-gcc.c：普通插桩模式，针对源码插桩，编译器可以使用gcc， clang； llvm_mode：llvm 插桩模式，针对源码插桩，编译器使用clang； qemu_mode：qemu 插桩模式，针对二进制文件插桩。 fuzzer 模块 afl-fuzz.c：fuzzer 实现的核心代码，AFL 的主体。 其他辅助模块 afl-analyze：对测试用例进行分析，通过分析给定的用例，确定是否可以发现用例中有意义的字段； afl-plot：生成测试任务的状态图； afl-tmin：对测试用例进行最小化； afl-cmin：对语料库进行精简操作； afl-showmap：对单个测试用例进行执行路径跟踪； afl-whatsup：各并行例程fuzzing结果统计； afl-gotcpu：查看当前CPU状态。 部分头文件说明 alloc-inl.h：定义带检测功能的内存分配和释放操作； config.h：定义配置信息； debug.h：与提示信息相关的宏定义； hash.h：哈希函数的实现定义； types.h：部分类型及宏的定义。 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:2:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"一、AFL的插桩——普通插桩 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:3:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"（一） 、AFL 的 gcc —— afl-gcc.c 1. 概述 afl-gcc 是GCC 或 clang 的一个wrapper（封装），常规的使用方法是在调用 ./configure 时通过 CC 将路径传递给 afl-gcc 或 afl-clang。（对于 C++ 代码，则使用 CXX 并将其指向 afl-g++ / afl-clang++。）afl-clang, afl-clang++， afl-g++ 均为指向 afl-gcc 的一个符号链接。 afl-gcc 的主要作用是实现对于关键节点的代码插桩，属于汇编级，从而记录程序执行路径之类的关键信息，对程序的运行情况进行反馈。 2. 源码 1. 关键变量 在开始函数代码分析前，首先要明确几个关键变量： static u8* as_path; /* Path to the AFL 'as' wrapper，AFL的as的路径 */ static u8** cc_params; /* Parameters passed to the real CC，CC实际使用的编译器参数 */ static u32 cc_par_cnt = 1; /* Param count, including argv0 ，参数计数 */ static u8 be_quiet, /* Quiet mode，静默模式 */ clang_mode; /* Invoked as afl-clang*? ，是否使用afl-clang*模式 */ # 数据类型说明 # typedef uint8_t u8; # typedef uint16_t u16; # typedef uint32_t u32; 2. main函数 main 函数全部逻辑如下： 其中主要有如下三个函数的调用： find_as(argv[0]) ：查找使用的汇编器 edit_params(argc, argv)：处理传入的编译参数，将确定好的参数放入 cc_params[] 数组 调用 execvp(cc_params[0], (cahr**)cc_params) 执行 afl-gcc 这里添加了部分代码打印出传入的参数 arg[0] - arg[7] ，其中一部分是我们指定的参数，另外一部分是自动添加的编译选项。 3. find_as 函数 函数的核心作用：寻找 afl-as 函数内部大概的流程如下（软件自动生成，控制流程图存在误差，但关键逻辑没有问题）： 首先检查环境变量 AFL_PATH ，如果存在直接赋值给 afl_path ，然后检查 afl_path/as 文件是否可以访问，如果可以，as_path = afl_path。 如果不存在环境变量 AFL_PATH ，检查 argv[0] （如“/Users/v4ler1an/AFL/afl-gcc”）中是否存在 “/” ，如果存在则取最后“/” 前面的字符串作为 dir，然后检查 dir/afl-as 是否可以访问，如果可以，将 as_path = dir 。 以上两种方式都失败，抛出异常。 4. edit_params 函数 核心作用：将 argv 拷贝到 u8 **cc_params ，然后进行相应的处理。 函数内部的大概流程如下： 调用 ch_alloc() 为 cc_params 分配大小为 (argc + 128) * 8 的内存（u8的类型为1byte无符号整数） 检查 argv[0] 中是否存在/，如果不存在则 name = argv[0]，如果存在则一直找到最后一个/，并将其后面的字符串赋值给 name 对比 name和固定字符串afl-clang： 若相同，设置clang_mode = 1，设置环境变量CLANG_ENV_VAR为1 对比name和固定字符串afl-clang++:： 若相同，则获取环境变量AFL_CXX的值，如果存在，则将该值赋值给cc_params[0]，否则将afl-clang++赋值给cc_params[0]。这里的cc_params为保存编译参数的数组； 若不相同，则获取环境变量AFL_CC的值，如果存在，则将该值赋值给cc_params[0]，否则将afl-clang赋值给cc_params[0]。 如果不相同，并且是Apple平台，会进入 #ifdef __APPLE__。在Apple平台下，开始对 name 进行对比，并通过 cc_params[0] = getenv(\"\") 对cc_params[0]进行赋值；如果是非Apple平台，对比 name 和 固定字符串afl-g++（此处忽略对Java环境的处理过程）： 若相同，则获取环境变量AFL_CXX的值，如果存在，则将该值赋值给cc_params[0]，否则将g++赋值给cc_params[0]； 若不相同，则获取环境变量AFL_CC的值，如果存在，则将该值赋值给cc_params[0]，否则将gcc赋值给cc_params[0]。 进入 while 循环，遍历从argv[1]开始的argv参数： 如果扫描到 -B ，-B选项用于设置编译器的搜索路径，直接跳过。（因为在这之前已经处理过as_path了）； 如果扫描到 -integrated-as，跳过； 如果扫描到 -pipe，跳过； 如果扫描到 -fsanitize=address 和 -fsanitize=memory 告诉 gcc 检查内存访问的错误，比如数组越界之类，设置 asan_set = 1； 如果扫描到 FORTIFY_SOURCE ，设置 fortify_set = 1 。FORTIFY_SOURCE 主要进行缓冲区溢出问题的检查，检查的常见函数有memcpy, mempcpy, memmove, memset, strcpy, stpcpy, strncpy, strcat, strncat, sprintf, vsprintf, snprintf, gets 等； 对 cc_params 进行赋值：cc_params[cc_par_cnt++] = cur; 跳出 while 循环，设置其他参数： 取出前面计算出的 as_path ，设置 -B as_path ； 如果为 clang_mode ，则设置-no-integrated-as； 3. 如果存在环境变量 AFL_HARDEN，则设置-fstack-protector-all。且如果没有设置 fortify_set ，追加 -D_FORTIFY_SOURCE=2 ； sanitizer相关，通过多个if进行判断： 如果 asan_set 在前面被设置为1，则设置环境变量 AFL_USE_ASAN 为1； 如果 asan_set 不为1且，存在 AFL_USE_ASAN 环境变量，则设置 -U_FORTIFY_SOURCE -fsanitize=address； 如果不存在 AFL_USE_ASAN 环境变量，但存在 AFL_USE_MSAN 环境变量，则设置-fsanitize=memory（不能同时指定AFL_USE_ASAN或者AFL_USE_MSAN，也不能同时指定 AFL_USE_MSAN 和 AFL_HARDEN，因为这样运行时速度过慢； 如果不存在 AFL_DONT_OPTIMIZE 环境变量，则设置-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1； 如果存在 AFL_NO_BUILTIN 环境变量，则表示允许进行优化，设置-fno-builtin-strcmp -fno-builtin-strncmp -fno-builtin-strcasecmp -fno-builtin-strncasecmp -fno-builtin-memcmp -fno-builtin-strstr -fno-builtin-strcasestr。 最后补充cc_params[cc_par_cnt] = NULL;，cc_params 参数数组编辑完成。 ###（二）、AFL的插桩 —— afl-as.c 1. 概述 afl-gcc 是 GNU as 的一个wrapper（封装），唯一目的是预处理由 GCC/clang 生成的汇编文件，并注入包含在 afl-as.h 中的插桩代码。 使用 afl-gcc / afl-clang 编译程序时，工具链会自动调用它。该wapper的目标并不是为了实现向 .s 或 asm  代码块中插入手写的代码。 experiment/clang_asm_normalize/ 中可以找到可能允许 clang 用户进行手动插入自定义代码的解决方案，GCC并不能实现该功能。 2. 源码 1. 关键变量 在开始函数代码分析前，首先要明确几个关键变量： static u8** as_params; /* Parameters passed to the real 'as'，传递给as的参数 */ static u8* input_file; /* Originally specified input file ，输入文件 */ static u8* modified_file; /* Instrumented file for the real 'as'，as进行插桩处理的文件 */ static u8 be_quiet, /* Quiet mode (no stderr output) ，静默模式，没有标准输出 */ clang_mod","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:3:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"二、AFL 的插桩 —— llvm_mode ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:4:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"（一）、LLVM 前置知识 LLVM 主要为了解决编译时多种多样的前端和后端导致编译环境复杂、苛刻的问题，其核心为设计了一个称为 LLVM IR 的中间表示，并以库的形式提供一些列接口，以提供诸如操作 IR 、生成目标平台代码等等后端的功能。其整体架构如下所示： 不同的前端和后端使用统一的中间代码LLVM InterMediate Representation(LLVM IR)，其结果就是如果需要支持一门新的编程语言，只需要实现一个新的前端；如果需要支持一款新的硬件设备，只需要实现一个新的后端；优化阶段为通用阶段，针对统一的 LLVM IR ，与新的编程语言和硬件设备无关。 GCC 的前后端耦合在一起，没有进行分离，所以GCC为了支持一门新的编程语言或一个新的硬件设备，需要重新开发前端到后端的完整过程。 Clang 是 LLVM 项目的一个子项目，它是 LLVM 架构下的 C/C++/Objective-C 的编译器，是 LLVM 前端的一部分。相较于GCC，具备编译速度快、占用内存少、模块化设计、诊断信息可读性强、设计清晰简单等优点。 最终从源码到机器码的流程如下（以 Clang 做编译器为例）： （LLVM Pass 是一些中间过程处理 IR 的可以用户自定义的内容，可以用来遍历、修改 IR 以达到插桩、优化、静态分析等目的。） 代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码。 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:4:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"（二）、 AFL的afl-clang-fast 1. 概述 AFL的 llvm_mode 可以实现编译器级别的插桩，可以替代 afl-gcc 或 afl-clang 使用的比较“粗暴”的汇编级别的重写的方法，且具备如下几个优势： 编译器可以进行很多优化以提升效率； 可以实现CPU无关，可以在非 x86 架构上进行fuzz； 可以更好地处理多线程目标。 在AFL的 llvm_mode 文件夹下包含3个文件： afl-clang-fast.c ， afl-llvm-pass.so.cc， afl-llvm-rt.o.c。 afl-llvm-rt.o.c 文件主要是重写了 afl-as.h 文件中的 main_payload 部分，方便调用； afl-llvm-pass.so.cc 文件主要是当通过 afl-clang-fast 调用 clang 时，这个pass被插入到 LLVM 中，告诉编译器添加与 ``afl-as.h` 中大致等效的代码； afl-clang-fast.c 文件本质上是 clang 的 wrapper，最终调用的还是 clang 。但是与 afl-gcc 一样，会进行一些参数处理。 llvm_mode 的插桩思路就是通过编写pass来实现信息记录，对每个基本块都插入探针，具体代码在 afl-llvm-pass.so.cc 文件中，初始化和forkserver操作通过链接完成。 2. 源码 1. afl-clang-fast.c 1. main 函数 main 函数的全部逻辑如下： 主要是对 find_obj(), edit_params(), execvp() 函数的调用， 其中主要有以下三个函数的调用： find_obj(argv[0])：查找运行时library edit_params(argc, argv)：处理传入的编译参数，将确定好的参数放入 cc_params[] 数组 execvp(cc_params[0], (cahr**)cc_params)：替换进程空间，传递参数，执行要调用的clang 这里后两个函数的作用与 afl-gcc.c 中的作用基本相同，只是对参数的处理过程存在不同，不同的主要是 find_obj() 函数。 2. find_obj 函数 find_obj()函数的控制流逻辑如下： 首先，读取环境变量 AFL_PATH 的值： 如果读取成功，确认 AFL_PATH/afl-llvm-rt.o 是否可以访问；如果可以访问，设置该目录为 obj_path ，然后直接返回； 如果读取失败，检查 arg0 中是否存在 / 字符，如果存在，则判断最后一个 / 前面的路径为 AFL 的根目录；然后读取afl-llvm-rt.o文件，成功读取，设置该目录为 obj_path ，然后直接返回。 如果上面两种方式都失败，到/usr/local/lib/afl 目录下查找是否存在 afl-llvm-rt.o ，如果存在，则设置为 obj_path 并直接返回（之所以向该路径下寻找，是因为默认的AFL的MakeFile在编译时，会定义一个名为AFL_PATH的宏，该宏会指向该路径）； 如果以上全部失败，抛出异常提示找不到 afl-llvm-rt.o 文件或 afl-llvm-pass.so 文件，并要求设置 AFL_PATH 环境变量 。 函数的主要功能是在寻找AFL的路径以找到 afl-llvm-rt.o 文件，该文件即为要用到的运行时库。 3. edit_params 函数 该函数的主要作用仍然为编辑参数数组，其控制流程如下： 首先，判断执行的是否为 afl-clang-fast++ ： 如果是，设置 cc_params[0] 为环境变量 AFL_CXX；如果环境变量为空，则设置为 clang++ ； 如果不是，设置 cc_params[0] 为环境变量 AFL_CC；如果环境变量为空，则设置为 clang ； 判断是否定义了 USE_TRACE_PC 宏，如果有，添加 -fsanitize-coverage=trace-pc-guard -mllvm(only Android) -sanitizer-coverage-block-threshold=0(only Android) 选项到参数数组；如果没有，依次将 -Xclang -load -Xclang obj_path/afl-llvm-pass.so -Qunused-arguments 选项添加到参数数组；（这里涉及到llvm_mode使用的2种插桩方式：默认使用的是传统模式，使用 afl-llvm-pass.so 注入来进行插桩，这种方式较为稳定；另外一种是处于实验阶段的方式——trace-pc-guard 模式，对于该模式的详细介绍可以参考llvm相关文档——tracing-pcs-with-guards） 遍历传递给 afl-clang-fast 的参数，进行一定的检查和设置，并添加到 cc_params 数组： 如果存在 -m32 或 armv7a-linux-androideabi ，设置 bit_mode 为32； 如果存在 -m64 ，设置 bit_mode 为64； 如果存在 -x ，设置 x_set 为1； 如果存在 -fsanitize=address 或 -fsanitize=memory，设置 asan_set 为1； 如果存在 -Wl,-z,defs 或 -Wl,--no-undefined，则直接pass掉。 检查环境变量是否设置了 AFL_HARDEN： 如果有，添加 -fstack-protector-all 选项； 如果有且没有设置 FORTIFY_SOURCE ，添加 -D_FORTIFY_SOURCE=2 选项； 检查参数中是否存在 -fsanitize=memory，即 asan_set 为0： 如果没有，尝试读取环境变量 AFL_USE_ASAN，如果存在，添加 -U_FORTIFY_SOURCE -fsanitize=address； 接下来对环境变量AFL_USE_MSAN的处理方式与 AFL_USE_ASAN 类似，添加的选项为 -U_FORTIFY_SOURCE -fsanitize=memory； 检查是否定义了 USE_TRACE_PC 宏，如果存在定义，检查是否存在环境变量 AFL_INST_RATIO，如果存在，抛出异常AFL_INST_RATIO 无法在trace-pc时使用； 检查环境变量 AFL_NO_BUILTIN ，如果没有设置，添加 -g -O3 -funroll-loops； 检查环境变量 AFL_NO_BUILTIN，如果进行了设置，添加 -fno-builtin-strcmp -fno-builtin-strncmp -fno-builtin-strcasecmp -fno-builtin-strcasecmp -fno-builtin-memcmp； 添加参数 -D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1； 定义了两个宏 __AFL_LOOP(), __AFL_INIT()； 检查是否设置了 x_set， 如果有添加 -x none； 检查是否设置了宏 __ANDORID__ ，如果没有，判断 bit_mode 的值： 如果为0，即没有-m32和-m64，添加 obj_path/afl-llvm-rt.o ； 如果为32，添加 obj_path/afl-llvm-rt-32.o ； 如果为64，添加 obj_path/afl-llvm-rt-64.o 。 2. afl-llvm-pass.so.cc afl-llvm-pass.so.cc 文件实现了 LLVM-mode 下的一个插桩 LLVM Pass。 本文不过多关心如何实现一个LLVM Pass，重点分析该pass的实现逻辑。 该文件只有一个Transform pass： AFLCoverage，继承自 ModulePass，实现了一个 runOnModule 函数，这也是我们需要重点分析的函数。 namespace { class AFLCoverage : public ModulePass { public: static char ID; AFLCoverage() : ModulePass(ID) { } bool runOnModule(Module \u0026M) override; // StringRef getPassName() const override { // return \"American Fuzzy Lop Instrumentation\"; // } }; } 1. pass注册 对pass进行注册的部分源码如下： static void registerAFLPass(const PassManagerBuilder \u0026, legacy::PassManagerBase \u0026PM) { PM.add(new AFLCoverage()); } static RegisterStandardPasses RegisterAFLPass( PassManagerBuilder::EP_ModuleOptimizerEarly, registerAFLPass); static RegisterStandardPasses RegisterAFLPass0( P","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:4:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"三、AFL的fuzzer —— afl-fuzz.c ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:5:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"1. 、概述 AFL中最重要的部分便是fuzzer的实现部分——afl_fuzz.c ，其主要作用是通过不断变异测试用例来影响程序的执行路径。该文件代码量在8000行左右，处于篇幅原因，我们不会对每一个函数进行源码级分析，而是按照功能划分，介绍其中的核心函数。该文件属于AFL整个项目的核心中的核心，强烈建议通读该文件。 在介绍源码的同时，会穿插AFL的整体运行过程和设计思路，辅助理解源码的设计思路。 在功能上，可以总体上分为3部分： 初始配置：进行fuzz环境配置相关工作 fuzz执行：fuzz的主循环过程 变异策略：测试用例的变异过程和方式 我们将按照以上3个功能对其中的关键函数和流程进行分析。 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:5:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"2、核心源码分析 1. 初始配置 1.1 第一个while循环 while ((opt = getopt(argc, argv, \"+i⭕fⓜ️b:t:T:dnCB:S:M:x:QV\")) \u003e 0) ... ... 该循环主要通过 getopt 获取各种环境配置、选项参数等。 1.2 setup_signal_handlers 函数 调用 sigaction ，注册信号处理函数，设置信号句柄。具体的信号内容如下： 信号 作用 SIGHUP/SIGINT/SIGTERM 处理各种“stop”情况 SIGALRM 处理超时的情况 SIGWINCH 处理窗口大小 SIGUSER1 用户自定义信号，这里定义为skip request SIGSTP/SIGPIPE 不是很重要的一些信号，可以不用关心 1.3 check_asan_opts 函数 读取环境变量 ASAN_OPTIONS 和 MSAN_OPTIONS，做一些必要性检查。 1.4 fix_up_sync 函数 如果通过 -M或者-S指定了 sync_id，则更新 out_dir 和 sync_dir 的值：设置 sync_dir 的值为 out_dir，设置 out_dir 的值为out_dir/sync_id。 1.5 save_cmdline 函数 copy当前命令行参数，保存。 1.6 check_if_tty 函数 检查是否在tty终端上面运行：读取环境变量 AFL_NO_UI ，如果存在，设置 not_on_tty 为1，并返回；通过 ioctl 读取window size，如果报错为 ENOTTY，表示当前不在一个tty终端运行，设置 not_on_tty。 1.7 几个CPU检查相关的函数 static void get_core_count(void)get_core_count() ：获取核心数量 check_crash_handling()：确保核心转储不会进入程序 check_cpu_governor()：检查CPU管理者 1.8 setup_shm 函数 该函数用于设置共享内存和 virgin_bits，属于比较重要的函数，这里我们结合源码来解析一下： /* Configure shared memory and virgin_bits. This is called at startup. */ EXP_ST void setup_shm(void) { u8* shm_str; if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE); // 如果 in_bitmap 为空，调用 memset 初始化数组 virgin_bits[MAP_SIZE] 的每个元素的值为 ‘255’。 memset(virgin_tmout, 255, MAP_SIZE); // 调用 memset 初始化数组 virgin_tmout[MAP_SIZE] 的每个元素的值为 ‘255’。 memset(virgin_crash, 255, MAP_SIZE); // 调用 memset 初始化数组 virgin_crash[MAP_SIZE] 的每个元素的值为 ‘255’。 shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); // 调用 shmget 函数分配一块共享内存，并将返回的共享内存标识符保存到 shm_id if (shm_id \u003c 0) PFATAL(\"shmget() failed\"); atexit(remove_shm); // 注册 atexit handler 为 remove_shm shm_str = alloc_printf(\"%d\", shm_id); // 创建字符串 shm_str /* If somebody is asking us to fuzz instrumented binaries in dumb mode, we don't want them to detect instrumentation, since we won't be sending fork server commands. This should be replaced with better auto-detection later on, perhaps? */ if (!dumb_mode) setenv(SHM_ENV_VAR, shm_str, 1); // 如果不是dumb_mode，设置环境变量 SHM_ENV_VAR 的值为 shm_str ck_free(shm_str); trace_bits = shmat(shm_id, NULL, 0); // 设置 trace_bits 并初始化为0 if (trace_bits == (void *)-1) PFATAL(\"shmat() failed\"); } 这里通过 trace_bits 和 virgin_bits 两个 bitmap 来分别记录当前的 tuple 信息及整体 tuple 信息，其中 trace_bits 位于共享内存上，便于进行进程间通信。通过 virgin_tmout 和 virgin_crash 两个 bitmap 来记录 fuzz 过程中出现的所有目标程序超时以及崩溃的 tuple 信息。 1.9 setup_dirs_fds 函数 该函数用于准备输出文件夹和文件描述符，结合源码进行解析： EXP_ST void setup_dirs_fds(void) { u8* tmp; s32 fd; ACTF(\"Setting up output directories...\"); if (sync_id \u0026\u0026 mkdir(sync_dir, 0700) \u0026\u0026 errno != EEXIST) PFATAL(\"Unable to create '%s'\", sync_dir); /* 如果sync_id，且创建sync_dir文件夹并设置权限为0700，如果报错单errno不是 EEXIST ，抛出异常 */ if (mkdir(out_dir, 0700)) { // 创建out_dir， 权限为0700 if (errno != EEXIST) PFATAL(\"Unable to create '%s'\", out_dir); maybe_delete_out_dir(); } else { if (in_place_resume) // 创建成功 FATAL(\"Resume attempted but old output directory not found\"); out_dir_fd = open(out_dir, O_RDONLY); // 以只读模式打开，返回fd：out_dir_fd #ifndef __sun if (out_dir_fd \u003c 0 || flock(out_dir_fd, LOCK_EX | LOCK_NB)) PFATAL(\"Unable to flock() output directory.\"); #endif /* !__sun */ } /* Queue directory for any starting \u0026 discovered paths. */ tmp = alloc_printf(\"%s/queue\", out_dir); if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp); // 创建 out_dir/queue 文件夹，权限为0700 ck_free(tmp); /* Top-level directory for queue metadata used for session resume and related tasks. */ tmp = alloc_printf(\"%s/queue/.state/\", out_dir); // 创建 out_dir/queue/.state 文件夹，用于保存session resume 和相关tasks的队列元数据。 if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp); ck_free(tmp); /* Directory for flagging queue entries that went through deterministic fuzzing in the past. */ tmp = alloc_printf(\"%s/queue/.state/deterministic_done/\", out_dir); if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp); ck_free(tmp); /* Directory with the auto-selected dictionary entries. */ tmp = alloc_printf(\"%s/queue/.state/auto_extras/\", out_dir); if (mkdir(tmp, 0700)) PFATAL(\"Unable to create '%s'\", tmp); ck_free(tmp); /* The set of paths currently deemed redund","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:5:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"四、总结 分析完源码，可以感受到，AFL遵循的基本原则是简单有效，没有进行过多的复杂的优化，能够针对fuzz领域的痛点，对症下药，拒绝花里胡哨，给出切实可行的解决方案，在漏洞挖掘领域的意义的确非同凡响。后期的很多先进的fuzz工具基本沿用了AFL的思路，甚至目前为止已基本围绕AFL建立了“生态圈”，涉及到多个平台、多种漏洞挖掘对象，对于安全研究员来说实属利器，值得从事fuzz相关工作的研究员下足功夫去体会AFL的精髓所在。 考虑到篇幅限制，我们没有对AFL中的变异策略进行源码说明，实属遗憾。如果有机会，将新开文章详细介绍AFL的变异策略和源码分析。 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:6:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Fuzz"],"content":"五、参考文献 http://lcamtuf.coredump.cx/afl/ https://eternalsakura13.com/2020/08/23/afl/ https://bbs.pediy.com/thread-265936.htm https://bbs.pediy.com/thread-249912.htm#msg_header_h3_3 ","date":"0001-01-01","objectID":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/:7:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 4","uri":"/2021/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"},{"categories":["Development"],"content":"通用安全编码指南 C/C++篇","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"收集于github，通用安全编码指南系列第一篇：C/C++，总结概述在C/C ++编码过程中常见的安全问题和应该采取的安全编码格式。 目录 1 通用安全指南 I. C/C++使用错误 1.1 不得直接使用无长度限制的字符拷贝函数 1.2 创建进程类的函数的安全规范 1.3 尽量减少使用 _alloca 和可变长度数组 1.4 printf系列参数必须对应 1.5 防止泄露指针（包括%p）的值 1.6 不应当把用户可修改的字符串作为printf系列函数的“format”参数 1.7 对数组delete时需要使用delete[] 1.8 注意隐式符号转换 1.9 注意八进制问题 II. 不推荐的编程习惯 2.1 switch中应有default 2.2 不应当在Debug或错误信息中提供过多内容 2.3 不应该在客户端代码中硬编码对称加密秘钥 2.4 返回栈上变量的地址 2.5 有逻辑联系的数组必须仔细检查 2.6 避免函数的声明和实现不同 2.7 检查复制粘贴的重复代码 2.8 左右一致的重复判断/永远为真或假的判断 2.9 函数每个分支都应有返回值 2.10 不得使用栈上未初始化的变量 2.11 不得直接使用刚分配的未初始化的内存（如realloc） 2.12 校验内存相关函数的返回值 2.13 不要在if里面赋值 2.14 确认if里面的按位操作 III. 多线程 3.1 变量应确保线程安全性 3.2 注意signal handler导致的条件竞争 3.3 注意Time-of-check Time-of-use条件竞争 IV. 加密解密 4.1 不得明文存储用户密码等敏感数据 4.2 内存中的用户密码等敏感数据应该安全抹除 4.3 rand() 类函数应正确初始化 4.4 在需要高强度安全加密时不应使用弱PRNG函数 4.5 自己实现的rand范围不应过小 V. 文件操作 5.1 避免路径穿越问题 5.2 避免相对路径导致的安全问题 5.3 文件权限控制 Ⅵ. 文件操作 6.1 防止各种越界写 6.2 防止任意地址写 Ⅶ. 文件操作 7.1 防止整数溢出 7.2 防止Off-By-One 7.3 避免大小端错误 7.4 检查除以零异常 7.5 防止数字类型的错误强转 7.6 比较数据大小时加上最小/最大值的校验 Ⅷ. 文件操作 8.1 检查在pointer上使用sizeof 8.2 检查直接将数组和0比较的代码 8.3 不应当向指针赋予写死的地址 8.4 检查空指针 8.5 释放完后置空指针 8.6 防止错误的类型转换 8.7 智能指针使用安全 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:0:0","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"通用安全指南 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:0","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"1 C/C++ 使用错误 1.1 【必须】不得直接使用无长度限制的字符拷贝函数 不应直接使用legacy的字符串拷贝、输入函数，如strcpy、strcat、sprintf、wcscpy、mbscpy等，这些函数的特征是：可以输出一长串字符串，而不限制长度。如果环境允许，应当使用其_s安全版本替代，或者使用n版本函数（如：snprintf，vsnprintf）。 若使用形如sscanf之类的函数时，在处理字符串输入时应当通过%10s这样的方式来严格限制字符串长度，同时确保字符串末尾有\\0。如果环境允许，应当使用_s安全版本。 但是注意，虽然MSVC 2015时默认引入结尾为0版本的snprintf（行为等同于C99定义的snprintf）。但更早期的版本中，MSVC的snprintf可能是_snprintf的宏。而_snprintf是不保证\\0结尾的（见本节后半部分）。 （MSVC） Beginning with the UCRT in Visual Studio 2015 and Windows 10, snprintf is no longer identical to _snprintf. The snprintf function behavior is now C99 standard compliant. 从Visual Studio 2015和Windows 10中的UCRT开始，snprintf不再与_snprintf相同。snprintf函数行为现在符合C99标准。 请参考：https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/snprintf-snprintf-snprintf-l-snwprintf-snwprintf-l?redirectedfrom=MSDN\u0026view=vs-2019 因此，在使用n系列拷贝函数时，要确保正确计算缓冲区长度，同时，如果你不确定是否代码在各个编译器下都能确保末尾有0时，建议可以适当增加1字节输入缓冲区，并将其置为\\0，以保证输出的字符串结尾一定有\\0。 // Good char buf[101] = {0}; snprintf(buf, sizeof(buf) - 1, \"foobar ...\", ...); 一些需要注意的函数，例如strncpy和_snprintf是不安全的。 strncpy不应当被视为strcpy的n系列函数，它只是恰巧与其他n系列函数名字很像而已。strncpy在复制时，如果复制的长度超过n，不会在结尾补\\0。 同样，MSVC _snprintf系列函数在超过或等于n时也不会以0结尾。如果后续使用非0结尾的字符串，可能泄露相邻的内容或者导致程序崩溃。 // Bad char a[4] = {0}; _snprintf(a, 4, \"%s\", \"AAAA\"); foo = strlen(a); 上述代码在MSVC中执行后， a[4] == ‘A’，因此字符串未以0结尾。a的内容是\"AAAA\"，调用strlen(a)则会越界访问。因此，正确的操作举例如下： // Good char a[4] = {0}; _snprintf(a, sizeof(a), \"%s\", \"AAAA\"); a[sizeof(a) - 1] = '\\0'; foo = strlen(a); 在 C++ 中，强烈建议用 string、vector 等更高封装层次的基础组件代替原始指针和动态数组，对提高代码的可读性和安全性都有很大的帮助。 关联漏洞: 中风险-信息泄露 低风险-拒绝服务 高风险-缓冲区溢出 1.2 【必须】创建进程类的函数的安全规范 system、WinExec、CreateProcess、ShellExecute等启动进程类的函数，需要严格检查其参数。 启动进程需要加上双引号，错误例子： // Bad WinExec(\"D:\\\\program files\\\\my folder\\\\foobar.exe\", SW_SHOW); 当存在D:\\program files\\my.exe的时候，my.exe会被启动。而foobar.exe不会启动。 // Good WinExec(\"\\\"D:\\\\program files\\\\my folder\\\\foobar.exe\\\"\", SW_SHOW); 另外，如果启动时从用户输入、环境变量读取组合命令行时，还需要注意是否可能存在命令注入。 // Bad std::string cmdline = \"calc \"; cmdline += user_input; system(cmdline.c_str()); 比如，当用户输入1+1 \u0026\u0026 ls时，执行的实际上是calc 1+1和ls 两个命令，导致命令注入。 需要检查用户输入是否含有非法数据。 // Good std::string cmdline = \"ls \"; cmdline += user_input; if(cmdline.find_first_not_of(\"1234567890.+-*/e \") == std::string::npos) system(cmdline.c_str()); else warning(...); 关联漏洞: 高风险-代码执行 高风险-权限提升 1.3 【必须】尽量减少使用 _alloca 和可变长度数组 _alloca 和可变长度数组使用的内存量在编译期间不可知。尤其是在循环中使用时，根据编译器的实现不同，可能会导致：（1）栈溢出，即拒绝服务； （2）缺少栈内存测试的编译器实现可能导致申请到非栈内存，并导致内存损坏。这在栈比较小的程序上，例如IoT设备固件上影响尤为大。对于 C++，可变长度数组也属于非标准扩展，在代码规范中禁止使用。 错误示例： // Bad for (int i = 0; i \u003c 100000; i++) { char* foo = (char *)_alloca(0x10000); ..do something with foo ..; } void Foo(int size) { char msg[size]; // 不可控的栈溢出风险！ } 正确示例： // Good // 改用动态分配的堆内存 for (int i = 0; i \u003c 100000; i++) { char * foo = (char *)malloc(0x10000); ..do something with foo ..; if (foo_is_no_longer_needed) { free(foo); foo = NULL; } } void Foo(int size) { std::string msg(size, '\\0'); // C++ char* msg = malloc(size); // C } 关联漏洞: 低风险-拒绝服务 高风险-内存破坏 1.4 【必须】printf系列参数必须对应 所有printf系列函数，如sprintf，snprintf，vprintf等必须对应控制符号和参数。 错误示例： // Bad const int buf_size = 1000; char buffer_send_to_remote_client[buf_size] = {0}; snprintf(buffer_send_to_remote_client, buf_size, \"%d: %p\", id, some_string); // %p 应为 %s buffer_send_to_remote_client[buf_size - 1] = '\\0'; send_to_remote(buffer_send_to_remote_client); 正确示例： // Good const int buf_size = 1000; char buffer_send_to_remote_client[buf_size] = {0}; snprintf(buffer_send_to_remote_client, buf_size, \"%d: %s\", id, some_string); buffer_send_to_remote_client[buf_size - 1] = '\\0'; send_to_remote(buffer_send_to_remote_client); 前者可能会让client的攻击者获取部分服务器的原始指针地址，可以用于破坏ASLR保护。 关联漏洞: 中风险-信息泄露 1.5 【必须】防止泄露指针（包括%p）的值 所有printf系列函数，要防止格式化完的字符串泄露程序布局信息。例如，如果将带有%p的字符串泄露给程序，则可能会破坏ASLR的防护效果。使得攻击者更容易攻破程序。 %p的值只应当在程序内使用，而不应当输出到外部或被外部以某种方式获取。 错误示例： // Bad // 如果这是暴露给客户的一个API： uint64_t GetUniqueObjectId(const Foo* pobject) { return (uint64_t)pobject; } 正确示例： // Good uint64_t g_object_id = 0; void Foo::Foo() { this-\u003eobject_id_ = g_object_id++; } // 如果这是暴露给客户的一个API： uint64_t GetUniqueObjectId(const Foo* objec","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:1","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"2 不推荐的编程习惯 2.1 【必须】switch中应有default switch中应该有default，以处理各种预期外的情况。这可以确保switch接受用户输入，或者后期在其他开发者修改函数后确保switch仍可以覆盖到所有情况，并确保逻辑正常运行。 // Bad int Foo(int bar) { switch (bar \u0026 7) { case 0: return Foobar(bar); break; case 1: return Foobar(bar * 2); break; } } 例如上述代码switch的取值可能从0～7，所以应当有default： // Good int Foo(int bar) { switch (bar \u0026 7) { case 0: return Foobar(bar); break; case 1: return Foobar(bar * 2); break; default: return -1; } } 关联漏洞: 中风险-逻辑漏洞 中风险-内存泄漏 2.2 【必须】不应当在Debug或错误信息中提供过多内容 包含过多信息的Debug消息不应当被用户获取到。Debug信息可能会泄露一些值，例如内存数据、内存地址等内容，这些内容可以帮助攻击者在初步控制程序后，更容易地攻击程序。 // Bad int Foo(int* bar) { if (bar \u0026\u0026 *bar == 5) { OutputDebugInfoToUser(\"Wrong value for bar %p = %d\\n\", bar, *bar); } } 而应该： // Good int foo(int* bar) { #ifdef DEBUG if (bar \u0026\u0026 *bar == 5) { OutputDebugInfo(\"Wrong value for bar.\\n\", bar, *bar); } #endif } 关联漏洞: 中风险-信息泄漏 2.3 【必须】不应该在客户端代码中硬编码对称加密秘钥 不应该在客户端代码中硬编码对称加密秘钥。例如：不应在客户端代码使用硬编码的 AES/ChaCha20-Poly1305/SM1 密钥，使用固定密钥的程序基本和没有加密一样。 如果业务需求是认证加密数据传输，应优先考虑直接用 HTTPS 协议。 如果是其它业务需求，可考虑由服务器端生成对称秘钥，客户端通过 HTTPS 等认证加密通信渠道从服务器拉取。 或者根据用户特定的会话信息，比如登录认证过程可以根据用户名用户密码业务上下文等信息，使用 HKDF 等算法衍生出对称秘钥。 又或者使用 RSA/ECDSA + ECDHE 等进行认证秘钥协商，生成对称秘钥。 // Bad char g_aes_key[] = {...}; void Foo() { .... AES_func(g_aes_key, input_data, output_data); } 可以考虑在线为每个用户获取不同的密钥： // Good char* g_aes_key; void Foo() { .... AES_encrypt(g_aes_key, input_data, output_data); } void Init() { g_aes_key = get_key_from_https(user_id, ...); } 关联漏洞: 中风险-信息泄露 2.4 【必须】返回栈上变量的地址 函数不可以返回栈上的变量的地址，其内容在函数返回后就会失效。 // Bad char* Foo(char* sz, int len){ char a[300] = {0}; if (len \u003e 100) { memcpy(a, sz, 100); } a[len] = '\\0'; return a; // WRONG } 而应当使用堆来传递非简单类型变量。 // Good char* Foo(char* sz, int len) { char* a = new char[300]; if (len \u003e 100) { memcpy(a, sz, 100); } a[len] = '\\0'; return a; // OK } 对于 C++ 程序来说，强烈建议返回 string、vector 等类型，会让代码更加简单和安全。 关联漏洞: 高风险-内存破坏 2.5 【必须】有逻辑联系的数组必须仔细检查 例如下列程序将字符串转换为week day，但是两个数组并不一样长，导致程序可能会越界读一个int。 // Bad int nWeekdays[] = {1, 2, 3, 4, 5, 6}; const char* sWeekdays[] = {\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"}; for (int x = 0; x \u003c ARRAY_SIZE(sWeekdays); x++) { if (strcmp(sWeekdays[x], input) == 0) return nWeekdays[x]; } 应当确保有关联的nWeekdays和sWeekdays数据统一。 // Good const int nWeekdays[] = {1, 2, 3, 4, 5, 6, 7}; const char* sWeekdays[] = {\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"}; assert(ARRAY_SIZE(nWeekdays) == ARRAY_SIZE(sWeekdays)); for (int x = 0; x \u003c ARRAY_SIZE(sWeekdays); x++) { if (strcmp(sWeekdays[x], input) == 0) { return nWeekdays[x]; } } 关联漏洞: 高风险-内存破坏 2.6 【必须】避免函数的声明和实现不同 在头文件、源代码、文档中列举的函数声明应当一致，不应当出现定义内容错位的情况。 错误： foo.h int CalcArea(int width, int height); foo.cc int CalcArea(int height, int width) { // Different from foo.h if (height \u003e real_height) { return 0; } return height * width; } 正确： foo.h int CalcArea(int height, int width); foo.cc int CalcArea (int height, int width) { if (height \u003e real_height) { return 0; } return height * width; } 关联漏洞: 中风险-逻辑问题 2.7 【必须】检查复制粘贴的重复代码（相同代码通常代表错误） 当开发中遇到较长的句子时，如果你选择了复制粘贴语句，请记得检查每一行代码，不要出现上下两句一模一样的情况，这通常代表代码哪里出现了错误： // Bad void Foobar(SomeStruct\u0026 foobase, SomeStruct\u0026 foo1, SomeStruct\u0026 foo2) { foo1.bar = (foo1.bar \u0026 0xffff) | (foobase.base \u0026 0xffff0000); foo1.bar = (foo1.bar \u0026 0xffff) | (foobase.base \u0026 0xffff0000); } 如上例，通常可能是： // Good void Foobar(SomeStruct\u0026 foobase, SomeStruct\u0026 foo1, SomeStruct\u0026 foo2) { foo1.bar = (foo1.bar \u0026 0xffff) | (foobase.base \u0026 0xffff0000); foo2.bar = (foo2.bar \u0026 0xffff) | (foobase.base \u0026 0xffff0000); } 最好是把重复的代码片段提取成函数，如果函数比较短，可以考虑定义为 inline 函数，在减少冗余的同时也能确保不会影响性能。 关联漏洞: 中风险-逻辑问题 2.8 【必须】左右一致的重复判断/永远为真或假的判断（通常代表错误） 这通常是由于自动完成或例如Visual Assistant X之类的补全插件导致的问题。 // Bad if (foo1.bar == foo1.bar) { … } 可能是： // Good if (foo1.bar == foo2.bar) { … } 关联漏洞: 中风险-逻辑问题 2.9 【必须】函数每个分支都应有返回值 函数的每个分支都应该有返回值，否则如果函数走到无返回值的分支，其结果是未知的。 // Bad int Foo(int bar) { if (bar \u003e 100) { return 10; } else if (bar \u003e 10) { return 1; } } 上述例子当bar\u003c10时，其结果是未知的值。 // Good int Foo(int bar) { if (bar \u003e 100) { return 10; } else if (bar \u003e 10) { return 1; } return 0; } 开启适当级别的警告（GCC 中为 -Wreturn-type ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:2","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"3 多线程 3.1 【必须】变量应确保线程安全性 当一个变量可能被多个线程使用时，应当使用原子操作或加锁操作。 // Bad char g_somechar; void foo_thread1() { g_somechar += 3; } void foo_thread2() { g_somechar += 1; } 对于可以使用原子操作的，应当使用一些可以确保内存安全的操作，如： // Good volatile char g_somechar; void foo_thread1() { __sync_fetch_and_add(\u0026g_somechar, 3); } void foo_thread2() { __sync_fetch_and_add(\u0026g_somechar, 1); } 对于 C 代码，C11 后推荐使用 atomic 标准库。 对于 C++代码，C++11 后，推荐使用 std::atomic。 关联漏洞: 高风险-内存破坏 中风险-逻辑问题 3.2 【必须】注意signal handler导致的条件竞争 竞争条件经常出现在信号处理程序中，因为信号处理程序支持异步操作。攻击者能够利用信号处理程序争用条件导致软件状态损坏，从而可能导致拒绝服务甚至代码执行。 当信号处理程序中发生不可重入函数或状态敏感操作时，就会出现这些问题。因为信号处理程序中随时可以被调用。比如，当在信号处理程序中调用free时，通常会出现另一个信号争用条件，从而导致双重释放。即使给定指针在释放后设置为NULL，在释放内存和将指针设置为NULL之间仍然存在竞争的可能。 为多个信号设置了相同的信号处理程序，这尤其有问题——因为这意味着信号处理程序本身可能会重新进入。例如，malloc()和free()是不可重入的，因为它们可能使用全局或静态数据结构来管理内存，并且它们被syslog()等看似无害的函数间接使用；这些函数可能会导致内存损坏和代码执行。 // Bad char *log_message; void Handler(int signum) { syslog(LOG_NOTICE, \"%s\\n\", log_m_essage); free(log_message); sleep(10); exit(0); } int main (int argc, char* argv[]) { log_message = strdup(argv[1]); signal(SIGHUP, Handler); signal(SIGTERM, Handler); sleep(10); } 可以借由下列操作规避问题： 避免在多个处理函数中共享某些变量。 在信号处理程序中使用同步操作。 屏蔽不相关的信号，从而提供原子性。 避免在信号处理函数中调用不满足异步信号安全的函数。 关联漏洞: 高风险-内存破坏 中风险-逻辑问题 3.3 【建议】注意Time-of-check Time-of-use (TOCTOU) 条件竞争 TOCTOU： 软件在使用某个资源之前检查该资源的状态，但是该资源的状态可以在检查和使用之间更改，从而使检查结果无效。当资源处于这种意外状态时，这可能会导致软件执行错误操作。 当攻击者可以影响检查和使用之间的资源状态时，此问题可能与安全相关。这可能发生在共享资源(如文件、内存，甚至多线程程序中的变量)上。在编程时需要注意避免出现TOCTOU问题。 例如，下面的例子中，该文件可能已经在检查和lstat之间进行了更新，特别是因为printf有延迟。 struct stat *st; lstat(\"...\", st); printf(\"foo\"); if (st-\u003est_mtimespec == ...) { printf(\"Now updating things\\n\"); UpdateThings(); } TOCTOU难以修复，但是有以下缓解方案： 限制对来自多个进程的文件的交叉操作。 如果必须在多个进程或线程之间共享对资源的访问，那么请尝试限制”检查“（CHECK）和”使用“（USE）资源之间的时间量，使他们相距尽量不要太远。这不会从根本上解决问题，但可能会使攻击更难成功。 在Use调用之后重新检查资源，以验证是否正确执行了操作。 确保一些环境锁定机制能够被用来有效保护资源。但要确保锁定是检查之前进行的，而不是在检查之后进行的，以便检查时的资源与使用时的资源相同。 关联漏洞: 高风险-内存破坏 中风险-逻辑问题 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:3","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"4 加密解密 4.1 【必须】不得明文存储用户密码等敏感数据 用户密码应该使用 Argon2, scrypt, bcrypt, pbkdf2 等算法做哈希之后再存入存储系统, https://password-hashing.net/ https://libsodium.gitbook.io/doc/password_hashing/default_phf#example-2-password-storage 用户敏感数据，应该做到传输过程中加密，存储状态下加密 传输过程中加密，可以使用 HTTPS 等认证加密通信协议 存储状态下加密，可以使用 SQLCipher 等类似方案。 4.2 【必须】内存中的用户密码等敏感数据应该安全抹除 例如用户密码等，即使是临时使用，也应在使用完成后应当将内容彻底清空。 错误： #include \u003copenssl/crypto.h\u003e #include \u003cunistd.h\u003e { ... string user_password(100, '\\0'); snprintf(\u0026user_password, \"password: %s\", user_password.size(), password_from_input); ... } 正确： { ... string user_password(100, '\\0'); snprintf(\u0026user_password, \"password: %s\", user_password.size(), password_from_input); ... OPENSSL_cleanse(\u0026user_password[0], user_password.size()); } 关联漏洞: 高风险-敏感信息泄露 4.3 【必须】rand() 类函数应正确初始化 rand类函数的随机性并不高。而且在使用前需要使用srand()来初始化。未初始化的随机数可能导致某些内容可预测。 // Bad int main() { int foo = rand(); return 0; } 上述代码执行完成后，foo的值是固定的。它等效于 srand(1); rand();。 // Good int main() { srand(time(0)); int foo = rand(); return 0; } 关联漏洞: 高风险-逻辑漏洞 4.4 【必须】在需要高强度安全加密时不应使用弱PRNG函数 在需要生成 AES/SM1/HMAC 等算法的密钥/IV/Nonce， RSA/ECDSA/ECDH 等算法的私钥，这类需要高安全性的业务场景，必须使用密码学安全的随机数生成器 (Cryptographically Secure PseudoRandom Number Generator (CSPRNG) ), 不得使用 rand() 等无密码学安全性保证的普通随机数生成器。 推荐使用的 CSPRNG 有： OpenSSL 中的 RAND_bytes() 函数, https://www.openssl.org/docs/man1.1.1/man3/RAND_bytes.html libsodium 中的 randombytes_buf() 函数 Linux kernel 的 getrandom() 系统调用, https://man7.org/linux/man-pages/man2/getrandom.2.html . 或者读 /dev/urandom 文件, 或者 /dev/random 文件。 Apple IOS 的 SecRandomCopyBytes(), https://developer.apple.com/documentation/security/1399291-secrandomcopybytes Windows 下的 BCryptGenRandom(), CryptGenRandom(), RtlGenRandom() #include \u003copenssl/aes.h\u003e #include \u003copenssl/crypto.h\u003e #include \u003copenssl/rand.h\u003e #include \u003cunistd.h\u003e { unsigned char key[16]; if (1 != RAND_bytes(\u0026key[0], sizeof(key))) { //... 错误处理 return -1; } AES_KEY aes_key; if (0 != AES_set_encrypt_key(\u0026key[0], sizeof(key) * 8, \u0026aes_key)) { // ... 错误处理 return -1; } ... OPENSSL_cleanse(\u0026key[0], sizeof(key)); } rand()类函数的随机性并不高。敏感操作时，如设计加密算法时，不得使用rand()或者类似的简单线性同余伪随机数生成器来作为随机数发生器。符合该定义的比特序列的特点是，序列中“1”的数量约等于“0”的数量；同理，“01”、“00”、“10”、“11”的数量大致相同，以此类推。 例如 C 标准库中的 rand() 的实现只是简单的线性同余算法，生成的伪随机数具有较强的可预测性。 当需要实现高强度加密，例如涉及通信安全时，不应当使用 rand() 作为随机数发生器。 实际应用中，C++11 标准提供的random_device保证加密的安全性和随机性 但是 C++ 标准并不保证这一点。跨平台的代码可以考虑用 OpenSSL 等保证密码学安全的库里的随机数发生器。 关联漏洞: 高风险-敏感数据泄露 4.5 【必须】自己实现的rand范围不应过小 如果在弱安全场景相关的算法中自己实现了PRNG，请确保rand出来的随机数不会很小或可预测。 // Bad int32_t val = ((state[0] * 1103515245U) + 12345U) \u0026 999999; 上述例子可能想生成0~999999共100万种可能的随机数，但是999999的二进制是11110100001000111111，与\u0026运算后，0位一直是0，所以生成出的范围明显会小于100万种。 // Good int32_t val = ((state[0] * 1103515245U) + 12345U) % 1000000; // Good int32_t val = ((state[0] * 1103515245U) + 12345U) \u0026 0x7fffffff; 关联漏洞: 高风险-逻辑漏洞 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:4","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"5 文件操作 5.1 【必须】避免路径穿越问题 在进行文件操作时，需要判断外部传入的文件名是否合法，如果文件名中包含 ../ 等特殊字符，则会造成路径穿越，导致任意文件的读写。 错误： void Foo() { char file_path[PATH_MAX] = \"/home/user/code/\"; // 如果传入的文件名包含../可导致路径穿越 // 例如\"../file.txt\"，则可以读取到上层目录的file.txt文件 char name[20] = \"../file.txt\"; memcpy(file_path + strlen(file_path), name, sizeof(name)); int fd = open(file_path, O_RDONLY); if (fd != -1) { char data[100] = {0}; int num = 0; memset(data, 0, sizeof(data)); num = read(fd, data, sizeof(data)); if (num \u003e 0) { write(STDOUT_FILENO, data, num); } close(fd); } } 正确： void Foo() { char file_path[PATH_MAX] = \"/home/user/code/\"; char name[20] = \"../file.txt\"; // 判断传入的文件名是否非法，例如\"../file.txt\"中包含非法字符../，直接返回 if (strstr(name, \"..\") != NULL){ // 包含非法字符 return; } memcpy(file_path + strlen(file_path), name, sizeof(name)); int fd = open(file_path, O_RDONLY); if (fd != -1) { char data[100] = {0}; int num = 0; memset(data, 0, sizeof(data)); num = read(fd, data, sizeof(data)); if (num \u003e 0) { write(STDOUT_FILENO, data, num); } close(fd); } } 关联漏洞: 高风险-逻辑漏洞 5.2 【必须】避免相对路径导致的安全问题（DLL、EXE劫持等问题） 在程序中，使用相对路径可能导致一些安全风险，例如DLL、EXE劫持等问题。 例如以下代码，可能存在劫持问题： int Foo() { // 传入的是dll文件名，如果当前目录下被写入了恶意的同名dll，则可能导致dll劫持 HINSTANCE hinst = ::LoadLibrary(\"dll_nolib.dll\"); if (hinst != NULL) { cout\u003c\u003c\"dll loaded!\" \u003c\u003c endl; } return 0; } 针对DLL劫持的安全编码的规范： 1）调用LoadLibrary，LoadLibraryEx，CreateProcess，ShellExecute等进行模块加载的函数时，指明模块的完整（全）路径，禁止使用相对路径，这样就可避免从其它目录加载DLL。 2）在应用程序的开头调用SetDllDirectory(TEXT(\"\")); 从而将当前目录从DLL的搜索列表中删除。结合SetDefaultDllDirectories，AddDllDirectory，RemoveDllDirectory这几个API配合使用，可以有效的规避DLL劫持问题。这些API只能在打了KB2533623补丁的Windows7，2008上使用。 关联漏洞: 中风险-逻辑漏洞 5.3 【必须】文件权限控制 在创建文件时，需要根据文件的敏感级别设置不同的访问权限，以防止敏感数据被其他恶意程序读取或写入。 错误： int Foo() { // 不要设置为777权限，以防止被其他恶意程序操作 if (creat(\"file.txt\", 0777) \u003c 0) { printf(\"文件创建失败！\\n\"); } else { printf(\"文件创建成功！\\n\"); } return 0; } 关联漏洞: 中风险-逻辑漏洞 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:5","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"6 内存操作 6.1 【必须】防止各种越界写（向前/向后） 错误1： int a[5]; a[5] = 0; 错误2： int a[5]; int b = user_controlled_value; a[b] = 3; 关联漏洞: 高风险-内存破坏 6.2 【必须】防止任意地址写 任意地址写会导致严重的安全隐患，可能导致代码执行。因此，在编码时必须校验写入的地址。 错误： void Write(MyStruct dst_struct) { char payload[10] = { 0 }; memcpy(dst_struct.buf, payload, sizeof(payload)); } int main() { MyStruct dst_stuct; dst_stuct.buf = (char*)user_controlled_value; Write(dst_stuct); return 0; } 关联漏洞: 高风险-内存破坏 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:6","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"7 数字操作 7.1 【必须】防止整数溢出 在计算时需要考虑整数溢出的可能，尤其在进行内存操作时，需要对分配、拷贝等大小进行合法校验，防止整数溢出导致的漏洞。 错误（该例子在计算时产生整数溢出） const kMicLen = 4; // 整数溢出 void Foo() { int len = 1; char payload[10] = { 0 }; char dst[10] = { 0 }; // Bad, 由于len小于4字节，导致计算拷贝长度时，整数溢出 // len - MIC_LEN == 0xfffffffd memcpy(dst, payload, len - kMicLen); } 正确例子 void Foo() { int len = 1; char payload[10] = { 0 }; char dst[10] = { 0 }; int size = len - kMicLen; // 拷贝前对长度进行判断 if (size \u003e 0 \u0026\u0026 size \u003c 10) { memcpy(dst, payload, size); printf(\"memcpy good\\n\"); } } 关联漏洞: 高风险-内存破坏 7.2 【必须】防止Off-By-One 在进行计算或者操作时，如果使用的最大值或最小值不正确，使得该值比正确值多1或少1，可能导致安全风险。 错误： char firstname[20]; char lastname[20]; char fullname[40]; fullname[0] = '\\0'; strncat(fullname, firstname, 20); // 第二次调用strncat()可能会追加另外20个字符。如果这20个字符没有终止空字符，则存在安全问题 strncat(fullname, lastname, 20); 正确： char firstname[20]; char lastname[20]; char fullname[40]; fullname[0] = '\\0'; // 当使用像strncat()函数时，必须在缓冲区的末尾为终止空字符留下一个空字节，避免off-by-one strncat(fullname, firstname, sizeof(fullname) - strlen(fullname) - 1); strncat(fullname, lastname, sizeof(fullname) - strlen(fullname) - 1); 对于 C++ 代码，再次强烈建议使用 string、vector 等组件代替原始指针和数组操作。 关联漏洞: 高风险-内存破坏 7.3 【必须】避免大小端错误 在一些涉及大小端数据处理的场景，需要进行大小端判断，例如从大段设备取出的值，要以大段进行处理，避免端序错误使用。 关联漏洞: 中风险-逻辑漏洞 7.4 【必须】检查除以零异常 在进行除法运算时，需要判断被除数是否为零，以防导致程序不符合预期或者崩溃。 错误： double divide(double x, double y) { return x / y; } int divide(int x, int y) { return x / y; } 正确： double divide(double x, double y) { if (y == 0) { throw DivideByZero; } return x / y; } 关联漏洞: 低风险-拒绝服务 7.5 【必须】防止数字类型的错误强转 在有符号和无符号数字参与的运算中，需要注意类型强转可能导致的逻辑错误，建议指定参与计算时数字的类型或者统一类型参与计算。 错误例子 int Foo() { int len = 1; unsigned int size = 9; // 1 \u003c 9 - 10 ? 由于运算中无符号和有符号混用，导致计算结果以无符号计算 if (len \u003c size - 10) { printf(\"Bad\\n\"); } else { printf(\"Good\\n\"); } } 正确例子 void Foo() { // 统一两者计算类型为有符号 int len = 1; int size = 9; if (len \u003c size - 10) { printf(\"Bad\\n\"); } else { printf(\"Good\\n\"); } } 关联漏洞: 高风险-内存破坏 中风险-逻辑漏洞 7.6 【必须】比较数据大小时加上最小/最大值的校验 在进行数据大小比较时，要合理地校验数据的区间范围，建议根据数字类型，对其进行最大和最小值的判断，以防止非预期错误。 错误： void Foo(int index) { int a[30] = {0}; // 此处index是int型，只考虑了index小于数组大小，但是并未判断是否大于0 if (index \u003c 30) { // 如果index为负数，则越界 a[index] = 1; } } 正确： void Foo(int index) { int a[30] = {0}; // 判断index的最大最小值 if (index \u003e=0 \u0026\u0026 index \u003c 30) { a[index] = 1; } } 关联漏洞: 高风险-内存破坏 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:7","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"8 指针操作 8.1 【建议】检查在pointer上使用sizeof 除了测试当前指针长度，否则一般不会在pointer上使用sizeof。 正确： size_t pointer_length = sizeof(void*); 可能错误： size_t structure_length = sizeof(Foo*); 可能是： size_t structure_length = sizeof(Foo); 关联漏洞: 中风险-逻辑漏洞 8.2 【必须】检查直接将数组和0比较的代码 错误： int a[3]; ...; if (a \u003e 0) ...; 该判断永远为真，等价于: int a[3]; ...; if (\u0026a[0]) ...; 可能是： int a[3]; ...; if(a[0] \u003e 0) ...; 开启足够的编译器警告（GCC 中为 -Waddress，并已包含在 -Wall 中），并设置为错误，可以在编译期间发现该问题。 关联漏洞: 中风险-逻辑漏洞 8.3 【必须】不应当向指针赋予写死的地址 特殊情况需要特殊对待（比如开发硬件固件时可能需要写死） 但是如果是系统驱动开发之类的，写死可能会导致后续的问题。 关联漏洞: 高风险-内存破坏 8.4 【必须】检查空指针 错误： *foo = 100; if (!foo) { ERROR(\"foobar\"); } 正确： if (!foo) { ERROR(\"foobar\"); } *foo = 100; 错误： void Foo(char* bar) { *bar = '\\0'; } 正确： void Foo(char* bar) { if(bar) *bar = '\\0'; else ...; } 关联漏洞: 低风险-拒绝服务 8.5 【必须】释放完后置空指针 在对指针进行释放后，需要将该指针设置为NULL，以防止后续free指针的误用，导致UAF等其他内存破坏问题。尤其是在结构体、类里面存储的原始指针。 错误： void foo() { char* p = (char*)malloc(100); memcpy(p, \"hello\", 6); // 此时p所指向的内存已被释放，但是p所指的地址仍然不变 printf(\"%s\\n\", p); free(p); // 未设置为NULL，可能导致UAF等内存错误 if (p != NULL) { // 没有起到防错作用 printf(\"%s\\n\", p); // 错误使用已经释放的内存 } } 正确： void foo() { char* p = (char*)malloc(100); memcpy(p, \"hello\", 6); // 此时p所指向的内存已被释放，但是p所指的地址仍然不变 printf(\"%s\\n\", p); free(p); //释放后将指针赋值为空 p = NULL; if (p != NULL) { // 没有起到防错作用 printf(\"%s\\n\", p); // 错误使用已经释放的内存 } } 对于 C++ 代码，使用 string、vector、智能指针等代替原始内存管理机制，可以大量减少这类错误。 关联漏洞: 高风险-内存破坏 8.6 【必须】防止错误的类型转换（type confusion） 在对指针、对象或变量进行操作时，需要能够正确判断所操作对象的原始类型。如果使用了与原始类型不兼容的类型进行访问，则存在安全隐患。 错误： const int NAME_TYPE = 1; const int ID_TYPE = 2; // 该类型根据 msg_type 进行区分，如果在对MessageBuffer进行操作时没有判断目标对象，则存在类型混淆 struct MessageBuffer { int msg_type; union { const char *name; int name_id; }; }; void Foo() { struct MessageBuffer buf; const char* default_message = \"Hello World\"; // 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name buf.msg_type = NAME_TYPE; buf.name = default_message; printf(\"Pointer of buf.name is %p\\n\", buf.name); // 没有判断目标消息类型是否为ID_TYPE，直接修改nameID，导致类型混淆 buf.name_id = user_controlled_value; if (buf.msg_type == NAME_TYPE) { printf(\"Pointer of buf.name is now %p\\n\", buf.name); // 以NAME_TYPE作为类型操作，可能导致非法内存读写 printf(\"Message: %s\\n\", buf.name); } else { printf(\"Message: Use ID %d\\n\", buf.name_id); } } 正确（判断操作的目标是否是预期类型）： void Foo() { struct MessageBuffer buf; const char* default_message = \"Hello World\"; // 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name buf.msg_type = NAME_TYPE; buf.name = default_msessage; printf(\"Pointer of buf.name is %p\\n\", buf.name); // 判断目标消息类型是否为 ID_TYPE，不是预期类型则做对应操作 if (buf.msg_type == ID_TYPE) buf.name_id = user_controlled_value; if (buf.msg_type == NAME_TYPE) { printf(\"Pointer of buf.name is now %p\\n\", buf.name); printf(\"Message: %s\\n\", buf.name); } else { printf(\"Message: Use ID %d\\n\", buf.name_id); } } 关联漏洞: 高风险-内存破坏 8.7 【必须】智能指针使用安全 在使用智能指针时，防止其和原始指针的混用，否则可能导致对象生命周期问题，例如 UAF 等安全风险。 错误例子： class Foo { public: explicit Foo(int num) { data_ = num; }; void Function() { printf(\"Obj is %p, data = %d\\n\", this, data_); }; private: int data_; }; std::unique_ptr\u003cFoo\u003e fool_u_ptr = nullptr; Foo* pfool_raw_ptr = nullptr; void Risk() { fool_u_ptr = make_unique\u003cFoo\u003e(1); // 从独占智能指针中获取原始指针,\u003cFoo\u003e(1) pfool_raw_ptr = fool_u_ptr.get(); // 调用\u003cFoo\u003e(1)的函数 pfool_raw_ptr-\u003eFunction(); // 独占智能指针重新赋值后会释放内存 fool_u_ptr = make_unique\u003cFoo\u003e(2); // 通过原始指针操作会导致UAF，pfool_raw_ptr指向的对象已经释放 pfool_raw_ptr-\u003eFunction(); } // 输出： // Obj is 0000027943087B80, data = 1 // Obj is 0000027943087B80, data = -572662307 正确，通过智能指针操作: void Safe() { fool_u_ptr = make_unique\u003cFoo\u003e(1); // 调用\u003cFoo\u003e(1)的函数 fool_u_ptr-\u003efunction(); fool_u_ptr = make_unique\u003cFoo\u003e(2); // 调用\u003cFoo\u003e(2)的函数 fool_u_ptr-\u003efunction(); } // 输出： // Obj is 000002C7BB550830, data = 1 // Obj is 000002C7BB557AF0, data = 2 关联漏洞: 高风险-内存破坏 ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:1:8","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Development"],"content":"参考链接 https://www.w3cschool.cn/secguide/secguide-ysdn3fk5.html ","date":"2021-01-04","objectID":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/:2:0","tags":["Coding","C/C++"],"title":"通用安全编码指南 -- C/C++ 篇","uri":"/2021/01/%E9%80%9A%E7%94%A8%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E6%8C%87%E5%8D%97-c-c-/"},{"categories":["Fuzz"],"content":"Fuzzing 101 系列 note 5","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"本文是Fuzzing101系列第四篇，fuzz的对象为 LibXML2 。 ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:0:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"1. Basic Info Target CVES to find Time estimated Main topics LibXML2 CVE-2017-9048 3hous measure the code coverage data CVE-2017-13028: Out-of-bounds Read vulneratibily. ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:1:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"2. Learning Target 在fuzzer中使用自定义词典 使用多个内核并行进行fuzz ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:2:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"3. Fuzzing ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:3:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"1. Workflow 找到一个使用LibXML2共享库的应用程序 复制SampleInput.xml文件到AFL的input目录 创建fuzzing XML的常规目录 开始fuzz，直到出现crash 使用造成crash的poc重现crash 修复漏洞 ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:3:1","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"2. Solution 1. Download and build target 首先创建待fuzz的LibXML2环境，进行编译待用： cd $HOME mkdir Fuzzing_libxml2 \u0026\u0026 cd Fuzzing_libxml2 # download and uncompress the target wget http://xmlsoft.org/download/libxml2-2.9.4.tar.gz tar xvf libxml2-2.9.4.tar.gz \u0026\u0026 cd libxml2-2.9.4/ # build and install libtiff sudo apt-get install python-dev CC=afl-clang-lto CXX=afl-clang-lto++ CFLAGS=\"-fsanitize=address\" CXXFLAGS=\"-fsanitize=address\" LDFLAGS=\"-fsanitize=address\" ./configure --prefix=\"$HOME/Fuzzing_libxml2/libxml2-2.9.4/install\" --disable-shared --without-debug --without-ftp --without-http --without-legacy --without-python LIBS='-ldl' make -j$(nproc) make install # test the target program ./xmllint --memory ./test/wml.xml 以上安装不报错的话，可以正常调用LibXML库 ： 注意一下上面的warning，有提示如果出现AFL++崩溃的情况，可以考虑讲AFL_MAP_SIZE的大小设置为146056. 2. Seed corpus creation 这里直接使用SampleInput.xml做为XML的样例： \u003c!DOCTYPE a []\u003e 3. Custom dictionary 这里直接使用AFL++提供的XML的dict： mkdir dictionaries \u0026\u0026 cd dictionaries wget https://github.com/AFLplusplus/AFLplusplus/blob/stable/dictionaries/xml.dict cd .. 4. Fuzzing 执行 afl-fuzz ，采用并行方式进行fuzz: afl-fuzz -m none -i ./afl_in -o afl_out -s 123 -x ./dictionaries/xml.dict -M master -- ./xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@ afl-fuzz -m none -i ./afl_in -o afl_out -s 234 -x ./dictionaries/xml.dict -S slave1 -- ./xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@ ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:3:2","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"3. Crashes 最终没有跑出来crash（肯定是哪里出了问题）： ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:3:3","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"4. Triage 这里直接使用的是教程里的： ./xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude './afl_out/default/crashes/id:000000,sig:06,src:003963,time:12456489,op:havoc,rep:4' ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:4:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"5. Fix 官方的修复地址： https://github.com/GNOME/libxml2/commit/932cc9896ab41475d4aa429c27d9afd175959d74 后续将对该漏洞进行深入分析和补丁分析，待完善。 ","date":"2020-12-18","objectID":"/2020/12/fuzzing101-5/:5:0","tags":["Fuzz","AFL"],"title":"Fuzzing 101 -- 5","uri":"/2020/12/fuzzing101-5/"},{"categories":["Fuzz"],"content":"AFL二三事系列 note 2","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"本文是AFL系列第二篇，主要介绍AFL的一些基本原理。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:0:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"一、代码覆盖率 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:1:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"1. 计算方法 代码覆盖率的计量单位，通常有3种： 函数（Fuction-Level） 基本块（BasicBlock-Level） 边界（Edge-Level） （1）函数（Fuction-Level） 这个很容易理解，就是代码执行时调用到哪些函数，但是函数里面的具体代码行却不作统计，相对比较粗糙但高效的统计方式。 所以，通常的统计方式是用基本块，简称BB。 （2）基本块（BasicBlock-Level） 基本块，直接看下图就很容易理解了。 IDA中每一块代码就代表着一个基本块，就是以指令跳转为作划分界限的。 （3）边界（Edge-Level） edge本身就涵盖了基本块部分，唯一的差别是edge多记录了一些执行边界的信息。比如示例代码： 在IDA中可以看到A、B、C这3个基本块，但当a为假时，程序就会从A执行到C。 前面基本块的方式就无法确切地知道是否曾从A执行到C，尤其是该段代码被多次执行的情况，就更无法知道，这时edge覆盖方式就出现了。 edge会在A跟C之间建立虚拟块D，通过判断D是否执行过，来确认是否曾从A执行到C，这种方式也会比较消耗性能。 以上内容摘自泉哥博客，原文链接https://riusksk.me/2018/07/29/honggfuzz%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF1/ AFL采用的是第三种方式。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:1:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"2. AFL中两种代码覆盖率计算方式 AFL支持两种代码覆盖率计算方式，有源码的情况下，在源代码编译时进行插桩，无源码的情况下，使用QEMU进行二进制插桩。下一章节会分别详细讲解这两种情况使用的插桩技术。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:1:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"二、插桩 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:2:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"1. 有源码 我们以如下代码为例进行说明，文件名为 socket.c #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cstring.h\u003e#include\u003cunistd.h\u003e#include\u003csys/socket.h\u003e#include\u003cnetinet/in.h\u003e #define SERV_PORT 8000 #define SIZE 100 #define MAXLINE 64 int command(char* buf) { char recv[32]; memset(recv, 32, 0); strcpy(recv, buf + 8); return 0; } int main() { struct sockaddr_in servaddr,cliaddr; socklen_t cliaddr_len; int listenfd,connfd; char buf[MAXLINE]; int i,n,flag = 0; listenfd = socket(AF_INET,SOCK_STREAM,0); bzero(\u0026servaddr,sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd,(struct sockaddr *)\u0026servaddr,sizeof(servaddr)); listen(listenfd,20); printf(\"Accepting connections..\\n\"); cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd,(struct sockaddr *)\u0026cliaddr,\u0026cliaddr_len); char send_msg[MAXLINE*2] = \"hello, send by send() :\\n\"; send(connfd, send_msg, strlen(send_msg), 0); n = read(connfd,buf,MAXLINE); if(n!=0){ if(!strncmp(buf, \"test \", 5)) sprintf(send_msg, \"test: %s\\n\", buf + 5); else if(!strncmp(buf, \"help\", 4)) sprintf(send_msg, \"help:\\n\\ttest\\n\\tcommand\\n\\texit\\n\"); else if(!strncmp(buf, \"command \", 8)){ command(buf); sprintf(send_msg, \"it's a command\\n\"); } else if(!strncmp(buf, \"exit\", 4)) send(connfd, \"bye~\\n\", 4, 0); else sprintf(send_msg, \"unknown command!\\n\"); send(connfd, send_msg, strlen(send_msg), 0); } else printf(\"Client say close the connection..\\n\"); close(connfd); } 可以进行源码插桩的指令有 afl-gcc、afl-g++、afl-clang、afl-clang++ ( afl-clang-fast 和 afl-clang-fast++ 暂不讨论)，通过查看这些文件的具体属性，可以发现后三者都是 afl-gcc 的软链接，其实都是同一个二进制文件： 通过分析 afl-gcc.c 中的代码可以发现， afl-gcc 就是在原有的编译指令上增加一些编译选项然后调用对应的系统调用指令： 为了方便查看每次源码编译时的编译选项，可以对 afl-gcc.c 进行修改，在 main() 函数中调用 execvp() 之前添加如下代码，打印出实际执行的编译指令： //print command for(int i = 0; i \u003c cc_par_cnt; i++){ printf(\"%s \", cc_params[i]); } printf(\"\\n\"); 其中数组 cc_params 存放着编译指令和选项，整数 cc_par_cnt 存放数组有效值，修改完成后对AFL重新进行编译即可。 （afl-clang-fast 和 afl-clang-fast++ 对应的源码文件为 llvm_mode/afl-clang-fast.c ，修改方法相同） 使用 afl-gcc 对上面代码进行编译 afl-gcc -o socket_afl socket.c 可以看到实际执行的编译指令为 gcc -o socket socket.c -B /usr/local/lib/afl -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 ，其中 -B \u003cdirectory\u003e 选项用于将添加到编译器的搜索路径，-g 选项生成调试信息，-O3 优化生成代码，-funroll-loops 选项展开循环的迭代次数可以在编译时或进入循环时确定，剩余两个为AFL使用的选项。（gcc的选项可以参考此链接 https://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Optimize-Options.html） 如果了解编译过程，那么就知道把源代码编译成二进制，主要是经过”源代码”-\u003e”汇编代码”-\u003e”二进制”这样的过程。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是as。不过，编译完成AFL后，在其目录下也会存在一个as文件，并作为符号链接指向afl-as。所以，如果通过-B选项为gcc设置了搜索路径，那么afl-as便会作为汇编器，执行实际的汇编操作。 所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过 afl-as 完成。 afl-as 下面通过对比 gcc 和 afl-gcc 的编译结果进行大致分析。 将 afl-gcc 中添加的 -B、-D__AFL_COMPILER=1、DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 三个选项去掉，调用 gcc gcc -o socket socket.c -g -O3 -funroll-loops 这样就生成了 socket_afl 和 socket 两个文件。 使用 bindiff 对这两个文件中的 main 函数进行对比 上图中右下角部分看起来结构不一样，不过这里是 bindiff 识别bug，多出了一个代码块并且少了一条线，我们可以分别使用 ida 打开这两个文件，查看 main 函数的结构图 这里对 bindiff 误报结果的详细分析就不多说了，这个不是本次的重点。 可以看到 afl 进行源代码插桩时不会改变代码的逻辑结构，也不会增加或减少代码块。 对比看下每个代码块中代码的区别 可以看出，基本每个代码块都被添加了一段相似的汇编代码 在 ida 中将这部分代码拷贝出来，如下： lea rsp, [rsp-98h] mov [rsp+1D0h+var_1D0], rdx mov [rsp+1D0h+var_1C8], rcx mov [rsp+1D0h+var_1C0], n mov rcx, 650Eh call __afl_maybe_log mov n, [rsp+1D0h+var_1C0] mov rcx, [rsp+1D0h+var_1C8] mov rdx, [rsp+1D0h+var_1D0] lea rsp, [rsp+98h] 对比可以发现，不同的代码块只有 mov rcx, 650Eh 这条汇编代码向 rcx 存放的值不同，这个就是随机生成的标识代码块的id，当运行到这部分汇编时 afl 就知道是哪个代码块被执行了。 上述 ida 中的汇编代码原型可以在 afl-as.h 中找到（以64位代码为例）： 上述代码执行的主要功能包括： 保存 rdx、 rcx 、rax 寄存器 将 rcx 的值设置为 fprintf() 函数将要打印的变量内容 调用 __afl_maybe_log 函数 恢复寄存器 在以上的功能中， __afl_maybe_log 是插桩代码所执行的实际内容，后续将详细展开。 可以在 afl-as.c 中查看到该汇编的调用，通过 fprintf() 函数的调用，将格式化字符串添加到汇编文件的相应位置。 这里分析下 R(MAP_SIZE) ，它就是上面汇编代码中将 rcx 设置的值。根据定义， MAP_SIZE 为64K，而对于 R(x) 函数定义如下： 其中 R(MAP_SIZE) 相当于 random() % (1 \u003c\u003c MAP_SIZE_POW2) ，也就是生成随机数，所以标识代码块的id是随机生成的（两次编译生成的代码段id不同）。 上述过程总结起来就是在处理到某个分支需要插入桩代码时， afl-as 会随机生成一个随机数，作为运行时保存在 rcx 中的值。而这个随机数，便是用于标识这个代码块的id。 （备注：因为代码块ID随机的问题，会导致一定的","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:2:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"2. 无源码 无源码情况下，AFL使用QEMU进行二进制插桩，具体插桩原理待补充。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:2:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"三、变异策略 AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下： bitflip，按位翻转，1变为0，0变为1 arithmetic，整数加/减算术运算 interest，把一些特殊内容替换到原文件中 dictionary，把自动生成或用户提供的token替换/插入到原文件中 havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异 splice，中文意思是“拼接”，此阶段会将两个文件拼接起来得到一个新的文件 其中，前四项 bitflip, arithmetic, interest, dictionary 是非 dumb mode（-d）和主 fuzzer（-M）会进行的操作，由于其变异方式没有随机性，所以也称为 deterministic fuzzing ；havoc 和 splice 则存在随机性，是所有状况的 fuzzer（是否 dumb mode、主从 fuzzer）都会执行的变异。 以下将对这些变异类型进行具体介绍。 ###（1） bitflip 拿到一个原始文件，首先进行的就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为： bitflip 1/1， 每次翻转1个bit，按照每1个bit的步长从头开始 bitflip 2/1， 每次翻转相邻的2个bit，按照每1个bit的步长从头开始 bitflip 4/1， 每次翻转相邻的4个bit，按照每1个bit的步长从头开始 bitflip 8/8， 每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转 bitflip 16/8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转 bitflip 32/8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转 在上述过程中，AFL巧妙地嵌入了一些对文件格式的启发式判断，以图尽可能多得获取文件信息。 自动检测token 在进行 bitflip 1/1变异时，对于每个 byte 的最低位( least significant bit )翻转还进行了额外的处理：如果连续多个 bytes 的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的 bytes 判断是一条token。 例如，PNG文件中用IHDR作为起始块的标识，那么就会存在类似于以下的内容： ........IHDR........ 当翻转到字符I的最高位时，因为IHDR被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，IHDR标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：IHDR，并将其记录下来为后面的变异提供备选。 AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在config.h中通过宏定义了限制： /* Length limits for auto-detected dictionary tokens: */ #define MIN_AUTO_EXTRA 3 #define MAX_AUTO_EXTRA 32 /* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. */ #define USE_AUTO_EXTRAS 10 #define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10) 对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改 MAX_AUTO_EXTRA 为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。 生成effector map 在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。 具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。 这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。 由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。 不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关： /* Minimum input file length at which the effector logic kicks in: */ #define EFF_MIN_LEN 128 /* Maximum effector density past which everything is just fuzzed unconditionally (%): */ #define EFF_MAX_PERC 90 即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。 ###（2） arithmetic 在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段： arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异 arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异 arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异 加减变异的上限，在config.h中的宏ARITH_MAX定义，默认为35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。 此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。 ###（3） interest 下一个阶段是interest，具体可分为： interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换 interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换 interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换 而用于替换的”interesting values”，是AFL预设的一些比较特殊的数： static s8 interesting_8[] = { INTERESTING_8 }; static s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 }; static s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 }; 这些数的定义在config.h文件中： /* List of interesting values to use in fuzzing. */ #define INTERESTING_8 \\ -128, /* Overflow signed 8-bit when decremented */\\ -1, /* */\\ 0, /* */\\ 1, /* */\\ 16, /* One-off with common buffer size */\\ 32, /* One-off with common buffer size */\\ 64, /* One-off w","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:3:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"效果分析 参考 https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html 中的测试方法，同样以 djpeg 为目标，最初的样本集只有一个文本 test，采用二进制插桩的方式进行fuzz，1个主节点以及3个从节点同时进行，测试最终是否能fuzz出一个合法的图片文件。 fuzz后的样本集合如下： 使用 afl-showmap 对所有样本进行分析，编写脚本如下： #!/bin/bash path=$1 dpath=$2 rm -rf $2/* for file in $(ls $1) do echo -e '\\n'$file afl-showmap -o $2/$file -Q -- /usr/bin/djpeg $1/$file echo -e '-------------------------------------\\n' done 第一个参数为样本集合目录，第二个参数为输出目录，假设脚本名为 djpeg.sh ，样本目录为 in ，输出目录为 map ./djpeg.sh in map 脚本的执行结果可在 分析/djpeg_sh脚本输出结果.txt 中查看，以下只展示部分： id:000000,orig:1 afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Not a JPEG file: starts with 0x74 0x65 -- Program output ends -- [+] Captured 50 tuples in 'map/id:000000,orig:1'. ------------------------------------- id:000001,src:000000,op:havoc,rep:64,+cov afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Corrupt JPEG data: 2 extraneous bytes before marker 0xfe JPEG datastream contains no image -- Program output ends -- [+] Captured 68 tuples in 'map/id:000001,src:000000,op:havoc,rep:64,+cov'. ------------------------------------- id:000005,src:000000+000001,op:splice,rep:64 afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Corrupt JPEG data: 6 extraneous bytes before marker 0xfe JPEG datastream contains no image -- Program output ends -- [+] Captured 68 tuples in 'map/id:000005,src:000000+000001,op:splice,rep:64'. ------------------------------------- id:000021,src:000011,op:flip32,pos:2,+cov afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Premature end of JPEG file JPEG datastream contains no image -- Program output ends -- [+] Captured 59 tuples in 'map/id:000021,src:000011,op:flip32,pos:2,+cov'. ------------------------------------- id:000026,src:000021,op:havoc,rep:2 afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Premature end of JPEG file JPEG datastream contains no image -- Program output ends -- [+] Captured 60 tuples in 'map/id:000026,src:000021,op:havoc,rep:2'. ------------------------------------- 可以看到上面样本id为21和26的输出结果相同，但是执行路径不同，可以使用 diff 指令进行路径对比： diff -Nu map/id\\:000021\\,src\\:000011\\,op\\:flip32\\,pos\\:2\\,+cov map/id\\:000026\\,src\\:000021\\,op\\:havoc\\,rep\\:2 结果如下： --- map/id:000021,src:000011,op:flip32,pos:2,+cov 2019-12-03 06:38:42.236000000 +0000 +++ map/id:000026,src:000021,op:havoc,rep:2 2019-12-03 06:38:42.388000000 +0000 @@ -1,20 +1,21 @@ 003224:1 004793:1 005209:1 -005993:1 +005993:2 006601:1 007073:1 008498:1 008874:1 -010130:1 +010130:2 010146:1 010282:1 -013459:1 +013459:2 +014971:1 017564:1 018892:1 019132:1 019148:1 -019172:1 +019172:2 019188:1 019236:1 019804:1 @@ -33,18 +34,18 @@ 032872:1 033112:1 037297:1 -037433:1 +037433:2 037817:1 039585:1 -039641:2 -043450:1 +039641:4 +043450:2 043562:1 044194:1 044818:1 045483:1 046955:1 047603:1 -048251:1 +048251:2 051300:1 052444:1 053124:1 从最初的只有文本内容“test”的样本，afl确实已经发现了很多其它路径，但是在我的测试结果中还是没有fuzz出正常的图片文件，从输出结果上看样本id为21和26算是比较接近，没有报明显错误。 Premature end of JPEG file JPEG datastream contains no image ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:3:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"参考链接 https://github.com/google/AFL https://www.secpulse.com/archives/71903.html https://www.freebuf.com/articles/system/191536.html http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html https://paper.seebug.org/841/ https://paper.seebug.org/496/#part-2afl https://rk700.github.io/2017/12/28/afl-internals/ https://rk700.github.io/2018/01/04/afl-mutations/ https://rk700.github.io/2018/02/02/afl-enhancement/ ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/:3:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B2/"},{"categories":["Fuzz"],"content":"AFL二三事系列 note 2","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"本文是AFL系列第二篇，主要介绍AFL的一些基本原理。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:0:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"一、代码覆盖率 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:1:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"1. 计算方法 代码覆盖率的计量单位，通常有3种： 函数（Fuction-Level） 基本块（BasicBlock-Level） 边界（Edge-Level） （1）函数（Fuction-Level） 这个很容易理解，就是代码执行时调用到哪些函数，但是函数里面的具体代码行却不作统计，相对比较粗糙但高效的统计方式。 所以，通常的统计方式是用基本块，简称BB。 （2）基本块（BasicBlock-Level） 基本块，直接看下图就很容易理解了。 IDA中每一块代码就代表着一个基本块，就是以指令跳转为作划分界限的。 （3）边界（Edge-Level） edge本身就涵盖了基本块部分，唯一的差别是edge多记录了一些执行边界的信息。比如示例代码： 在IDA中可以看到A、B、C这3个基本块，但当a为假时，程序就会从A执行到C。 前面基本块的方式就无法确切地知道是否曾从A执行到C，尤其是该段代码被多次执行的情况，就更无法知道，这时edge覆盖方式就出现了。 edge会在A跟C之间建立虚拟块D，通过判断D是否执行过，来确认是否曾从A执行到C，这种方式也会比较消耗性能。 以上内容摘自泉哥博客，原文链接https://riusksk.me/2018/07/29/honggfuzz%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF1/ AFL采用的是第三种方式。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:1:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"2. AFL中两种代码覆盖率计算方式 AFL支持两种代码覆盖率计算方式，有源码的情况下，在源代码编译时进行插桩，无源码的情况下，使用QEMU进行二进制插桩。下一章节会分别详细讲解这两种情况使用的插桩技术。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:1:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"二、插桩 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:2:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"1. 有源码 我们以如下代码为例进行说明，文件名为 socket.c #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003cstring.h\u003e#include\u003cunistd.h\u003e#include\u003csys/socket.h\u003e#include\u003cnetinet/in.h\u003e #define SERV_PORT 8000 #define SIZE 100 #define MAXLINE 64 int command(char* buf) { char recv[32]; memset(recv, 32, 0); strcpy(recv, buf + 8); return 0; } int main() { struct sockaddr_in servaddr,cliaddr; socklen_t cliaddr_len; int listenfd,connfd; char buf[MAXLINE]; int i,n,flag = 0; listenfd = socket(AF_INET,SOCK_STREAM,0); bzero(\u0026servaddr,sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd,(struct sockaddr *)\u0026servaddr,sizeof(servaddr)); listen(listenfd,20); printf(\"Accepting connections..\\n\"); cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd,(struct sockaddr *)\u0026cliaddr,\u0026cliaddr_len); char send_msg[MAXLINE*2] = \"hello, send by send() :\\n\"; send(connfd, send_msg, strlen(send_msg), 0); n = read(connfd,buf,MAXLINE); if(n!=0){ if(!strncmp(buf, \"test \", 5)) sprintf(send_msg, \"test: %s\\n\", buf + 5); else if(!strncmp(buf, \"help\", 4)) sprintf(send_msg, \"help:\\n\\ttest\\n\\tcommand\\n\\texit\\n\"); else if(!strncmp(buf, \"command \", 8)){ command(buf); sprintf(send_msg, \"it's a command\\n\"); } else if(!strncmp(buf, \"exit\", 4)) send(connfd, \"bye~\\n\", 4, 0); else sprintf(send_msg, \"unknown command!\\n\"); send(connfd, send_msg, strlen(send_msg), 0); } else printf(\"Client say close the connection..\\n\"); close(connfd); } 可以进行源码插桩的指令有 afl-gcc、afl-g++、afl-clang、afl-clang++ ( afl-clang-fast 和 afl-clang-fast++ 暂不讨论)，通过查看这些文件的具体属性，可以发现后三者都是 afl-gcc 的软链接，其实都是同一个二进制文件： 通过分析 afl-gcc.c 中的代码可以发现， afl-gcc 就是在原有的编译指令上增加一些编译选项然后调用对应的系统调用指令： 为了方便查看每次源码编译时的编译选项，可以对 afl-gcc.c 进行修改，在 main() 函数中调用 execvp() 之前添加如下代码，打印出实际执行的编译指令： //print command for(int i = 0; i \u003c cc_par_cnt; i++){ printf(\"%s \", cc_params[i]); } printf(\"\\n\"); 其中数组 cc_params 存放着编译指令和选项，整数 cc_par_cnt 存放数组有效值，修改完成后对AFL重新进行编译即可。 （afl-clang-fast 和 afl-clang-fast++ 对应的源码文件为 llvm_mode/afl-clang-fast.c ，修改方法相同） 使用 afl-gcc 对上面代码进行编译 afl-gcc -o socket_afl socket.c 可以看到实际执行的编译指令为 gcc -o socket socket.c -B /usr/local/lib/afl -g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 ，其中 -B \u003cdirectory\u003e 选项用于将添加到编译器的搜索路径，-g 选项生成调试信息，-O3 优化生成代码，-funroll-loops 选项展开循环的迭代次数可以在编译时或进入循环时确定，剩余两个为AFL使用的选项。（gcc的选项可以参考此链接 https://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Optimize-Options.html） 如果了解编译过程，那么就知道把源代码编译成二进制，主要是经过”源代码”-\u003e”汇编代码”-\u003e”二进制”这样的过程。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是as。不过，编译完成AFL后，在其目录下也会存在一个as文件，并作为符号链接指向afl-as。所以，如果通过-B选项为gcc设置了搜索路径，那么afl-as便会作为汇编器，执行实际的汇编操作。 所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过 afl-as 完成。 afl-as 下面通过对比 gcc 和 afl-gcc 的编译结果进行大致分析。 将 afl-gcc 中添加的 -B、-D__AFL_COMPILER=1、DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1 三个选项去掉，调用 gcc gcc -o socket socket.c -g -O3 -funroll-loops 这样就生成了 socket_afl 和 socket 两个文件。 使用 bindiff 对这两个文件中的 main 函数进行对比 上图中右下角部分看起来结构不一样，不过这里是 bindiff 识别bug，多出了一个代码块并且少了一条线，我们可以分别使用 ida 打开这两个文件，查看 main 函数的结构图 这里对 bindiff 误报结果的详细分析就不多说了，这个不是本次的重点。 可以看到 afl 进行源代码插桩时不会改变代码的逻辑结构，也不会增加或减少代码块。 对比看下每个代码块中代码的区别 可以看出，基本每个代码块都被添加了一段相似的汇编代码 在 ida 中将这部分代码拷贝出来，如下： lea rsp, [rsp-98h] mov [rsp+1D0h+var_1D0], rdx mov [rsp+1D0h+var_1C8], rcx mov [rsp+1D0h+var_1C0], n mov rcx, 650Eh call __afl_maybe_log mov n, [rsp+1D0h+var_1C0] mov rcx, [rsp+1D0h+var_1C8] mov rdx, [rsp+1D0h+var_1D0] lea rsp, [rsp+98h] 对比可以发现，不同的代码块只有 mov rcx, 650Eh 这条汇编代码向 rcx 存放的值不同，这个就是随机生成的标识代码块的id，当运行到这部分汇编时 afl 就知道是哪个代码块被执行了。 上述 ida 中的汇编代码原型可以在 afl-as.h 中找到（以64位代码为例）： 上述代码执行的主要功能包括： 保存 rdx、 rcx 、rax 寄存器 将 rcx 的值设置为 fprintf() 函数将要打印的变量内容 调用 __afl_maybe_log 函数 恢复寄存器 在以上的功能中， __afl_maybe_log 是插桩代码所执行的实际内容，后续将详细展开。 可以在 afl-as.c 中查看到该汇编的调用，通过 fprintf() 函数的调用，将格式化字符串添加到汇编文件的相应位置。 这里分析下 R(MAP_SIZE) ，它就是上面汇编代码中将 rcx 设置的值。根据定义， MAP_SIZE 为64K，而对于 R(x) 函数定义如下： 其中 R(MAP_SIZE) 相当于 random() % (1 \u003c\u003c MAP_SIZE_POW2) ，也就是生成随机数，所以标识代码块的id是随机生成的（两次编译生成的代码段id不同）。 上述过程总结起来就是在处理到某个分支需要插入桩代码时， afl-as 会随机生成一个随机数，作为运行时保存在 rcx 中的值。而这个随机数，便是用于标识这个代码块的id。 （备注：因为代码块ID随机的问题，会导致一定的","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:2:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"2. 无源码 无源码情况下，AFL使用QEMU进行二进制插桩，具体插桩原理待补充。 ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:2:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"三、变异策略 AFL维护了一个队列(queue)，每次从这个队列中取出一个文件，对其进行大量变异，并检查运行后是否会引起目标崩溃、发现新路径等结果。变异的主要类型如下： bitflip，按位翻转，1变为0，0变为1 arithmetic，整数加/减算术运算 interest，把一些特殊内容替换到原文件中 dictionary，把自动生成或用户提供的token替换/插入到原文件中 havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异 splice，中文意思是“拼接”，此阶段会将两个文件拼接起来得到一个新的文件 其中，前四项 bitflip, arithmetic, interest, dictionary 是非 dumb mode（-d）和主 fuzzer（-M）会进行的操作，由于其变异方式没有随机性，所以也称为 deterministic fuzzing ；havoc 和 splice 则存在随机性，是所有状况的 fuzzer（是否 dumb mode、主从 fuzzer）都会执行的变异。 以下将对这些变异类型进行具体介绍。 ###（1） bitflip 拿到一个原始文件，首先进行的就是bitflip，而且还会根据翻转量/步长进行多种不同的翻转，按照顺序依次为： bitflip 1/1， 每次翻转1个bit，按照每1个bit的步长从头开始 bitflip 2/1， 每次翻转相邻的2个bit，按照每1个bit的步长从头开始 bitflip 4/1， 每次翻转相邻的4个bit，按照每1个bit的步长从头开始 bitflip 8/8， 每次翻转相邻的8个bit，按照每8个bit的步长从头开始，即依次对每个byte做翻转 bitflip 16/8，每次翻转相邻的16个bit，按照每8个bit的步长从头开始，即依次对每个word做翻转 bitflip 32/8，每次翻转相邻的32个bit，按照每8个bit的步长从头开始，即依次对每个dword做翻转 在上述过程中，AFL巧妙地嵌入了一些对文件格式的启发式判断，以图尽可能多得获取文件信息。 自动检测token 在进行 bitflip 1/1变异时，对于每个 byte 的最低位( least significant bit )翻转还进行了额外的处理：如果连续多个 bytes 的最低位被翻转后，程序的执行路径都未变化，而且与原始执行路径不一致，那么就把这一段连续的 bytes 判断是一条token。 例如，PNG文件中用IHDR作为起始块的标识，那么就会存在类似于以下的内容： ........IHDR........ 当翻转到字符I的最高位时，因为IHDR被破坏，此时程序的执行路径肯定与处理正常文件的路径是不同的；随后，在翻转接下来3个字符的最高位时，IHDR标识同样被破坏，程序应该会采取同样的执行路径。由此，AFL就判断得到一个可能的token：IHDR，并将其记录下来为后面的变异提供备选。 AFL采取的这种方式是非常巧妙的：就本质而言，这实际上是对每个byte进行修改并检查执行路径；但集成到bitflip后，就不需要再浪费额外的执行资源了。此外，为了控制这样自动生成的token的大小和数量，AFL还在config.h中通过宏定义了限制： /* Length limits for auto-detected dictionary tokens: */ #define MIN_AUTO_EXTRA 3 #define MAX_AUTO_EXTRA 32 /* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing (first value), and to keep in memory as candidates. The latter should be much higher than the former. */ #define USE_AUTO_EXTRAS 10 #define MAX_AUTO_EXTRAS (USE_AUTO_EXTRAS * 10) 对于一些文件来说，我们已知其格式中出现的token长度不会超过4，那么我们就可以修改 MAX_AUTO_EXTRA 为4并重新编译AFL，以排除一些明显不会是token的情况。遗憾的是，这些设置是通过宏定义来实现，所以不能做到运行时指定，每次修改后必须重新编译AFL。 生成effector map 在进行bitflip 8/8变异时，AFL还生成了一个非常重要的信息：effector map。这个effector map几乎贯穿了整个deterministic fuzzing的始终。 具体地，在对每个byte进行翻转时，如果其造成执行路径与原始路径不一致，就将该byte在effector map中标记为1，即“有效”的，否则标记为0，即“无效”的。 这样做的逻辑是：如果一个byte完全翻转，都无法带来执行路径的变化，那么这个byte很有可能是属于”data”，而非”metadata”（例如size, flag等），对整个fuzzing的意义不大。所以，在随后的一些变异中，会参考effector map，跳过那些“无效”的byte，从而节省了执行资源。 由此，通过极小的开销（没有增加额外的执行次数），AFL又一次对文件格式进行了启发式的判断。看到这里，不得不叹服于AFL实现上的精妙。 不过，在某些情况下并不会检测有效字符。第一种情况就是dumb mode或者从fuzzer，此时文件所有的字符都有可能被变异。第二、第三种情况与文件本身有关： /* Minimum input file length at which the effector logic kicks in: */ #define EFF_MIN_LEN 128 /* Maximum effector density past which everything is just fuzzed unconditionally (%): */ #define EFF_MAX_PERC 90 即默认情况下，如果文件小于128 bytes，那么所有字符都是“有效”的；同样地，如果AFL发现一个文件有超过90%的bytes都是“有效”的，那么也不差那10%了，大笔一挥，干脆把所有字符都划归为“有效”。 ###（2） arithmetic 在bitflip变异全部进行完成后，便进入下一个阶段：arithmetic。与bitflip类似的是，arithmetic根据目标大小的不同，也分为了多个子阶段： arith 8/8，每次对8个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个byte进行整数加减变异 arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异 arith 32/8，每次对32个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个dword进行整数加减变异 加减变异的上限，在config.h中的宏ARITH_MAX定义，默认为35。所以，对目标整数会进行+1, +2, …, +35, -1, -2, …, -35的变异。特别地，由于整数存在大端序和小端序两种表示方式，AFL会贴心地对这两种整数表示方式都进行变异。 此外，AFL还会智能地跳过某些arithmetic变异。第一种情况就是前面提到的effector map：如果一个整数的所有bytes都被判断为“无效”，那么就跳过对整数的变异。第二种情况是之前bitflip已经生成过的变异：如果加/减某个数后，其效果与之前的某种bitflip相同，那么这次变异肯定在上一个阶段已经执行过了，此次便不会再执行。 ###（3） interest 下一个阶段是interest，具体可分为： interest 8/8，每次对8个bit进替换，按照每8个bit的步长从头开始，即对文件的每个byte进行替换 interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换 interest 32/8，每次对32个bit进替换，按照每8个bit的步长从头开始，即对文件的每个dword进行替换 而用于替换的”interesting values”，是AFL预设的一些比较特殊的数： static s8 interesting_8[] = { INTERESTING_8 }; static s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 }; static s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 }; 这些数的定义在config.h文件中： /* List of interesting values to use in fuzzing. */ #define INTERESTING_8 \\ -128, /* Overflow signed 8-bit when decremented */\\ -1, /* */\\ 0, /* */\\ 1, /* */\\ 16, /* One-off with common buffer size */\\ 32, /* One-off with common buffer size */\\ 64, /* One-off w","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:3:0","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"效果分析 参考 https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html 中的测试方法，同样以 djpeg 为目标，最初的样本集只有一个文本 test，采用二进制插桩的方式进行fuzz，1个主节点以及3个从节点同时进行，测试最终是否能fuzz出一个合法的图片文件。 fuzz后的样本集合如下： 使用 afl-showmap 对所有样本进行分析，编写脚本如下： #!/bin/bash path=$1 dpath=$2 rm -rf $2/* for file in $(ls $1) do echo -e '\\n'$file afl-showmap -o $2/$file -Q -- /usr/bin/djpeg $1/$file echo -e '-------------------------------------\\n' done 第一个参数为样本集合目录，第二个参数为输出目录，假设脚本名为 djpeg.sh ，样本目录为 in ，输出目录为 map ./djpeg.sh in map 脚本的执行结果可在 分析/djpeg_sh脚本输出结果.txt 中查看，以下只展示部分： id:000000,orig:1 afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Not a JPEG file: starts with 0x74 0x65 -- Program output ends -- [+] Captured 50 tuples in 'map/id:000000,orig:1'. ------------------------------------- id:000001,src:000000,op:havoc,rep:64,+cov afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Corrupt JPEG data: 2 extraneous bytes before marker 0xfe JPEG datastream contains no image -- Program output ends -- [+] Captured 68 tuples in 'map/id:000001,src:000000,op:havoc,rep:64,+cov'. ------------------------------------- id:000005,src:000000+000001,op:splice,rep:64 afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Corrupt JPEG data: 6 extraneous bytes before marker 0xfe JPEG datastream contains no image -- Program output ends -- [+] Captured 68 tuples in 'map/id:000005,src:000000+000001,op:splice,rep:64'. ------------------------------------- id:000021,src:000011,op:flip32,pos:2,+cov afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Premature end of JPEG file JPEG datastream contains no image -- Program output ends -- [+] Captured 59 tuples in 'map/id:000021,src:000011,op:flip32,pos:2,+cov'. ------------------------------------- id:000026,src:000021,op:havoc,rep:2 afl-showmap 2.56b by \u003clcamtuf@google.com\u003e [*] Executing '/usr/bin/djpeg'... -- Program output begins -- Premature end of JPEG file JPEG datastream contains no image -- Program output ends -- [+] Captured 60 tuples in 'map/id:000026,src:000021,op:havoc,rep:2'. ------------------------------------- 可以看到上面样本id为21和26的输出结果相同，但是执行路径不同，可以使用 diff 指令进行路径对比： diff -Nu map/id\\:000021\\,src\\:000011\\,op\\:flip32\\,pos\\:2\\,+cov map/id\\:000026\\,src\\:000021\\,op\\:havoc\\,rep\\:2 结果如下： --- map/id:000021,src:000011,op:flip32,pos:2,+cov 2019-12-03 06:38:42.236000000 +0000 +++ map/id:000026,src:000021,op:havoc,rep:2 2019-12-03 06:38:42.388000000 +0000 @@ -1,20 +1,21 @@ 003224:1 004793:1 005209:1 -005993:1 +005993:2 006601:1 007073:1 008498:1 008874:1 -010130:1 +010130:2 010146:1 010282:1 -013459:1 +013459:2 +014971:1 017564:1 018892:1 019132:1 019148:1 -019172:1 +019172:2 019188:1 019236:1 019804:1 @@ -33,18 +34,18 @@ 032872:1 033112:1 037297:1 -037433:1 +037433:2 037817:1 039585:1 -039641:2 -043450:1 +039641:4 +043450:2 043562:1 044194:1 044818:1 045483:1 046955:1 047603:1 -048251:1 +048251:2 051300:1 052444:1 053124:1 从最初的只有文本内容“test”的样本，afl确实已经发现了很多其它路径，但是在我的测试结果中还是没有fuzz出正常的图片文件，从输出结果上看样本id为21和26算是比较接近，没有报明显错误。 Premature end of JPEG file JPEG datastream contains no image ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:3:1","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Fuzz"],"content":"参考链接 https://github.com/google/AFL https://www.secpulse.com/archives/71903.html https://www.freebuf.com/articles/system/191536.html http://zeroyu.xyz/2019/05/15/how-to-use-afl-fuzz https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html https://paper.seebug.org/841/ https://paper.seebug.org/496/#part-2afl https://rk700.github.io/2017/12/28/afl-internals/ https://rk700.github.io/2018/01/04/afl-mutations/ https://rk700.github.io/2018/02/02/afl-enhancement/ ","date":"2020-12-04","objectID":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/:3:2","tags":["Fuzz","AFL"],"title":"AFL二三事 -- 2","uri":"/2020/12/afl%E4%BA%8C%E4%B8%89%E4%BA%8B3/"},{"categories":["Tech"],"content":"Windows内核函数前缀可以表明函数作用，特此总结学习。","date":"2020-02-07","objectID":"/WindowsDev/WindowsKernel/","tags":["Security","Widnows内核函数"],"title":"Windows内核函数前缀简述","uri":"/WindowsDev/WindowsKernel/"},{"categories":["Tech"],"content":"Windows内核函数前缀简述 Windows内核函数是Windows内核开发中必须要熟悉的函数，其每个函数命名一般都可以直接反映出其用途和作用对象，且函数名都按其所在的层次或模块加上了特定的前缀。了解了这些前缀，在看到函数名时就大致可以知道函数所属的层次和模块。特此对Windows内核函数的前缀做一个汇总，方便查找和学习Windows内核函数。 主要的Windows内核函数前缀罗列如下： Ex：Executive，提供堆管理和同步服务。 Nt：Native，对应于win32 API的内核函数。 Ke：内核层，所有多线程和多处理器的低等级同步活动都发生在内核中。 Zw：Win32子系统存在于用户模式中，所以用户模式中的应用程序可以容易地调用其例程。为了方便，Windows NT在内核模式中实现了一些有Zw前缀名的函数，这些函数可以使驱动程序调用Win32子系统例程。 Hal：硬件抽象层，Hal是Hardware Abstraction Layer的缩写。 Ob：对象管理器，集中控制Windows NT中的各种数据对象，WDM驱动程序仅需要对象管理器维护对象的参考计数，以防止对象被意外删除。 Mm：内存管理器，控制页表，页表定义了虚拟内存到物理内存之间的映射。 Ps：进程结构模块，创建并管理内核模式线程，普通的WDM驱动程序应使用一个独立的线程来循检无中断生成能力的设备。（Ps - Process） Se：安全参考监视器，使文件系统驱动程序执行安全检测。I/O请求到达WDM驱动程序前已经做完了安全检测。  Io：I/O管理，包含许多驱动程序可以使用的服务函数。 Fs：文件系统，Fs是File System的缩写。 Cc：文件缓存管理，Cc表示Cache。 Cm：系统配置管理，Cm是Configuration Manager的缩写。 Pp：“即插即用”管理，Pp表示PnP。（Plug and Play） Rtl：运行时程序库，Rtl是Runtime Library的缩写，包含工具例程，例如列表和串管理例程，内核模式驱动程序可以用这些例程来替代常规的ANSI标准例程，大部分例程可以从其名字上直接看出它的功能。 ","date":"2020-02-07","objectID":"/WindowsDev/WindowsKernel/:0:0","tags":["Security","Widnows内核函数"],"title":"Windows内核函数前缀简述","uri":"/WindowsDev/WindowsKernel/"},{"categories":null,"content":"Hugo 主题 LoveIt \" ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 V4ler1an","uri":"/about/"},{"categories":null,"content":"Working on ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于 V4ler1an","uri":"/about/"},{"categories":null,"content":"我是谁  漏洞练习生：长期处于漏洞领域的学习和练习中，什么时候出道全看天。  音乐忠实爱好者：属于没有音乐活不了的那种。  看雪二进制漏洞版块小版主：何其有幸能为教会我许多的看雪论坛贡献自己的一份力量。  羽毛球国家1亿级运动员：长期稳定占据该等级王者位置。  MOBA游戏辅助迷：爱打辅助不是因为我菜，只是不想打击祖国电竞未来的希望。  小区最强CTFer：常年霸占小区CTF竞赛排行榜第一名，从未下来过。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于 V4ler1an","uri":"/about/"},{"categories":null,"content":"And / 后续：博客后续应该会持续更新，频率不定 / 佛系：人生在世，淡然一点，所以什么都看得开 ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于 V4ler1an","uri":"/about/"},{"categories":null,"content":"哪里找我  WeChat订阅号：技术文章更新速度没有Blog快，但是我家仙女会更新她的内容。 有毒的猫Alt text \" 有毒的猫  看雪主页:  Twitter: 基本什么都没有-。- ","date":"2019-08-02","objectID":"/about/:4:0","tags":null,"title":"关于 V4ler1an","uri":"/about/"},{"categories":null,"content":"最后就奉上我最喜欢的歌词 I’ve been reading books of old The legends and the myths Achilles and his gold Hercules and his gifts Spider-Man’s control And Batman with his fists And clearly I don’t see myself upon that list But she said, where’d you wanna go? How much you wanna risk? I’m not lookin' for somebody With some superhuman gifts Some superhero Some fairy-tale bliss Just something I can turn to Somebody I can kiss I want something just like this ","date":"2019-08-02","objectID":"/about/:5:0","tags":null,"title":"关于 V4ler1an","uri":"/about/"}]