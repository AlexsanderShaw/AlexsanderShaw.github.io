# Linux-0.11-02


# Linux-0.11-02


本文是Linux 0.11系列学习记录的正式的第二篇。

<!--more-->

## 03 做好最最基础的准备工作

书接上回，上回书咱们说到，操作系统的代码最开头的 512 字节的数据，从硬盘的启动区先是被移动到了内存 **0x7c00** 处，然后又立刻被移动到 **0x90000** 处，并且跳转到此处往后再稍稍偏移 **go** 这个标签所代表的偏移地址处。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049159)

那我们接下来，就继续把我们的目光放在 go 这个标签的位置，跟着 CPU 的步伐往后看。

```assembly
go: mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov sp,#0xFF00
```

全都是 mov 操作，那好办了。

这段代码的直接意思很容易理解，就是把 **cs** 寄存器的值分别复制给 **ds**、**es** 和 **ss** 寄存器，然后又把 0xFF00 给了 **sp** 寄存器。

回顾下 CPU 寄存器图。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049254)

cs 寄存器表示**代码段寄存器**，CPU 当前正在执行的代码在内存中的位置，就是由 cs:ip 这组寄存器配合指向的，其中 cs 是基址，ip 是偏移地址。

由于之前执行过一个段间跳转指令，还记得不？

```
jmpi go,0x9000
```

所以现在 cs 寄存器里的值就是 **0x9000**，ip 寄存器里的值是 **go** 这个标签的偏移地址。那这三个 mov 指令就分别给 ds、es 和 ss 寄存器赋值为了 0x9000。

ds 为数据段寄存器，之前我们说过了，当时它被复制为 **0x07c0**，是因为之前的代码在 0x7c00 处，现在代码已经被挪到了 0x90000 处，所以现在自然又改赋值为 **0x9000** 了。

es 是扩展段寄存器，仅仅是个扩展，不是主角，先不用理它。

ss 为**栈段寄存器**，后面要配合栈基址寄存器 sp 来表示此时的栈顶地址。而此时 sp 寄存器被赋值为了 **0xFF00** 了，所以目前的栈顶地址就是 **ss:sp** 所指向的地址 **0x9FF00** 处。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049741)

其实到这里，操作系统的一些最最最最基础的准备工作，就做好了。都做了些啥事呢？

**第一**，代码从硬盘移到内存，又从内存挪了个地方，放在了 **0x90000** 处。
**第二**，**数据段寄存器 ds** 和**代码段寄存器 cs** 此时都被设置为了 0x9000，也就为跳转代码和访问内存数据，奠定了同一个内存的基址地址，方便了跳转和内存访问，因为仅仅需要指定偏移地址即可了。
**第三**，栈顶地址被设置为了 0x9FF00，具体表现为**栈段寄存器 ss** 为 0x9000，**栈基址寄存器 sp** 为 0xFF00。栈是向下发展的，这个栈顶地址 0x9FF00 要远远大于此时代码所在的位置 0x90000，所以栈向下发展就很难撞见代码所在的位置，也就比较安全。这也是为什么给栈顶地址设置为这个值的原因，其实只需要离代码的位置远远的即可。

做好这些基础工作后，接下来就又该折腾了其他事了。

总结拔高一下，这一部分其实就是把**代码段寄存器 cs**，**数据段寄存器 ds**，**栈段寄存器 ss** 和**栈基址寄存器 sp** 分别设置好了值，方便后续使用。

再拔高一下，其实操作系统在做的事情，就是给如何访问代码，如何访问数据，如何访问栈进行了一下**内存的初步规划**。其中访问代码和访问数据的规划方式就是设置了一个**基址**而已，访问栈就是把**栈顶指针**指向了一个远离代码位置的地方而已。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049545)

所以，千万别多想，就这么点事儿。那再给大家留个作业，把当前的内存布局画出来，告诉我现在 **cs、ip、ds、ss、sp** 这些寄存器的值，在内存布局中的位置。

好了，接下来我们应该干什么呢？我们回忆下，我们目前仅仅把硬盘中 512 字节加载到内存中了，但操作系统还有很多代码仍然在硬盘里，不能抛下他们不管呀。

所以你猜下一步要干嘛了？

后面的世界越来越精彩，欲知后事如何，且听下回分解。

**------- 本回扩展与延伸 -------**

有关段寄存器的详细信息，可以参考 Intel 手册：

Volume 1 Chapter 3.4.2 Segment Registers

其中有一张图清晰地描述了三种段寄存器的作用。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049077)

正如我们本回所涉及到的讲述一样，**CS 是代码段寄存器**，就是执行代码的时候带着这里存的基地址。**DS 是数据段寄存器**，就是访问数据的时候带着这里的基地址。**SS 是栈段寄存器**，就是访问栈时带着这里的基地址。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049857)

所以本回的代码，正如标题所说，就是做好最最基础的准备工作。但要从更伟大的战略意义上讲，它其实是按照 Intel 手册上要求的，老老实实把这三类段寄存器的值设置好，达到了**初步规划内存**的目的。

## 04 把自己在硬盘里的其他部分也放到内存来

做好这些基础工作后，接下来就又该新的一翻折腾了，我们接着往下看。

```assembly
load_setup:
    mov dx,#0x0000      ; drive 0, head 0
    mov cx,#0x0002      ; sector 2, track 0
    mov bx,#0x0200      ; address = 512, in 0x9000
    mov ax,#0x0200+4    ; service 2, nr of sectors
    int 0x13            ; read it
    jnc ok_load_setup       ; ok - continue
    mov dx,#0x0000
    mov ax,#0x0000      ; reset the diskette
    int 0x13
    jmp load_setup

ok_load_setup:
    ...
```

这里有两个 **int 指令**我们还没见过。

注意这个 int 是汇编指令，可不是高级语言的整型变量哟。int 0x13 表示**发起 0x13 号中断**，这条指令上面给 dx、cx、bx、ax 赋值都是作为这个中断程序的参数。

中断是啥如果你不理解，先不要管，如果你就是放不下，那可以看一眼我之前的文章：[认认真真的聊聊中断](http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247498208&idx=1&sn=b784f8b4e627ebd1bfb9810d194fdb80&chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&scene=21#wechat_redirect)，里面讲得非常细致。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049780)

总之这个中断发起后，CPU 会通过这个**中断号**，去寻找对应的**中断处理程序的入口地址**，并**跳转**过去执行，逻辑上就相当于**执行了一个函数**。而 0x13 号中断的处理程序是 BIOS 提前给我们写好的，是**读取磁盘**的相关功能的函数。

之后真正进入操作系统内核后，中断处理程序是需要我们自己去重新写的，这个在后面的章节中，你会不断看到各个模块注册自己相关的中断处理程序，所以不要急。此时为了方便就先用 BIOS 提前给我们写好的程序了。

可见即便是操作系统的源码，有时也需要去调用现成的函数方便自己，并不是造轮子的人就非得完全从头造。

本段代码的注释已经写的很明确了，直接说最终的作用吧，**就是将硬盘的第 2 个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区**，图示其实就是这样。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049038)

为了图片清晰表达意思，可能比例就不那么严谨了，大家不必纠结。

可以看到，如果复制成功，就跳转到 **ok_load_setup** 这个标签，如果失败，则会不断重复执行这段代码，也就是重试。那我们就别管重试逻辑了，直接看成功后跳转的 ok_load_setup 这个标签后的代码。

```
ok_load_setup:
    ...
    mov ax,#0x1000
    mov es,ax       ; segment of 0x10000
    call read_it
    ...
    jmpi 0,0x9020
```

这段代码省略了很多非主逻辑的代码，比如在屏幕上输出 Loading system ... 这个字符串以防止用户等烦了。

剩下的主要代码就都写在这里了，就这么几行，其作用是**把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处**，和之前的从硬盘捣腾到内存是一个道理。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049528)

至此，整个操作系统的**全部代码**，就已经全部从硬盘中，被搬迁到内存来了。

然后又通过一个熟悉的段间跳转指令 jmpi 0,0x9020，跳转到 **0x90200** 处，就是硬盘第二个扇区开始处的内容。

那这里的内容是什么呢？先不急，我们借这个机会把整个操作系统的编译过程说下。整个编译过程，就是通过 **Makefile** 和 **build.c** 配合完成的，最终会：

***1.*** 把 bootsect.s 编译成 bootsect 放在硬盘的 1 扇区。

***2.*** 把 setup.s 编译成 setup 放在硬盘的 2~5 扇区。

***3.*** 把剩下的全部代码（head.s 作为开头）编译成 system 放在硬盘的随后 240 个扇区。

所以整个路径就是这样的。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131049397)

所以，我们即将跳转到的内存中的 **0x90200** 处的代码，就是从硬盘第二个扇区开始处加载到内存的。第二个扇区的最开始处，那也就是 setup.s 文件的第一行代码咯。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131050902)

那这个代码是什么呢？我们后面再说，不过先打开 setup.s 这个文件看看吧。

```
start:
    mov ax,#0x9000  ; this is done in bootsect already, but...
    mov ds,ax
    mov ah,#0x03    ; read cursor pos
    xor bh,bh
    int 0x10        ; save it in known place, con_init fetches
    mov [0],dx      ; it from 0x90000.
    ...
```

好了，到目前为止，你是不是觉得，我去，这前面编译放在硬盘的位置，和后面代码写死的跳转地址，竟然如此地强耦合？那万一整错了咋办。

是啊，就是这样，你以为呢？**在操作系统刚刚开始建立的时候，那是完全自己安排前前后后的关系**，一个字节都不能偏，就是这么强耦合，需要小心翼翼，需要大脑时刻保持清醒，规划好自己写的代码被编译并存储在硬盘的哪个位置，而随后又会被加载到内存的哪个位置，不能错乱。

但这也是很有好处的，那就是在这个阶段，你完完全全知道每一步跳转，每一步数据访问都是怎么设计和规划的，不存在黑盒。

不像我们在写高级语言的时候，完全不知道是怎么底层帮我们做了多少工作。虽然这解脱了程序员关心底层细节的烦恼，但在遇到问题或者想知道原理的时候，就显得很讨厌了。所以珍惜这个阶段吧！

而且，你在上层之所以能那么随心所欲，很多底层细节完全不用考虑，很省心，正是因为像今天这样以及之后每一章的各种底层代码小心翼翼的做了很多铺垫。

好了，本文的内容就结束了。这也标志着我们走完了**第一个操作系统源码**文件 **bootsect.s**，开始向下一个文件 **setup.s** 进发了！

后面的世界越来越精彩，欲知后事如何，且听下回分解。

## 05 进入保护模式钱的最后一次折腾内存

书接上回，上回书咱们说到，操作系统已经完成了各种从硬盘到内存的加载，以及内存到内存的复制。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131050622)

至此，整个 **bootsect.s** 的使命就完成了，也是我们品读完的第一个操作系统源码文件。之后便跳转到了 **0x90200** 这个位置开始执行，这个位置处的代码就是位于 **setup.s** 的开头，我们接着来看。

```
start:
    mov ax,#0x9000  ; this is done in bootsect already, but...
    mov ds,ax
    mov ah,#0x03    ; read cursor pos
    xor bh,bh
    int 0x10        ; save it in known place, con_init fetches
    mov [0],dx      ; it from 0x90000.
```

又有个 **int** 指令。

前面的文章好好看过的话，一下就能猜出它要干嘛。还记不记得之前有个 **int 0x13** 表示触发 BIOS 提供的**读磁盘**中断程序？这个 **int 0x10** 也是一样的，它也是触发 BIOS 提供的**显示服务**中断处理程序，而 **ah** 寄存器被赋值为 **0x03** 表示显示服务里具体的**读取光标位置功能**。

具体 BIOS 提供了哪些中断服务，如何去调用和获取返回值，请大家自行寻找资料，这里只说结果。

这个 int 0x10 中断程序执行完毕并返回时，**dx** 寄存器里的值表示**光标的位置**，具体说来其高八位 dh 存储了**行号**，低八位 dl 存储了列号。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131050708)

这里说明一下：计算机在加电自检后会自动初始化到文字模式，在这种模式下，一屏幕可以显示 25 行，每行 80 个字符，也就是 80 列。 

那下一步 **mov [0],dx** 就是把这个光标位置存储在 [0] 这个内存地址处。注意，前面我们说过，这个内存地址仅仅是偏移地址，还需要加上 ds 这个寄存器里存储的段基址，最终的内存地址是在 **0x90000** 处，这里存放着光标的位置，以便之后在初始化控制台的时候用到。

所以从这里也可以看出，这和我们平时调用一个方法没什么区别，只不过这里的**寄存器**的用法相当于**入参和返回值**，这里的 **0x10 中断号**相当于**方法名**。

这里又应了之前说的一句话，操作系统内核的最开始也处处都是 BIOS 的调包侠，有现成的就用呗。

再接下来的几行代码，都是和刚刚一样的逻辑，调用一个 BIOS 中断获取点什么信息，然后存储在内存中某个位置，我们迅速浏览一下就好咯。

```
比如获取内存信息。
; Get memory size (extended mem, kB)
    mov ah,#0x88
    int 0x15
    mov [2],ax
获取显卡显示模式。
; Get video-card data:
    mov ah,#0x0f
    int 0x10
    mov [4],bx      ; bh = display page
    mov [6],ax      ; al = video mode, ah = window width
检查显示方式并取参数
; check for EGA/VGA and some config parameters
    mov ah,#0x12
    mov bl,#0x10
    int 0x10
    mov [8],ax
    mov [10],bx
    mov [12],cx
获取第一块硬盘的信息。
; Get hd0 data
    mov ax,#0x0000
    mov ds,ax
    lds si,[4*0x41]
    mov ax,#INITSEG
    mov es,ax
    mov di,#0x0080
    mov cx,#0x10
    rep
    movsb
获取第二块硬盘的信息。
; Get hd1 data
    mov ax,#0x0000
    mov ds,ax
    lds si,[4*0x46]
    mov ax,#INITSEG
    mov es,ax
    mov di,#0x0090
    mov cx,#0x10
    rep
    movsb
```

以上原理都是一样的。

我们就没必要细琢磨了，对操作系统的理解作用不大，只需要知道最终存储在内存中的信息是什么，在什么位置，就好了，之后会用到他们的。

| 内存地址 | 长度(字节) | 名称         |
| -------- | ---------- | ------------ |
| 0x90000  | 2          | 光标位置     |
| 0x90002  | 2          | 扩展内存数   |
| 0x90004  | 2          | 显示页面     |
| 0x90006  | 1          | 显示模式     |
| 0x90007  | 1          | 字符列数     |
| 0x90008  | 2          | 未知         |
| 0x9000A  | 1          | 显示内存     |
| 0x9000B  | 1          | 显示状态     |
| 0x9000C  | 2          | 显卡特性参数 |
| 0x9000E  | 1          | 屏幕行数     |
| 0x9000F  | 1          | 屏幕列数     |
| 0x90080  | 16         | 硬盘1参数表  |
| 0x90090  | 16         | 硬盘2参数表  |
| 0x901FC  | 2          | 根设备号     |


由于之后很快就会用 c 语言进行编程，虽然汇编和 c 语言也可以用变量的形式进行传递数据，但这需要编译器在链接时做一些额外的工作，所以这么多数据更方便的还是**双方共同约定一个内存地址**，我往这里存，你从这里取，就完事了。这恐怕是最最原始和直观的变量传递的方式了。 

把这些信息存储好之后，操作系统又要做什么呢？我们继续往下看。

```
cli         ; no interrupts allowed ;
```

就一行 cli，表示**关闭中断**的意思。

因为后面我们要把原本是 BIOS 写好的中断向量表给覆盖掉，也就是给破坏掉了，写上我们自己的中断向量表，所以这个时候是不允许中断进来的。

继续看。

```
; first we move the system to it's rightful place
    mov ax,#0x0000
    cld         ; 'direction'=0, movs moves forward
do_move:
    mov es,ax       ; destination segment
    add ax,#0x1000
    cmp ax,#0x9000
    jz  end_move
    mov ds,ax       ; source segment
    sub di,di
    sub si,si
    mov cx,#0x8000
    rep movsw
    jmp do_move
; then we load the segment descriptors
end_move:
    ...
```

看到后面那个 **rep movsw** 熟不熟悉，一开始我们把操作系统代码从 **0x7c00** 移动到 **0x90000** 的时候就是用的这个指令，来图回忆一下。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131050135)

同前面的原理一样，也是做了个内存复制操作，最终的结果是，把内存地址 **0x10000** 处开始往后一直到 **0x90000** 的内容，统统复制到内存的最开始的 **0** 位置，大概就是这么个效果。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131050898)

由于之前的各种加载和复制，导致内存看起来很乱，是时候进行一波取舍和整理了，我们重新梳理一下此时的内存布局。

栈顶地址仍然是 **0x9FF00** 没有改变。

**0x90000** 开始往上的位置，原来是 **bootsect** 和 **setup** 程序的代码，现 bootsect 的一部分代码在已经被操作系统为了记录内存、硬盘、显卡等一些**临时存放的**数据给覆盖了一部分。

内存最开始的 **0** 到 **0x80000** 这 512K 被 **system** 模块给占用了，之前讲过，这个 system 模块就是除了 bootsect 和 setup 之外的全部程序链接在一起的结果，可以理解为**操作系统的全部**。

那么现在的内存布局就是这个样子。

![图片](https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/202112131050719.png)

好了，记住上面的图就好了，这回是不是又重新清晰起来了？之前的什么 0x7c00，已经是过去式了，**赶紧忘掉它**，向前看！

接下来，就要进行有点技术含量的工作了，那就是**模式的转换**，需要从现在的 16 位的**实模式**转变为之后 32 位的**保护模式**，这是一项大工程！也是我认为的这趟操作系统源码旅程中，第一个颇为精彩的地方，大家做好准备！

后面的世界越来越精彩，欲知后事如何，且听下回分解。

## 原文地址

[你管这破玩意叫操作系统源码 | 第三回 做好最最基础的准备工作](https://mp.weixin.qq.com/s/90QBJ-lP_-du2qQJxNF-Fw)

[你管这破玩意叫操作系统源码 | 第四回 把自己在硬盘里的其他部分也放到内存来](https://mp.weixin.qq.com/s/hStc-y-sabP-KwJUDUesTw)

[你管这破玩意叫操作系统源码 | 第五回 进入保护模式前的最后一次折腾内存](https://mp.weixin.qq.com/s/5s_nmrWRZbA_4mkNKOQ2Cg)

