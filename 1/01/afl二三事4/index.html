<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title> - V4ler1an-有毒</title><meta name="Description" content="Live a life you like."><meta property="og:title" content="" />
<meta property="og:description" content="AFL二三事 &ndash; 4 本文是AFL系列第四篇，主要介绍AFL的源码分析。 AFL二三事——源码分析 前言 AFL，全称“American Fuzzy Lop”，是由" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.v4ler1an.com/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" /><meta property="og:image" content="https://www.v4ler1an.com/images/personal_logo.png"/><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://www.v4ler1an.com/images/personal_logo.png"/>

<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="AFL二三事 &ndash; 4 本文是AFL系列第四篇，主要介绍AFL的源码分析。 AFL二三事——源码分析 前言 AFL，全称“American Fuzzy Lop”，是由"/>
<meta name="application-name" content="V4ler1an">
<meta name="apple-mobile-web-app-title" content="V4ler1an"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://www.v4ler1an.com/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" /><link rel="prev" href="https://www.v4ler1an.com/1/01/fuzzing101-6/" /><link rel="next" href="https://www.v4ler1an.com/1/01/roarctf/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/www.v4ler1an.com\/1\/01\/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4\/"
        },"image": ["https:\/\/www.v4ler1an.com\/images\/personal_logo.png"],"genre": "posts","wordcount":  28953 ,
        "url": "https:\/\/www.v4ler1an.com\/1\/01\/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4\/","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/www.v4ler1an.com\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "v4ler1an-有毒"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="V4ler1an-有毒"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/personal_logo.png"
        data-srcset="/images/personal_logo.png, /images/personal_logo.png 1.5x, /images/personal_logo.png 2x"
        data-sizes="auto"
        alt="/images/personal_logo.png"
        title="/images/personal_logo.png" />V4ler1an-有毒</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 我 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item language" title="选择语言">简体中文<i class="fas fa-chevron-right fa-fw"></i>
                        <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" selected>简体中文</option></select>
                    </a><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="V4ler1an-有毒"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/personal_logo.png"
        data-srcset="/images/personal_logo.png, /images/personal_logo.png 1.5x, /images/personal_logo.png 2x"
        data-sizes="auto"
        alt="/images/personal_logo.png"
        title="/images/personal_logo.png" />V4ler1an-有毒</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">我</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">简体中文<i class="fas fa-chevron-right fa-fw"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" selected>简体中文</option></select>
                </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX"></h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://www.v4ler1an.com" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>v4ler1an-有毒</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="0001-01-01">0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 28953 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 58 分钟&nbsp;<span id="/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" class="leancloud_visitors" data-flag-title="">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#宏观">宏观</a></li>
    <li><a href="#一afl的插桩普通插桩">一、AFL的插桩——普通插桩</a>
      <ul>
        <li><a href="#一-afl-的-gcc--afl-gccc">（一） 、AFL 的 gcc —— afl-gcc.c</a>
          <ul>
            <li><a href="#1-概述">1. 概述</a></li>
            <li><a href="#2-源码">2. 源码</a>
              <ul>
                <li><a href="#1-关键变量">1. 关键变量</a></li>
                <li><a href="#2-main函数">2. main函数</a></li>
                <li><a href="#3-find_as-函数">3. find_as 函数</a></li>
                <li><a href="#4-edit_params-函数">4. edit_params 函数</a></li>
              </ul>
            </li>
            <li><a href="#1-概述-1">1. 概述</a></li>
            <li><a href="#2-源码-1">2. 源码</a>
              <ul>
                <li><a href="#1-关键变量-1">1. 关键变量</a></li>
                <li><a href="#2-main函数-1">2. main函数</a></li>
                <li><a href="#3-add_instrumentation函数">3. add_instrumentation函数</a></li>
                <li><a href="#4-edit_params函数">4. edit_params函数</a></li>
              </ul>
            </li>
            <li><a href="#3-instrumentation-trampoline-和-main_payload">3. instrumentation trampoline 和 main_payload</a>
              <ul>
                <li><a href="#1-trampoline_fmt_6432">1. trampoline_fmt_64/32</a></li>
                <li><a href="#2-__afl_maybe_log">2. __afl_maybe_log</a></li>
                <li><a href="#3-__afl_setup">3. __afl_setup</a></li>
                <li><a href="#4-__afl_setup_first">4. __afl_setup_first</a></li>
                <li><a href="#5-__afl_forkserver">5. __afl_forkserver</a></li>
                <li><a href="#6-__afl_fork_wait_loop">6. __afl_fork_wait_loop</a></li>
                <li><a href="#7-__afl_fork_resume">7. __afl_fork_resume</a></li>
                <li><a href="#8-__afl_store">8. __afl_store</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#二afl-的插桩--llvm_mode">二、AFL 的插桩 —— llvm_mode</a>
      <ul>
        <li><a href="#一llvm-前置知识">（一）、LLVM 前置知识</a></li>
        <li><a href="#二-afl的afl-clang-fast">（二）、 AFL的afl-clang-fast</a>
          <ul>
            <li><a href="#1-概述-2">1. 概述</a></li>
            <li><a href="#2-源码-2">2. 源码</a>
              <ul>
                <li><a href="#1-afl-clang-fastc">1. afl-clang-fast.c</a>
                  <ul>
                    <li><a href="#1-main-函数">1. main 函数</a></li>
                    <li><a href="#2-find_obj-函数">2. find_obj 函数</a></li>
                    <li><a href="#3-edit_params-函数">3. edit_params 函数</a></li>
                  </ul>
                </li>
                <li><a href="#2-afl-llvm-passsocc">2. afl-llvm-pass.so.cc</a>
                  <ul>
                    <li><a href="#1-pass注册">1. pass注册</a></li>
                    <li><a href="#2-runonmodule-函数">2. runOnModule 函数</a></li>
                  </ul>
                </li>
                <li><a href="#3-afl-llvm-rtoc">3. afl-llvm-rt.o.c</a>
                  <ul>
                    <li><a href="#1-deferred-instrumentation">1. deferred instrumentation</a></li>
                    <li><a href="#3-trace-pc-guard-mode">3. trace-pc-guard mode</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#三afl的fuzzer--afl-fuzzc">三、AFL的fuzzer —— afl-fuzz.c</a>
      <ul>
        <li><a href="#1-概述-3">1. 、概述</a></li>
        <li><a href="#2核心源码分析">2、核心源码分析</a>
          <ul>
            <li><a href="#1-初始配置">1. 初始配置</a>
              <ul>
                <li><a href="#11-第一个while循环">1.1 第一个while循环</a></li>
                <li><a href="#12-setup_signal_handlers-函数">1.2 setup_signal_handlers 函数</a></li>
                <li><a href="#13-check_asan_opts-函数">1.3 check_asan_opts 函数</a></li>
                <li><a href="#14-fix_up_sync-函数">1.4 fix_up_sync 函数</a></li>
                <li><a href="#15-save_cmdline-函数">1.5 save_cmdline 函数</a></li>
                <li><a href="#16--check_if_tty-函数">1.6  check_if_tty 函数</a></li>
                <li><a href="#17-几个cpu检查相关的函数">1.7 几个CPU检查相关的函数</a></li>
                <li><a href="#18-setup_shm-函数">1.8 <strong>setup_shm</strong> 函数</a></li>
                <li><a href="#19-setup_dirs_fds-函数">1.9 setup_dirs_fds 函数</a></li>
                <li><a href="#110-read_testcases-函数">1.10 read_testcases 函数</a></li>
                <li><a href="#111-add_to_queue-函数">1.11 add_to_queue 函数</a></li>
                <li><a href="#112-pivot_inputs-函数">1.12 pivot_inputs 函数</a></li>
                <li><a href="#1-13-find_timeout-函数">1. 13 find_timeout 函数</a></li>
                <li><a href="#114-detect_file_args">1.14 detect_file_args</a></li>
                <li><a href="#115-check_binary-函数">1.15 check_binary 函数</a></li>
              </ul>
            </li>
            <li><a href="#2-第一遍fuzz">2. 第一遍fuzz</a>
              <ul>
                <li><a href="#21-检查">2.1 检查</a></li>
                <li><a href="#22-perform_dry_run-函数">2.2 perform_dry_run 函数</a></li>
                <li><a href="#23-calibrate_case-函数">2.3 calibrate_case 函数</a></li>
                <li><a href="#24-init_forkserve-函数">2.4 init_forkserve 函数</a></li>
                <li><a href="#25-run_target-函数">2.5 run_target 函数</a></li>
                <li><a href="#26-update_bitmap_score-函数">2.6 update_bitmap_score 函数</a></li>
              </ul>
            </li>
            <li><a href="#3-主循环">3. 主循环</a>
              <ul>
                <li><a href="#31-主循环之前">3.1 主循环之前</a>
                  <ul>
                    <li><a href="#311-cull_queue-函数">3.1.1 cull_queue 函数</a></li>
                    <li><a href="#312-show_init_stats-函数">3.1.2 show_init_stats 函数</a></li>
                    <li><a href="#313-find_start_position-函数">3.1.3 find_start_position 函数</a></li>
                    <li><a href="#314-write_stats_file-函数">3.1.4 write_stats_file 函数</a></li>
                    <li><a href="#315-save_auto-函数">3.1.5 save_auto 函数</a></li>
                  </ul>
                </li>
                <li><a href="#32-主循环">3.2 主循环</a></li>
                <li><a href="#33-主循环后">3.3 主循环后</a>
                  <ul>
                    <li><a href="#331-fuzz_one-函数">3.3.1 fuzz_one 函数</a></li>
                    <li><a href="#332-sync_fuzzers-函数">3.3.2 sync_fuzzers 函数</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#四总结">四、总结</a></li>
    <li><a href="#五参考文献">五、参考文献</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="afl二三事----4">AFL二三事 &ndash; 4</h1>
<p>本文是AFL系列第四篇，主要介绍AFL的源码分析。</p>
<!--more-->
<h1 id="afl二三事源码分析">AFL二三事——源码分析</h1>
<h2 id="前言">前言</h2>
<p>AFL，全称“American Fuzzy Lop”，是由安全研究员Michal Zalewski开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率（代码执行路径的覆盖情况），以此进行反馈，对输入样本进行调整以提高覆盖率，从而提升发现漏洞的可能性。AFL可以针对有源码和无源码的程序进行模糊测试，其设计思想和实现方案在模糊测试领域具有十分重要的意义。</p>
<p>深入分析AFL源码，对理解AFL的设计理念和其中用到的技巧有着巨大的帮助，对于后期进行定制化Fuzzer开发也具有深刻的指导意义。所以，阅读AFL源码是学习AFL必不可少的一个关键步骤。</p>
<p>（注：需要强调的是，本文的主要目的是协助fuzz爱好者阅读AFL的源码，所以需要在了解AFL基本工作流程和原理的前提下进行阅读，本文并不会在原理侧做过多说明。）</p>
<p><strong>当别人都要快的时候，你要慢下来。</strong></p>
<h2 id="宏观">宏观</h2>
<p>首先在宏观上看一下AFL的源码结构：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210910151552.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210910151552.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210910151552.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210910151552.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210910151552.png"
        title="MetricsTreemap-AFL" /></p>
<p>主要的代码在 <code>afl-fuzz.c</code> 文件中，然后是几个独立模块的实现代码，<code>llvm_mode</code> 和 <code>qemu_mode</code> 的代码量大致相当，所以分析的重点应该还是在AFL的根目录下的几个核心功能的实现上，尤其是 <code>afl-fuzz.c</code>，属于核心中的重点。</p>
<p>各个模块的主要功能和作用的简要说明：</p>
<ul>
<li>
<p><strong>插桩模块</strong></p>
<ol>
<li><code>afl-as.h, afl-as.c, afl-gcc.c</code>：普通插桩模式，针对源码插桩，编译器可以使用gcc， clang；</li>
<li><code>llvm_mode</code>：llvm 插桩模式，针对源码插桩，编译器使用clang；</li>
<li><code>qemu_mode</code>：qemu 插桩模式，针对二进制文件插桩。</li>
</ol>
</li>
<li>
<p><strong>fuzzer 模块</strong></p>
<p><code>afl-fuzz.c</code>：fuzzer 实现的核心代码，AFL 的主体。</p>
</li>
<li>
<p><strong>其他辅助模块</strong></p>
<ol>
<li><code>afl-analyze</code>：对测试用例进行分析，通过分析给定的用例，确定是否可以发现用例中有意义的字段；</li>
<li><code>afl-plot</code>：生成测试任务的状态图；</li>
<li><code>afl-tmin</code>：对测试用例进行最小化；</li>
<li><code>afl-cmin</code>：对语料库进行精简操作；</li>
<li><code>afl-showmap</code>：对单个测试用例进行执行路径跟踪；</li>
<li><code>afl-whatsup</code>：各并行例程fuzzing结果统计；</li>
<li><code>afl-gotcpu</code>：查看当前CPU状态。</li>
</ol>
</li>
<li>
<p><strong>部分头文件说明</strong></p>
<ol>
<li><code>alloc-inl.h</code>：定义带检测功能的内存分配和释放操作；</li>
<li><code>config.h</code>：定义配置信息；</li>
<li><code>debug.h</code>：与提示信息相关的宏定义；</li>
<li><code>hash.h</code>：哈希函数的实现定义；</li>
<li><code>types.h</code>：部分类型及宏的定义。</li>
</ol>
</li>
</ul>
<h2 id="一afl的插桩普通插桩">一、AFL的插桩——普通插桩</h2>
<h3 id="一-afl-的-gcc--afl-gccc">（一） 、AFL 的 gcc —— afl-gcc.c</h3>
<h4 id="1-概述">1. 概述</h4>
<p><code>afl-gcc</code> 是GCC 或 clang 的一个wrapper（封装），常规的使用方法是在调用 <code>./configure</code> 时通过 <code>CC</code> 将路径传递给 <code>afl-gcc</code> 或 <code>afl-clang</code>。（对于 C++ 代码，则使用 <code>CXX</code> 并将其指向 <code>afl-g++</code> / <code>afl-clang++</code>。）<code>afl-clang</code>, <code>afl-clang++</code>， <code>afl-g++</code> 均为指向 <code>afl-gcc</code> 的一个符号链接。</p>
<p><code>afl-gcc</code> 的主要作用是实现对于关键节点的代码插桩，属于汇编级，从而记录程序执行路径之类的关键信息，对程序的运行情况进行反馈。</p>
<h4 id="2-源码">2. 源码</h4>
<h5 id="1-关键变量">1. 关键变量</h5>
<p>在开始函数代码分析前，首先要明确几个关键变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">u8</span><span class="o">*</span>  <span class="n">as_path</span><span class="p">;</span>                <span class="cm">/* Path to the AFL &#39;as&#39; wrapper，AFL的as的路径      */</span>
<span class="k">static</span> <span class="n">u8</span><span class="o">**</span> <span class="n">cc_params</span><span class="p">;</span>              <span class="cm">/* Parameters passed to the real CC，CC实际使用的编译器参数 */</span>
<span class="k">static</span> <span class="n">u32</span>  <span class="n">cc_par_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>         <span class="cm">/* Param count, including argv0 ，参数计数 */</span>
<span class="k">static</span> <span class="n">u8</span>   <span class="n">be_quiet</span><span class="p">,</span>               <span class="cm">/* Quiet mode，静默模式      */</span>
            <span class="n">clang_mode</span><span class="p">;</span>             <span class="cm">/* Invoked as afl-clang*? ，是否使用afl-clang*模式 */</span>

<span class="cp"># 数据类型说明
</span><span class="cp"># typedef uint8_t  u8;
</span><span class="cp"># typedef uint16_t u16;
</span><span class="cp"># typedef uint32_t u32;
</span></code></pre></td></tr></table>
</div>
</div><h5 id="2-main函数">2. main函数</h5>
<p>main 函数全部逻辑如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825105002.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825105002.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825105002.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825105002.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825105002.png"
        title="image-20210825105002088" /></p>
<p>其中主要有如下三个函数的调用：</p>
<ul>
<li><code>find_as(argv[0])</code> ：查找使用的汇编器</li>
<li><code>edit_params(argc, argv)</code>：处理传入的编译参数，将确定好的参数放入 <code>cc_params[]</code> 数组</li>
<li>调用 <code>execvp(cc_params[0], (cahr**)cc_params)</code> 执行 <code>afl-gcc</code></li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825115407.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825115407.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825115407.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825115407.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825115407.png"
        title="20210825115404" /></p>
<p>这里添加了部分代码打印出传入的参数 <code>arg[0] - arg[7]</code> ，其中一部分是我们指定的参数，另外一部分是自动添加的编译选项。</p>
<h5 id="3-find_as-函数">3. find_as 函数</h5>
<p>函数的核心作用：寻找 <code>afl-as</code></p>
<p>函数内部大概的流程如下（软件自动生成，控制流程图存在误差，但关键逻辑没有问题）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825145618.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825145618.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825145618.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825145618.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825145618.png"
        title="image-20210825145618543" /></p>
<ol>
<li>首先检查环境变量 <code>AFL_PATH</code> ，如果存在直接赋值给 <code>afl_path</code> ，然后检查 <code>afl_path/as</code> 文件是否可以访问，如果可以，<code>as_path = afl_path</code>。</li>
<li>如果不存在环境变量 <code>AFL_PATH</code> ，检查 <code>argv[0]</code> （如“/Users/v4ler1an/AFL/afl-gcc”）中是否存在 &ldquo;/&rdquo; ，如果存在则取最后“/” 前面的字符串作为 <code>dir</code>，然后检查 <code>dir/afl-as</code> 是否可以访问，如果可以，将 <code>as_path = dir</code> 。</li>
<li>以上两种方式都失败，抛出异常。</li>
</ol>
<h5 id="4-edit_params-函数">4. edit_params 函数</h5>
<p>核心作用：将 <code>argv</code> 拷贝到 <code>u8 **cc_params </code>，然后进行相应的处理。</p>
<p>函数内部的大概流程如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825150938.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825150938.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825150938.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825150938.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210825150938.png"
        title="image-20210825150938293" /></p>
<ol>
<li>
<p>调用 <code>ch_alloc()</code> 为 <code>cc_params</code> 分配大小为 <code>(argc + 128) * 8</code> 的内存（u8的类型为1byte无符号整数）</p>
</li>
<li>
<p>检查 <code>argv[0]</code> 中是否存在<code>/</code>，如果不存在则 <code>name = argv[0]</code>，如果存在则一直找到最后一个<code>/</code>，并将其后面的字符串赋值给 <code>name</code></p>
</li>
<li>
<p>对比 <code>name</code>和固定字符串<code>afl-clang</code>：</p>
<ol>
<li>
<p>若相同，设置<code>clang_mode = 1</code>，设置环境变量<code>CLANG_ENV_VAR</code>为1</p>
<ol>
<li>对比<code>name</code>和固定字符串<code>afl-clang++</code>:：
<ol>
<li>若相同，则获取环境变量<code>AFL_CXX</code>的值，如果存在，则将该值赋值给<code>cc_params[0]</code>，否则将<code>afl-clang++</code>赋值给<code>cc_params[0]</code>。这里的<code>cc_params</code>为保存编译参数的数组；</li>
<li>若不相同，则获取环境变量<code>AFL_CC</code>的值，如果存在，则将该值赋值给<code>cc_params[0]</code>，否则将<code>afl-clang</code>赋值给<code>cc_params[0]</code>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>如果不相同，并且是Apple平台，会进入 <code>#ifdef __APPLE__</code>。在Apple平台下，开始对 <code>name</code> 进行对比，并通过 <code>cc_params[0] = getenv(&quot;&quot;)</code> 对<code>cc_params[0]</code>进行赋值；如果是非Apple平台，对比 <code>name</code> 和 固定字符串<code>afl-g++</code>（此处忽略对Java环境的处理过程）：</p>
<ol>
<li>
<p>若相同，则获取环境变量<code>AFL_CXX</code>的值，如果存在，则将该值赋值给<code>cc_params[0]</code>，否则将<code>g++</code>赋值给<code>cc_params[0]</code>；</p>
</li>
<li>
<p>若不相同，则获取环境变量<code>AFL_CC</code>的值，如果存在，则将该值赋值给<code>cc_params[0]</code>，否则将<code>gcc</code>赋值给<code>cc_params[0]</code>。</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>进入 while 循环，遍历从<code>argv[1]</code>开始的<code>argv</code>参数：</p>
<ul>
<li>
<p>如果扫描到 <code>-B</code> ，<code>-B</code>选项用于设置编译器的搜索路径，直接跳过。（因为在这之前已经处理过<code>as_path</code>了）；</p>
</li>
<li>
<p>如果扫描到 <code>-integrated-as</code>，跳过；</p>
</li>
<li>
<p>如果扫描到 <code>-pipe</code>，跳过；</p>
</li>
<li>
<p>如果扫描到 <code>-fsanitize=address</code> 和 <code>-fsanitize=memory</code> 告诉 gcc 检查内存访问的错误，比如数组越界之类，设置 <code>asan_set = 1；</code></p>
</li>
<li>
<p>如果扫描到 <code>FORTIFY_SOURCE</code> ，设置 <code>fortify_set = 1</code> 。<code>FORTIFY_SOURCE</code> 主要进行缓冲区溢出问题的检查，检查的常见函数有<code>memcpy, mempcpy, memmove, memset, strcpy, stpcpy, strncpy, strcat, strncat, sprintf, vsprintf, snprintf, gets</code> 等；</p>
</li>
<li>
<p>对 <code>cc_params</code> 进行赋值：<code>cc_params[cc_par_cnt++] = cur;</code></p>
</li>
</ul>
</li>
<li>
<p>跳出 <code>while</code> 循环，设置其他参数：</p>
<ol>
<li>取出前面计算出的 <code>as_path</code> ，设置 <code>-B as_path</code> ；</li>
</ol>
</li>
<li>
<p>如果为 <code>clang_mode</code> ，则设置<code>-no-integrated-as</code>；
3. 如果存在环境变量 <code>AFL_HARDEN</code>，则设置<code>-fstack-protector-all</code>。且如果没有设置 <code>fortify_set</code> ，追加 <code>-D_FORTIFY_SOURCE=2</code> ；</p>
</li>
<li>
<p>sanitizer相关，通过多个if进行判断：</p>
<ul>
<li>
<p>如果 <code>asan_set</code> 在前面被设置为1，则设置环境变量 <code>AFL_USE_ASAN</code> 为1；</p>
<ul>
<li>如果 <code>asan_set</code> 不为1且，存在 <code>AFL_USE_ASAN</code> 环境变量，则设置<code> -U_FORTIFY_SOURCE -fsanitize=address</code>；</li>
</ul>
</li>
<li>
<p>如果不存在 <code>AFL_USE_ASAN</code> 环境变量，但存在 <code>AFL_USE_MSAN</code> 环境变量，则设置<code>-fsanitize=memory</code>（不能同时指定<code>AFL_USE_ASAN</code>或者<code>AFL_USE_MSAN</code>，也不能同时指定 <code>AFL_USE_MSAN</code> 和 <code>AFL_HARDEN</code>，因为这样运行时速度过慢；</p>
<ul>
<li>如果不存在 <code>AFL_DONT_OPTIMIZE</code> 环境变量，则设置<code>-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code>；</li>
<li>如果存在 <code>AFL_NO_BUILTIN</code> 环境变量，则表示允许进行优化，设置<code>-fno-builtin-strcmp -fno-builtin-strncmp -fno-builtin-strcasecmp -fno-builtin-strncasecmp -fno-builtin-memcmp -fno-builtin-strstr -fno-builtin-strcasestr</code>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>最后补充<code>cc_params[cc_par_cnt] = NULL;</code>，<code>cc_params</code> 参数数组编辑完成。</p>
</li>
</ol>
<p>###（二）、AFL的插桩 —— afl-as.c</p>
<h4 id="1-概述-1">1. 概述</h4>
<p><code>afl-gcc</code> 是 GNU as 的一个wrapper（封装），唯一目的是预处理由 GCC/clang 生成的汇编文件，并注入包含在 <code>afl-as.h</code> 中的插桩代码。 使用 <code>afl-gcc / afl-clang</code> 编译程序时，工具链会自动调用它。该wapper的目标并不是为了实现向 <code>.s</code> 或 <code>asm </code> 代码块中插入手写的代码。</p>
<p><code>experiment/clang_asm_normalize/</code> 中可以找到可能允许 clang 用户进行手动插入自定义代码的解决方案，GCC并不能实现该功能。</p>
<h4 id="2-源码-1">2. 源码</h4>
<h5 id="1-关键变量-1">1. 关键变量</h5>
<p>在开始函数代码分析前，首先要明确几个关键变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">u8</span><span class="o">**</span> <span class="n">as_params</span><span class="p">;</span>          <span class="cm">/* Parameters passed to the real &#39;as&#39;，传递给as的参数   */</span>

<span class="k">static</span> <span class="n">u8</span><span class="o">*</span>  <span class="n">input_file</span><span class="p">;</span>         <span class="cm">/* Originally specified input file ，输入文件     */</span>
<span class="k">static</span> <span class="n">u8</span><span class="o">*</span>  <span class="n">modified_file</span><span class="p">;</span>      <span class="cm">/* Instrumented file for the real &#39;as&#39;，as进行插桩处理的文件  */</span>

<span class="k">static</span> <span class="n">u8</span>   <span class="n">be_quiet</span><span class="p">,</span>           <span class="cm">/* Quiet mode (no stderr output) ，静默模式，没有标准输出       */</span>
            <span class="n">clang_mode</span><span class="p">,</span>         <span class="cm">/* Running in clang mode?    是否运行在clang模式           */</span>
            <span class="n">pass_thru</span><span class="p">,</span>          <span class="cm">/* Just pass data through?   只通过数据           */</span>
            <span class="n">just_version</span><span class="p">,</span>       <span class="cm">/* Just show version?        只显示版本   */</span>
            <span class="n">sanitizer</span><span class="p">;</span>          <span class="cm">/* Using ASAN / MSAN         是否使用ASAN/MSAN           */</span>

<span class="k">static</span> <span class="n">u32</span>  <span class="n">inst_ratio</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>   <span class="cm">/* Instrumentation probability (%)  插桩覆盖率    */</span>
            <span class="n">as_par_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Number of params to &#39;as&#39;    传递给as的参数数量初始值         */</span>
</code></pre></td></tr></table>
</div>
</div><p>注：如果在参数中没有指明 <code>--m32</code> 或 <code>--m64</code> ，则默认使用在编译时使用的选项。</p>
<h5 id="2-main函数-1">2. main函数</h5>
<p>main 函数全部逻辑如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826112710.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826112710.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826112710.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826112710.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826112710.png"
        title="image-20210826112703339" /></p>
<ol>
<li>首先获取环境变量 <code>AFL_INST_RATIO</code> ，赋值给 <code>inst_ratio_str</code>，该环境变量主要控制检测每个分支的概率，取值为0到100%，设置为0时则只检测函数入口的跳转，而不会检测函数分支的跳转；</li>
<li>通过 <code>gettimeofday(&amp;tv,&amp;tz);</code>获取时区和时间，然后设置 <code>srandom()</code> 的随机种子 <code>rand_seed = tv.tv_sec ^ tv.tv_usec ^ getpid();</code></li>
<li>调用 <code>edit_params(argc, argv)</code> 函数进行参数处理；</li>
<li>检测 <code>inst_ratio_str</code> 的值是否合法范围内，并设置环境变量 <code>AFL_LOOP_ENV_VAR</code>；</li>
<li>读取环境变量``AFL_USE_ASAN<code>和</code>AFL_USE_MSAN<code>的值，如果其中有一个为1，则设置</code>sanitizer<code>为1，且将</code>inst_ratio`除3。这是因为在进行ASAN的编译时，AFL无法识别出ASAN特定的分支，导致插入很多无意义的桩代码，所以直接暴力地将插桩概率/3；</li>
<li>调用 <code>add_instrumentation()</code> 函数，这是实际的插桩函数；</li>
<li>fork 一个子进程来执行 <code>execvp(as_params[0], (char**)as_params);</code>。这里采用的是 fork 一个子进程的方式来执行插桩。这其实是因为我们的 <code>execvp</code> 执行的时候，会用 <code>as_params[0]</code> 来完全替换掉当前进程空间中的程序，如果不通过子进程来执行实际的 <code>as</code>，那么后续就无法在执行完实际的as之后，还能unlink掉modified_file；</li>
<li>调用 <code>waitpid(pid, &amp;status, 0)</code> 等待子进程执行结束；</li>
<li>读取环境变量 <code>AFL_KEEP_ASSEMBLY</code> 的值，如果没有设置这个环境变量，就unlink掉 <code>modified_file</code>(已插完桩的文件)。设置该环境变量主要是为了防止 <code>afl-as</code> 删掉插桩后的汇编文件，设置为1则会保留插桩后的汇编文件。</li>
</ol>
<p>可以通过在main函数中添加如下代码来打印实际执行的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">print</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">as_params</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="n">peinrf</span><span class="p">(</span><span class="s">&#34;as_params[%d]:%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">as_params</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111516.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111516.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111516.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111516.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111516.png"
        title="image-20210827111515934" /></p>
<p>在插桩完成后，会生成 <code>.s</code> 文件，内容如下（具体的文件位置与设置的环境变量相关）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111738.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111738.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111738.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111738.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827111738.png"
        title="image-20210827111738232" /></p>
<h5 id="3-add_instrumentation函数">3. add_instrumentation函数</h5>
<p><code>add_instrumentation</code> 函数负责处理输入文件，生成 <code>modified_file</code> ，将 <code>instrumentation</code> 插入所有适当的位置。其整体控制流程如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826145815.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826145815.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826145815.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826145815.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826145815.png"
        title="image-20210826145814976" /></p>
<p>整体逻辑看上去有点复杂，但是关键内容并不算很多。在main函数中调用完 <code>edit_params()</code> 函数完成 <code>as_params</code> 参数数组的处理后，进入到该函数。</p>
<ol>
<li>
<p>判断 <code>input_file</code> 是否为空，如果不为空则尝试打开文件获取fd赋值给 <code>inf</code>，失败则抛出异常；<code>input_file</code> 为空则 <code>inf</code> 设置为标准输入；</p>
</li>
<li>
<p>打开 <code>modified_file</code> ，获取fd赋值给 <code>outfd</code>，失败返回异常；进一步验证该文件是否可写，不可写返回异常；</p>
</li>
<li>
<p><code>while</code> 循环读取 <code>inf</code> 指向文件的每一行到 <code>line</code> 数组，每行最多 <code>MAX_LINE = 8192</code>个字节（含末尾的‘\0’），从<code>line</code>数组里将读取到的内容写入到 <code>outf</code> 指向的文件，然后进入到真正的插桩逻辑。这里需要注意的是，插桩只向 <code>.text</code> 段插入，：</p>
<ol>
<li>
<p>首先跳过标签、宏、注释；</p>
</li>
<li>
<p>这里结合部分关键代码进行解释。需要注意的是，变量 <code>instr_ok</code> 本质上是一个flag，用于表示是否位于<code>.text</code>段。变量设置为1，表示位于 <code>.text</code> 中，如果不为1，则表示不再。于是，如果<code>instr_ok</code> 为1，就会在分支处执行插桩逻辑，否则就不插桩。</p>
<ol>
<li>
<p>首先判断读入的行是否以‘\t’ 开头，本质上是在匹配<code>.s</code>文件中声明的段，然后判断<code>line[1]</code>是否为<code>.</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>

      <span class="cm">/* OpenBSD puts jump tables directly inline with the code, which is
</span><span class="cm">         a bit annoying. They use a specific format of p2align directives
</span><span class="cm">         around them, so we use that as a signal. */</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">clang_mode</span> <span class="o">&amp;&amp;</span> <span class="n">instr_ok</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;p2align &#34;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="n">isdigit</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> <span class="n">skip_next_label</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;text</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">||</span>
          <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;section</span><span class="se">\t</span><span class="s">.text&#34;</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span> <span class="o">||</span>
          <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;section</span><span class="se">\t</span><span class="s">__TEXT,__text&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span> <span class="o">||</span>
          <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;section __TEXT,__text&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">instr_ok</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span> 
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;section</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span>
          <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;section &#34;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span>
          <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;bss</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span>
          <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;data</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">instr_ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>&lsquo;\t&rsquo;开头，且<code>line[1]=='.'</code>，检查是否为 <code>p2align</code> 指令，如果是，则设置 <code>skip_next_label = 1</code>；</li>
<li>尝试匹配 <code>&quot;text\n&quot;</code> <code>&quot;section\t.text&quot;</code> <code>&quot;section\t__TEXT,__text&quot;</code> <code>&quot;section __TEXT,__text&quot;</code> 其中任意一个，匹配成功， 设置 <code>instr_ok = 1</code>， 表示位于 <code>.text</code> 段中，<code>continue</code> 跳出，进行下一次遍历；</li>
<li>尝试匹配<code>&quot;section\t&quot;</code> <code>&quot;section &quot;</code> <code>&quot;bss\n&quot;</code> <code>&quot;data\n&quot;</code> 其中任意一个，匹配成功，设置 <code>instr_ok = 0</code>，表位于其他段中，<code>continue</code> 跳出，进行下一次遍历；</li>
</ol>
</li>
<li>
<p>接下来通过几个 <code>if</code> 判断，来设置一些标志信息，包括 <code>off-flavor assembly</code>，<code>Intel/AT&amp;T</code>的块处理方式、<code>ad-hoc __asm__</code>块的处理方式等；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/* Detect off-flavor assembly (rare, happens in gdb). When this is
</span><span class="cm">       encountered, we set skip_csect until the opposite directive is
</span><span class="cm">       seen, and we do not instrument. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;.code&#34;</span><span class="p">))</span> <span class="p">{</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;.code32&#34;</span><span class="p">))</span> <span class="n">skip_csect</span> <span class="o">=</span> <span class="n">use_64bit</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;.code64&#34;</span><span class="p">))</span> <span class="n">skip_csect</span> <span class="o">=</span> <span class="o">!</span><span class="n">use_64bit</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="cm">/* Detect syntax changes, as could happen with hand-written assembly.
</span><span class="cm">       Skip Intel blocks, resume instrumentation when back to AT&amp;T. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;.intel_syntax&#34;</span><span class="p">))</span> <span class="n">skip_intel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;.att_syntax&#34;</span><span class="p">))</span> <span class="n">skip_intel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Detect and skip ad-hoc __asm__ blocks, likewise skipping them. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span> <span class="o">||</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;#APP&#34;</span><span class="p">))</span> <span class="n">skip_app</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;#NO_APP&#34;</span><span class="p">))</span> <span class="n">skip_app</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>AFL在插桩时重点关注的内容包括：<code>^main, ^.L0, ^.LBB0_0, ^\tjnz foo</code> （_main函数， gcc和clang下的分支标记，条件跳转分支标记），这些内容通常标志了程序的流程变化，因此AFL会重点在这些位置进行插桩：</p>
<p>对于形如<code>\tj[^m].</code>格式的指令，即条件跳转指令，且<code>R(100)</code>产生的随机数小于插桩密度<code>inst_ratio</code>，直接使用<code>fprintf</code>将<code>trampoline_fmt_64</code>(插桩部分的指令)写入 <code>outf</code> 指向的文件，写入大小为小于 <code>MAP_SIZE</code>的随机数——<code>R(MAP_SIZE)</code></p>
<p>，然后插桩计数<code>ins_lines</code>加一，<code>continue</code> 跳出，进行下一次遍历；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/* If we&#39;re in the right mood for instrumenting, check for function
</span><span class="cm">       names or conditional labels. This is a bit messy, but in essence,
</span><span class="cm">       we want to catch:
</span><span class="cm">
</span><span class="cm">         ^main:      - function entry point (always instrumented)
</span><span class="cm">         ^.L0:       - GCC branch label
</span><span class="cm">         ^.LBB0_0:   - clang branch label (but only in clang mode)
</span><span class="cm">         ^\tjnz foo  - conditional branches
</span><span class="cm">
</span><span class="cm">       ...but not:
</span><span class="cm">
</span><span class="cm">         ^# BB#0:    - clang comments
</span><span class="cm">         ^ # BB#0:   - ditto
</span><span class="cm">         ^.Ltmp0:    - clang non-branch labels
</span><span class="cm">         ^.LC0       - GCC non-branch labels
</span><span class="cm">         ^.LBB0_0:   - ditto (when in GCC mode)
</span><span class="cm">         ^\tjmp foo  - non-conditional jumps
</span><span class="cm">
</span><span class="cm">       Additionally, clang and GCC on MacOS X follow a different convention
</span><span class="cm">       with no leading dots on labels, hence the weird maze of #ifdefs
</span><span class="cm">       later on.
</span><span class="cm">
</span><span class="cm">     */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">skip_intel</span> <span class="o">||</span> <span class="n">skip_app</span> <span class="o">||</span> <span class="n">skip_csect</span> <span class="o">||</span> <span class="o">!</span><span class="n">instr_ok</span> <span class="o">||</span>
        <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;#&#39;</span> <span class="o">||</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

    <span class="cm">/* Conditional branch instruction (jnz, etc). We append the instrumentation
</span><span class="cm">       right after the branch (to instrument the not-taken path) and at the
</span><span class="cm">       branch destination label (handled later on). */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;j&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;m&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">R</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">inst_ratio</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">fprintf</span><span class="p">(</span><span class="n">outf</span><span class="p">,</span> <span class="n">use_64bit</span> <span class="o">?</span> <span class="nl">trampoline_fmt_64</span> <span class="p">:</span> <span class="n">trampoline_fmt_32</span><span class="p">,</span>
                <span class="n">R</span><span class="p">(</span><span class="n">MAP_SIZE</span><span class="p">));</span>

        <span class="n">ins_lines</span><span class="o">++</span><span class="p">;</span>

      <span class="p">}</span>

      <span class="k">continue</span><span class="p">;</span>

    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>对于label的相关评估，有一些label可能是一些分支的目的地，需要自己评判</p>
<p>首先检查该行中是否存在<code>:</code>，然后检查是否以<code>.</code>开始</p>
<ol>
<li>
<p>如果以<code>.</code>开始，则代表想要插桩<code>^.L0:</code>或者 <code>^.LBB0_0:</code>这样的branch label，即 style jump destination</p>
<ol>
<li>检查 <code>line[2]</code>是否为数字 或者 如果是在clang_mode下，比较从<code>line[1]</code>开始的三个字节是否为<code>LBB. </code>，前述所得结果和<code>R(100) &lt; inst_ratio)</code>相与。如果结果为真，则设置<code>instrument_next = 1</code>；</li>
</ol>
</li>
<li>
<p>否则代表这是一个function，插桩<code>^func:</code>，function entry point，直接设置<code>instrument_next = 1</code>（defer mode）。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="cm">/* Label of some sort. This may be a branch destination, but we need to
</span><span class="cm">       tread carefully and account for several different formatting
</span><span class="cm">       conventions. */</span>

<span class="cp">#ifdef __APPLE__
</span><span class="cp"></span>
    <span class="cm">/* Apple: L&lt;whatever&gt;&lt;digit&gt;: */</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">colon_pos</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">)))</span> <span class="p">{</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;L&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">colon_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>

<span class="cp">#else
</span><span class="cp"></span>
    <span class="cm">/* Everybody else: .L&lt;whatever&gt;: */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">))</span> <span class="p">{</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>

<span class="cp">#endif </span><span class="cm">/* __APPLE__ */</span><span class="cp">
</span><span class="cp"></span>
        <span class="cm">/* .L0: or LBB0_0: style jump destination */</span>

<span class="cp">#ifdef __APPLE__
</span><span class="cp"></span>
        <span class="cm">/* Apple: L&lt;num&gt; / LBB&lt;num&gt; */</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">isdigit</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">||</span> <span class="p">(</span><span class="n">clang_mode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">&#34;LBB&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
            <span class="o">&amp;&amp;</span> <span class="n">R</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">inst_ratio</span><span class="p">)</span> <span class="p">{</span>

<span class="cp">#else
</span><span class="cp"></span>
        <span class="cm">/* Apple: .L&lt;num&gt; / .LBB&lt;num&gt; */</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">isdigit</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">||</span> <span class="p">(</span><span class="n">clang_mode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;LBB&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
            <span class="o">&amp;&amp;</span> <span class="n">R</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">inst_ratio</span><span class="p">)</span> <span class="p">{</span>

<span class="cp">#endif </span><span class="cm">/* __APPLE__ */</span><span class="cp">
</span><span class="cp"></span>
          <span class="cm">/* An optimization is possible here by adding the code only if the
</span><span class="cm">             label is mentioned in the code in contexts other than call / jmp.
</span><span class="cm">             That said, this complicates the code by requiring two-pass
</span><span class="cm">             processing (messy with stdin), and results in a speed gain
</span><span class="cm">             typically under 10%, because compilers are generally pretty good
</span><span class="cm">             about not generating spurious intra-function jumps.
</span><span class="cm">
</span><span class="cm">             We use deferred output chiefly to avoid disrupting
</span><span class="cm">             .Lfunc_begin0-style exception handling calculations (a problem on
</span><span class="cm">             MacOS X). */</span>

          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_next_label</span><span class="p">)</span> <span class="n">instrument_next</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">else</span> <span class="n">skip_next_label</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="p">}</span>

      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

        <span class="cm">/* Function label (always instrumented, deferred mode). */</span>

        <span class="n">instrument_next</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>上述过程完成后，来到 <code>while</code> 循环的下一个循环，在 <code>while</code> 的开头，可以看到对以 defered mode 进行插桩的位置进行了真正的插桩处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pass_thru</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_intel</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_app</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_csect</span> <span class="o">&amp;&amp;</span> <span class="n">instr_ok</span> <span class="o">&amp;&amp;</span>
        <span class="n">instrument_next</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\t&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">isalpha</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>

      <span class="n">fprintf</span><span class="p">(</span><span class="n">outf</span><span class="p">,</span> <span class="n">use_64bit</span> <span class="o">?</span> <span class="nl">trampoline_fmt_64</span> <span class="p">:</span> <span class="n">trampoline_fmt_32</span><span class="p">,</span>
              <span class="n">R</span><span class="p">(</span><span class="n">MAP_SIZE</span><span class="p">));</span>

      <span class="n">instrument_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">ins_lines</span><span class="o">++</span><span class="p">;</span>

    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里对 <code>instr_ok, instrument_next</code> 变量进行了检验是否为1，而且进一步校验是否位于 <code>.text</code> 段中，且设置了 defered mode 进行插桩，则就进行插桩操作，写入 <code>trampoline_fmt_64/32</code> 。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>至此，插桩函数 <code>add_instrumentation</code> 的主要逻辑已梳理完成。</p>
<h5 id="4-edit_params函数">4. edit_params函数</h5>
<p><code>edit_params</code>，该函数主要是设置变量 <code>as_params</code> 的值，以及 <code>use_64bit/modified_file</code> 的值， 其整体控制流程如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826122737.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826122737.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826122737.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826122737.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210826122737.png"
        title="image-20210826122737400" /></p>
<ol>
<li>
<p>获取环境变量 <code>TMPDIR</code> 和 <code>AFL_AS</code>;</p>
</li>
<li>
<p>对于 <code>__APPLE_</code> 宏， 如果当前在 <code>clang_mode</code> 且没有设置 <code>AFL_AS</code> 环境变量，会设置 <code>use_clang_mode = 1</code>，并设置 <code>afl-as</code> 为 <code>AFL_CC/AFL_CXX/clang</code>中的一种；</p>
</li>
<li>
<p>设置 <code>tmp_dir</code> ，尝试获取的环境变量依次为 <code>TEMP, TMP</code>，如果都失败，则直接设置为 <code>/tmp</code>；</p>
</li>
<li>
<p>调用 <code>ck_alloc()</code> 函数为 <code>as_params</code> 参数数组分配内存，大小为(argc + 32) * 8；</p>
</li>
<li>
<p>设置 <code>afl-as</code> 路径：<code>as_params[0] = afl_as ? afl_as : (u8*)&quot;as&quot;;</code></p>
</li>
<li>
<p>设置 <code>  as_params[argc] = 0;</code> ，as_par_cnt 初始值为1；</p>
</li>
<li>
<p>遍历从 <code>argv[1]</code> 到 <code>argv[argc-1]</code> 之前的每个 argv：</p>
<ol>
<li>如果存在字符串 <code>--64</code>， 则设置 <code>use_64bit = 1</code> ；如果存在字符串 <code>--32</code> ，则设置 <code>use_64bit = 0</code>。对于<code>__APPLE__</code> ，如果存在<code>-arch x86_64</code>，设置 <code>use_64bit=1</code>，并跳过<code>-q</code>和<code>-Q</code>选项；</li>
<li><code>as_params[as_par_cnt++] = argv[i]</code>，设置as_params的值为argv对应的参数值</li>
</ol>
</li>
<li>
<p>开始设置其他参数：</p>
<ol>
<li>
<p>对于 <code>__APPLE__</code>，如果设置了 <code>use_clang_as</code>，则追加 <code>-c -x assembler</code>；</p>
</li>
<li>
<p>设置 <code>input_file</code> 变量：<code>input_file = argv[argc - 1];</code>，把最后一个参数的值作为 <code>input_file</code>；</p>
<ol>
<li>
<p>如果 <code>input_file</code> 的首字符为<code>-</code>：</p>
<ol>
<li>如果后续为 <code>-version</code>，则 <code>just_version = 1</code>, <code>modified_file = input_file</code>，然后跳转到<code>wrap_things_up</code>。这里就只是做<code>version</code>的查询；</li>
<li>如果后续不为 <code>-version</code>，抛出异常；</li>
</ol>
</li>
<li>
<p>如果 <code>input_file</code> 首字符不为<code>-</code>，比较 <code>input_file</code> 和 <code>tmp_dir </code>、<code>/var/tmp</code> 、<code>/tmp/</code>的前 <code>strlen(tmp_dir)/9/5</code>个字节是否相同，如果不相同，就设置 <code>pass_thru</code> 为1；</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>设置 <code>modified_file</code>：<code>modified_file = alloc_printf(&quot;%s/.afl-%u-%u.s&quot;, tmp_dir, getpid(), (u32)time(NULL));</code>，即为<code>tmp_dir/afl-pid-tim.s</code> 格式的字符串</p>
<ol start="4">
<li>设置<code>as_params[as_par_cnt++] = modified_file</code>，<code>as_params[as_par_cnt] = NULL;</code>。</li>
</ol>
</li>
</ol>
<h4 id="3-instrumentation-trampoline-和-main_payload">3. instrumentation trampoline 和 main_payload</h4>
<p><code>trampoline</code> 的含义是“蹦床”，直译过来就是“插桩蹦床”。个人感觉直接使用英文更能表达出其代表的真实含义和作用，可以简单理解为桩代码。</p>
<h5 id="1-trampoline_fmt_6432">1. trampoline_fmt_64/32</h5>
<p>根据前面内容知道，在64位环境下，AFL会插入 <code>trampoline_fmt_64</code> 到文件中，在32位环境下，AFL会插入<code>trampoline_fmt_32</code> 到文件中。<code>trampoline_fmt_64/32</code>定义在 <code>afl-as.h</code> 头文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">const</span> <span class="n">u8</span><span class="o">*</span> <span class="n">trampoline_fmt_32</span> <span class="o">=</span>

  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;/* --- AFL TRAMPOLINE (32-BIT) --- */</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;.align 4</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;leal -16(%%esp), %%esp</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl %%edi,  0(%%esp)</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl %%edx,  4(%%esp)</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl %%ecx,  8(%%esp)</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl %%eax, 12(%%esp)</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl $0x%08x, %%ecx</span><span class="se">\n</span><span class="s">&#34;</span>    <span class="c1">// 向ecx中存入识别代码块的随机桩代码id
</span><span class="c1"></span>  <span class="s">&#34;call __afl_maybe_log</span><span class="se">\n</span><span class="s">&#34;</span>   <span class="c1">// 调用 __afl_maybe_log 函数
</span><span class="c1"></span>  <span class="s">&#34;movl 12(%%esp), %%eax</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl  8(%%esp), %%ecx</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl  4(%%esp), %%edx</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movl  0(%%esp), %%edi</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;leal 16(%%esp), %%esp</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;/* --- END --- */</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span><span class="o">*</span> <span class="n">trampoline_fmt_64</span> <span class="o">=</span>

  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;/* --- AFL TRAMPOLINE (64-BIT) --- */</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;.align 4</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;leaq -(128+24)(%%rsp), %%rsp</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movq %%rdx,  0(%%rsp)</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movq %%rcx,  8(%%rsp)</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movq %%rax, 16(%%rsp)</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movq $0x%08x, %%rcx</span><span class="se">\n</span><span class="s">&#34;</span>  <span class="c1">// 64位下使用的寄存器为rcx
</span><span class="c1"></span>  <span class="s">&#34;call __afl_maybe_log</span><span class="se">\n</span><span class="s">&#34;</span> <span class="c1">// 调用 __afl_maybe_log 函数
</span><span class="c1"></span>  <span class="s">&#34;movq 16(%%rsp), %%rax</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movq  8(%%rsp), %%rcx</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;movq  0(%%rsp), %%rdx</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;leaq (128+24)(%%rsp), %%rsp</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;/* --- END --- */</span><span class="se">\n</span><span class="s">&#34;</span>
  <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面列出的插桩代码与我们在 <code>.s</code> 文件和IDA逆向中看到的插桩代码是一样的：</p>
<p><code>.s</code> 文件中的桩代码：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902113944.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902113944.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902113944.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902113944.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902113944.png"
        title="image-20210902113944635" /></p>
<p>IDA逆向中显示的桩代码：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902114629.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902114629.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902114629.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902114629.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902114629.png"
        title="image-20210902114629323" /></p>
<p>上述代码执行的主要功能包括：</p>
<ul>
<li>保存 <code>rdx</code>、 <code>rcx</code> 、<code>rax</code> 寄存器</li>
<li>将 <code>rcx</code> 的值设置为 <code>fprintf()</code> 函数将要打印的变量内容</li>
<li>调用 <code>__afl_maybe_log</code> 函数</li>
<li>恢复寄存器</li>
</ul>
<p>在以上的功能中， <code>__afl_maybe_log</code> 才是核心内容。</p>
<p>从 <code>__afl_maybe_log</code> 函数开始，后续的处理流程大致如下(图片来自ScUpax0s师傅)：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827114857.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827114857.jpg, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827114857.jpg 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827114857.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210827114857.jpg"
        title="img" /></p>
<p>首先对上面流程中涉及到的几个bss段的变量进行简单说明（以64位为例，从<code>main_payload_64</code>中提取）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="p">.</span><span class="nl">AFL_VARS</span><span class="p">:</span>
 
  <span class="p">.</span><span class="n">comm</span>   <span class="n">__afl_area_ptr</span><span class="p">,</span> <span class="mi">8</span>
  <span class="p">.</span><span class="n">comm</span>   <span class="n">__afl_prev_loc</span><span class="p">,</span> <span class="mi">8</span>
  <span class="p">.</span><span class="n">comm</span>   <span class="n">__afl_fork_pid</span><span class="p">,</span> <span class="mi">4</span>
  <span class="p">.</span><span class="n">comm</span>   <span class="n">__afl_temp</span><span class="p">,</span> <span class="mi">4</span>
  <span class="p">.</span><span class="n">comm</span>   <span class="n">__afl_setup_failure</span><span class="p">,</span> <span class="mi">1</span>
  <span class="p">.</span><span class="n">comm</span>    <span class="n">__afl_global_area_ptr</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>__afl_area_ptr</code>：共享内存地址；</li>
<li><code>__afl_prev_loc</code>：上一个插桩位置（id为R(100)随机数的值）；</li>
<li><code>__afl_fork_pid</code>：由fork产生的子进程的pid；</li>
<li><code>__afl_temp</code>：缓冲区；</li>
<li><code>__afl_setup_failure</code>：标志位，如果置位则直接退出；</li>
<li><code>__afl_global_area_ptr</code>：全局指针。</li>
</ul>
<p><strong>说明</strong></p>
<p>以下介绍的指令段均来自于 <code>main_payload_64</code> 。</p>
<h5 id="2-__afl_maybe_log">2. __afl_maybe_log</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">__afl_maybe_log:</span>   <span class="err">/*</span> <span class="err">源码删除无关内容后</span> <span class="err">*/</span>
 
  <span class="nf">lahf</span>
  <span class="nf">seto</span>  <span class="nv">%al</span>
 
  <span class="err">/*</span> <span class="nf">Check</span> <span class="no">if</span> <span class="no">SHM</span> <span class="no">region</span> <span class="no">is</span> <span class="no">already</span> <span class="no">mapped.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">movq</span>  <span class="no">__afl_area_ptr</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdx</span>
  <span class="nf">testq</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nf">je</span>    <span class="no">__afl_setup</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，使用 <code>lahf</code> 指令（加载状态标志位到<code>AH</code>）将EFLAGS寄存器的低八位复制到 <code>AH</code>，被复制的标志位包括：符号标志位（SF）、零标志位（ZF）、辅助进位标志位（AF）、奇偶标志位（PF）和进位标志位（CF），使用该指令可以方便地将标志位副本保存在变量中；</p>
<p>然后，使用 <code>seto</code> 指令溢出置位；</p>
<p>接下来检查共享内存是否进行了设置，判断 <code>__afl_area_ptr</code> 是否为NULL：</p>
<ul>
<li>如果为NULL，跳转到 <code>__afl_setup</code> 函数进行设置；</li>
<li>如果不为NULL，继续进行。</li>
</ul>
<h5 id="3-__afl_setup">3. __afl_setup</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">__afl_setup:</span>

		<span class="err">/*</span> <span class="nf">Do</span> <span class="no">not</span> <span class="no">retry</span> <span class="no">setup</span> <span class="no">is</span> <span class="no">we</span> <span class="no">had</span> <span class="no">previous</span> <span class="no">failues.</span> <span class="p">*</span><span class="err">/</span>
		<span class="nf">cmpb</span> <span class="no">$0</span><span class="p">,</span> <span class="no">__afl_setup_failure</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
		<span class="nf">jne</span> <span class="no">__afl_return</span>
		
		<span class="err">/*</span> <span class="nf">Check</span> <span class="no">out</span> <span class="no">if</span> <span class="no">we</span> <span class="no">have</span> <span class="no">a</span> <span class="no">global</span> <span class="no">pointer</span> <span class="no">on</span> <span class="no">file.</span> <span class="p">*</span><span class="err">/</span>
		<span class="nf">movq</span> <span class="no">__afl_global_area_ptr</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdx</span>
		<span class="nf">testq</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>
		<span class="nf">je</span> <span class="no">__afl_setup_first</span>
		
		<span class="nf">movq</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="no">__afl_area_ptr</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
		<span class="nf">jmp</span>  <span class="no">__afl_store</span>
</code></pre></td></tr></table>
</div>
</div><p>该部分的主要作用为初始化 <code>__afl_area_ptr</code> ，且只在运行到第一个桩时进行本次初始化。</p>
<p>首先，如果 <code>__afl_setup_failure</code> 不为0，直接跳转到 <code>__afl_return</code> 返回；</p>
<p>然后，检查 <code>__afl_global_area_ptr</code> 文件指针是否为NULL：</p>
<ul>
<li>如果为NULL，跳转到 <code>__afl_setup_first</code> 进行接下来的工作；</li>
<li>如果不为NULL，将 <code>__afl_global_area_ptr</code> 的值赋给 <code>__afl_area_ptr</code>，然后跳转到 <code>__afl_store</code> 。</li>
</ul>
<h5 id="4-__afl_setup_first">4. __afl_setup_first</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">__afl_setup_first:</span>
 
  <span class="err">/*</span> <span class="nf">Save</span> <span class="no">everything</span> <span class="no">that</span> <span class="no">is</span> <span class="no">not</span> <span class="no">yet</span> <span class="no">saved</span> <span class="no">and</span> <span class="no">that</span> <span class="no">may</span> <span class="no">be</span> <span class="no">touched</span> <span class="no">by</span>
     <span class="nf">getenv</span><span class="p">()</span> <span class="no">and</span> <span class="no">several</span> <span class="no">other</span> <span class="no">libcalls</span> <span class="no">we</span><span class="err">&#39;</span><span class="no">ll</span> <span class="no">be</span> <span class="no">relying</span> <span class="no">on.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">leaq</span> <span class="p">-</span><span class="mi">352</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rsp</span>
 
  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,</span>   <span class="mi">0</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%rcx</span><span class="p">,</span>   <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%rdi</span><span class="p">,</span>  <span class="mi">16</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%rsi</span><span class="p">,</span>  <span class="mi">32</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%r8</span><span class="p">,</span>   <span class="mi">40</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%r9</span><span class="p">,</span>   <span class="mi">48</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%r10</span><span class="p">,</span>  <span class="mi">56</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%r11</span><span class="p">,</span>  <span class="mi">64</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
 
  <span class="nf">movq</span> <span class="nv">%xmm0</span><span class="p">,</span>  <span class="mi">96</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm1</span><span class="p">,</span>  <span class="mi">112</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm2</span><span class="p">,</span>  <span class="mi">128</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm3</span><span class="p">,</span>  <span class="mi">144</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm4</span><span class="p">,</span>  <span class="mi">160</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm5</span><span class="p">,</span>  <span class="mi">176</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm6</span><span class="p">,</span>  <span class="mi">192</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm7</span><span class="p">,</span>  <span class="mi">208</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm8</span><span class="p">,</span>  <span class="mi">224</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm9</span><span class="p">,</span>  <span class="mi">240</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm10</span><span class="p">,</span> <span class="mi">256</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm11</span><span class="p">,</span> <span class="mi">272</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm12</span><span class="p">,</span> <span class="mi">288</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm13</span><span class="p">,</span> <span class="mi">304</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm14</span><span class="p">,</span> <span class="mi">320</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%xmm15</span><span class="p">,</span> <span class="mi">336</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">)</span>
 
  <span class="err">/*</span> <span class="nf">Map</span> <span class="no">SHM</span><span class="p">,</span> <span class="no">jumping</span> <span class="no">to</span> <span class="no">__afl_setup_abort</span> <span class="no">if</span> <span class="no">something</span> <span class="no">goes</span> <span class="no">wrong.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="err">/*</span> <span class="nf">The</span> <span class="mi">64</span><span class="p">-</span><span class="no">bit</span> <span class="no">ABI</span> <span class="no">requires</span> <span class="mi">16</span><span class="p">-</span><span class="no">byte</span> <span class="no">stack</span> <span class="no">alignment.</span> <span class="no">We</span><span class="err">&#39;</span><span class="no">ll</span> <span class="no">keep</span> <span class="no">the</span>
     <span class="nf">original</span> <span class="no">stack</span> <span class="no">ptr</span> <span class="no">in</span> <span class="no">the</span> <span class="no">callee-saved</span> <span class="no">r12.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">pushq</span> <span class="nv">%r12</span>
  <span class="nf">movq</span>  <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%r12</span>
  <span class="nf">subq</span>  <span class="no">$16</span><span class="p">,</span> <span class="nv">%rsp</span>
  <span class="nf">andq</span>  <span class="no">$0xfffffffffffffff0</span><span class="p">,</span> <span class="nv">%rsp</span>
 
  <span class="nf">leaq</span> <span class="no">.AFL_SHM_ENV</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdi</span>
<span class="nf">call</span> <span class="no">_getenv</span>
 
  <span class="nf">testq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rax</span>
  <span class="nf">je</span>    <span class="no">__afl_setup_abort</span>
 
  <span class="nf">movq</span>  <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
<span class="nf">call</span> <span class="no">_atoi</span>
 
  <span class="nf">xorq</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rdx</span>   <span class="err">/</span><span class="p">*</span> <span class="no">shmat</span> <span class="no">flags</span>    <span class="p">*</span><span class="err">/</span>
  <span class="nf">xorq</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="nv">%rsi</span>   <span class="err">/</span><span class="p">*</span> <span class="no">requested</span> <span class="no">addr</span> <span class="p">*</span><span class="err">/</span>
  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>   <span class="err">/</span><span class="p">*</span> <span class="no">SHM</span> <span class="no">ID</span>         <span class="p">*</span><span class="err">/</span>
<span class="nf">call</span> <span class="no">_shmat</span>
 
  <span class="nf">cmpq</span> <span class="no">$-1</span><span class="p">,</span> <span class="nv">%rax</span>
  <span class="nf">je</span>   <span class="no">__afl_setup_abort</span>
 
  <span class="err">/*</span> <span class="nf">Store</span> <span class="no">the</span> <span class="no">address</span> <span class="no">of</span> <span class="no">the</span> <span class="no">SHM</span> <span class="no">region.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdx</span>
  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="no">__afl_area_ptr</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
 
  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="no">__afl_global_area_ptr</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
  <span class="nf">movq</span> <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdx</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，保存所有寄存器的值，包括 <code>xmm</code> 寄存器组；</p>
<p>然后，进行 <code>rsp</code> 的对齐；</p>
<p>然后，获取环境变量 <code>__AFL_SHM_ID</code>，该环境变量保存的是共享内存的ID：</p>
<ul>
<li>如果获取失败，跳转到 <code>__afl_setup_abort</code> ；</li>
<li>如果获取成功，调用 <code>_shmat</code> ，启用对共享内存的访问，启用失败跳转到 <code>__afl_setup_abort</code>。</li>
</ul>
<p>接下来，将 <code>_shmat</code> 返回的共享内存地址存储在 <code>__afl_area_ptr</code> 和 <code> __afl_global_area_ptr</code> 变量中。</p>
<p>后面即开始运行 <code>__afl_forkserver</code>。</p>
<h5 id="5-__afl_forkserver">5. __afl_forkserver</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">__afl_forkserver:</span>

	 <span class="err">/*</span> <span class="nf">Enter</span> <span class="no">the</span> <span class="no">fork</span> <span class="no">server</span> <span class="no">mode</span> <span class="no">to</span> <span class="no">avoid</span> <span class="no">the</span> <span class="no">overhead</span> <span class="no">of</span> <span class="no">execve</span><span class="p">()</span> <span class="no">calls.</span> <span class="no">We</span>
     <span class="nf">push</span> <span class="no">rdx</span> <span class="p">(</span><span class="no">area</span> <span class="no">ptr</span><span class="p">)</span> <span class="no">twice</span> <span class="no">to</span> <span class="no">keep</span> <span class="no">stack</span> <span class="no">alignment</span> <span class="no">neat.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">pushq</span> <span class="nv">%rdx</span>
  <span class="nf">pushq</span> <span class="nv">%rdx</span>
 
  <span class="err">/*</span> <span class="nf">Phone</span> <span class="no">home</span> <span class="no">and</span> <span class="no">tell</span> <span class="no">the</span> <span class="no">parent</span> <span class="no">that</span> <span class="no">we</span><span class="err">&#39;</span><span class="no">re</span> <span class="no">OK.</span> <span class="p">(</span><span class="no">Note</span> <span class="no">that</span> <span class="no">signals</span> <span class="no">with</span>
     <span class="nf">no</span> <span class="no">SA_RESTART</span> <span class="no">will</span> <span class="no">mess</span> <span class="no">it</span> <span class="no">up</span><span class="p">).</span> <span class="no">If</span> <span class="no">this</span> <span class="no">fails</span><span class="p">,</span> <span class="no">assume</span> <span class="no">that</span> <span class="no">the</span> <span class="no">fd</span> <span class="no">is</span>
     <span class="nf">closed</span> <span class="no">because</span> <span class="no">we</span> <span class="no">were</span> <span class="no">execve</span><span class="p">()</span><span class="no">d</span> <span class="no">from</span> <span class="no">an</span> <span class="no">instrumented</span> <span class="no">binary</span><span class="p">,</span> <span class="no">or</span> <span class="no">because</span>
     <span class="nf">the</span> <span class="no">parent</span> <span class="no">doesn</span><span class="err">&#39;</span><span class="no">t</span> <span class="no">want</span> <span class="no">to</span> <span class="no">use</span> <span class="no">the</span> <span class="no">fork</span> <span class="no">server.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">movq</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rdx</span>               <span class="err">/</span><span class="p">*</span> <span class="no">length</span>    <span class="p">*</span><span class="err">/</span>
  <span class="nf">leaq</span> <span class="no">__afl_temp</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span> <span class="err">/</span><span class="p">*</span> <span class="no">data</span>      <span class="p">*</span><span class="err">/</span>
  <span class="nf">movq</span> <span class="no">$</span><span class="err">&#34;</span> <span class="no">STRINGIFY</span><span class="p">((</span><span class="no">FORKSRV_FD</span> <span class="err">+</span> <span class="mi">1</span><span class="p">))</span> <span class="err">&#34;</span><span class="p">,</span> <span class="nv">%rdi</span>       <span class="err">/</span><span class="p">*</span> <span class="no">file</span> <span class="no">desc</span> <span class="p">*</span><span class="err">/</span>
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">write</span><span class="err">&#34;</span><span class="p">)</span>
 
  <span class="nf">cmpq</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rax</span>
  <span class="nf">jne</span>  <span class="no">__afl_fork_resume</span>
</code></pre></td></tr></table>
</div>
</div><p>这一段实现的主要功能是向 <code>FORKSRV_FD+1</code> （也就是198+1）号描述符（即状态管道）中写 <code>__afl_temp</code> 中的4个字节，告诉 fork server （将在后续的文章中进行详细解释）已经成功启动。</p>
<h5 id="6-__afl_fork_wait_loop">6. __afl_fork_wait_loop</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">__afl_fork_wait_loop:</span>
 
  <span class="err">/*</span> <span class="nf">Wait</span> <span class="no">for</span> <span class="no">parent</span> <span class="no">by</span> <span class="no">reading</span> <span class="no">from</span> <span class="no">the</span> <span class="no">pipe.</span> <span class="no">Abort</span> <span class="no">if</span> <span class="no">read</span> <span class="no">fails.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">movq</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rdx</span>               <span class="err">/</span><span class="p">*</span> <span class="no">length</span>    <span class="p">*</span><span class="err">/</span>
  <span class="nf">leaq</span> <span class="no">__afl_temp</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span> <span class="err">/</span><span class="p">*</span> <span class="no">data</span>      <span class="p">*</span><span class="err">/</span>
  <span class="nf">movq</span> <span class="no">$</span><span class="err">&#34;</span> <span class="no">STRINGIFY</span><span class="p">(</span><span class="no">FORKSRV_FD</span><span class="p">)</span> <span class="err">&#34;</span><span class="p">,</span> <span class="nv">%rdi</span>            <span class="err">/</span><span class="p">*</span> <span class="no">file</span> <span class="no">desc</span> <span class="p">*</span><span class="err">/</span>
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">read</span><span class="err">&#34;</span><span class="p">)</span>
  <span class="nf">cmpq</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rax</span>
  <span class="nf">jne</span>  <span class="no">__afl_die</span>
 
  <span class="err">/*</span> <span class="nf">Once</span> <span class="no">woken</span> <span class="no">up</span><span class="p">,</span> <span class="no">create</span> <span class="no">a</span> <span class="no">clone</span> <span class="no">of</span> <span class="no">our</span> <span class="no">process.</span> <span class="no">This</span> <span class="no">is</span> <span class="no">an</span> <span class="no">excellent</span> <span class="no">use</span>
     <span class="nf">case</span> <span class="no">for</span> <span class="no">syscall</span><span class="p">(</span><span class="no">__NR_clone</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="no">CLONE_PARENT</span><span class="p">),</span> <span class="no">but</span> <span class="no">glibc</span> <span class="no">boneheadedly</span>
     <span class="nf">caches</span> <span class="no">getpid</span><span class="p">()</span> <span class="no">results</span> <span class="no">and</span> <span class="no">offers</span> <span class="no">no</span> <span class="no">way</span> <span class="no">to</span> <span class="no">update</span> <span class="no">the</span> <span class="no">value</span><span class="p">,</span> <span class="no">breaking</span>
     <span class="nf">abort</span><span class="p">(),</span> <span class="no">raise</span><span class="p">(),</span> <span class="no">and</span> <span class="no">a</span> <span class="no">bunch</span> <span class="no">of</span> <span class="no">other</span> <span class="no">things</span> <span class="p">:-(</span> <span class="p">*</span><span class="err">/</span>
 
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">fork</span><span class="err">&#34;</span><span class="p">)</span>
  <span class="nf">cmpq</span> <span class="no">$0</span><span class="p">,</span> <span class="nv">%rax</span>
  <span class="nf">jl</span>   <span class="no">__afl_die</span>
  <span class="nf">je</span>   <span class="no">__afl_fork_resume</span>
 
  <span class="err">/*</span> <span class="nf">In</span> <span class="no">parent</span> <span class="no">process</span><span class="p">:</span> <span class="no">write</span> <span class="no">PID</span> <span class="no">to</span> <span class="no">pipe</span><span class="p">,</span> <span class="no">then</span> <span class="no">wait</span> <span class="no">for</span> <span class="no">child.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">movl</span> <span class="nv">%eax</span><span class="p">,</span> <span class="no">__afl_fork_pid</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
 
  <span class="nf">movq</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rdx</span>                   <span class="err">/</span><span class="p">*</span> <span class="no">length</span>    <span class="p">*</span><span class="err">/</span>
  <span class="nf">leaq</span> <span class="no">__afl_fork_pid</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span> <span class="err">/</span><span class="p">*</span> <span class="no">data</span>      <span class="p">*</span><span class="err">/</span>
  <span class="nf">movq</span> <span class="no">$</span><span class="err">&#34;</span> <span class="no">STRINGIFY</span><span class="p">((</span><span class="no">FORKSRV_FD</span> <span class="err">+</span> <span class="mi">1</span><span class="p">))</span> <span class="err">&#34;</span><span class="p">,</span> <span class="nv">%rdi</span>             <span class="err">/</span><span class="p">*</span> <span class="no">file</span> <span class="no">desc</span> <span class="p">*</span><span class="err">/</span>
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">write</span><span class="err">&#34;</span><span class="p">)</span>
 
  <span class="nf">movq</span> <span class="no">$0</span><span class="p">,</span> <span class="nv">%rdx</span>                   <span class="err">/</span><span class="p">*</span> <span class="no">no</span> <span class="no">flags</span>  <span class="p">*</span><span class="err">/</span>
  <span class="nf">leaq</span> <span class="no">__afl_temp</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span>     <span class="err">/</span><span class="p">*</span> <span class="no">status</span>    <span class="p">*</span><span class="err">/</span>
  <span class="nf">movq</span> <span class="no">__afl_fork_pid</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rdi</span> <span class="err">/</span><span class="p">*</span> <span class="no">PID</span>       <span class="p">*</span><span class="err">/</span>
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">waitpid</span><span class="err">&#34;</span><span class="p">)</span>
  <span class="nf">cmpq</span> <span class="no">$0</span><span class="p">,</span> <span class="nv">%rax</span>
  <span class="nf">jle</span>  <span class="no">__afl_die</span>
 
  <span class="err">/*</span> <span class="nf">Relay</span> <span class="no">wait</span> <span class="no">status</span> <span class="no">to</span> <span class="no">pipe</span><span class="p">,</span> <span class="no">then</span> <span class="no">loop</span> <span class="no">back.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">movq</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%rdx</span>               <span class="err">/</span><span class="p">*</span> <span class="no">length</span>    <span class="p">*</span><span class="err">/</span>
  <span class="nf">leaq</span> <span class="no">__afl_temp</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rsi</span> <span class="err">/</span><span class="p">*</span> <span class="no">data</span>      <span class="p">*</span><span class="err">/</span>
  <span class="nf">movq</span> <span class="no">$</span><span class="err">&#34;</span> <span class="no">STRINGIFY</span><span class="p">((</span><span class="no">FORKSRV_FD</span> <span class="err">+</span> <span class="mi">1</span><span class="p">))</span> <span class="err">&#34;</span><span class="p">,</span> <span class="nv">%rdi</span>         <span class="err">/</span><span class="p">*</span> <span class="no">file</span> <span class="no">desc</span> <span class="p">*</span><span class="err">/</span>
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">write</span><span class="err">&#34;</span><span class="p">)</span>
 
  <span class="nf">jmp</span>  <span class="no">__afl_fork_wait_loop</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>等待fuzzer通过控制管道发送过来的命令，读入到 <code>__afl_temp</code> 中：
<ul>
<li>读取失败，跳转到 <code>__afl_die</code> ，结束循环；</li>
<li>读取成功，继续；</li>
</ul>
</li>
<li>fork 一个子进程，子进程执行 <code>__afl_fork_resume</code>；</li>
<li>将子进程的pid赋给 <code>__afl_fork_pid</code>，并写到状态管道中通知父进程；</li>
<li>等待子进程执行完成，写入状态管道告知 fuzzer；</li>
<li>重新执行下一轮 <code>__afl_fork_wait_loop</code> 。</li>
</ol>
<h5 id="7-__afl_fork_resume">7. __afl_fork_resume</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">__afl_fork_resume:</span>

<span class="err">/*</span> <span class="nf">In</span> <span class="no">child</span> <span class="no">process</span><span class="p">:</span> <span class="no">close</span> <span class="no">fds</span><span class="p">,</span> <span class="no">resume</span> <span class="no">execution.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">movq</span> <span class="no">$</span><span class="err">&#34;</span> <span class="no">STRINGIFY</span><span class="p">(</span><span class="no">FORKSRV_FD</span><span class="p">)</span> <span class="err">&#34;</span><span class="p">,</span> <span class="nv">%rdi</span>
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">close</span><span class="err">&#34;</span><span class="p">)</span>
 
  <span class="nf">movq</span> <span class="no">$</span><span class="p">(</span><span class="err">&#34;</span> <span class="no">STRINGIFY</span><span class="p">(</span><span class="no">FORKSRV_FD</span><span class="p">)</span> <span class="err">&#34;</span> <span class="err">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nv">%rdi</span>
<span class="nf">CALL_L64</span><span class="p">(</span><span class="err">&#34;</span><span class="no">close</span><span class="err">&#34;</span><span class="p">)</span>
 
  <span class="nf">popq</span> <span class="nv">%rdx</span>
  <span class="nf">popq</span> <span class="nv">%rdx</span>
 
  <span class="nf">movq</span> <span class="nv">%r12</span><span class="p">,</span> <span class="nv">%rsp</span>
  <span class="nf">popq</span> <span class="nv">%r12</span>
 
  <span class="nf">movq</span>  <span class="mi">0</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rax</span>
  <span class="nf">movq</span>  <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rcx</span>
  <span class="nf">movq</span> <span class="mi">16</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rdi</span>
  <span class="nf">movq</span> <span class="mi">32</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rsi</span>
  <span class="nf">movq</span> <span class="mi">40</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%r8</span>
  <span class="nf">movq</span> <span class="mi">48</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%r9</span>
  <span class="nf">movq</span> <span class="mi">56</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%r10</span>
  <span class="nf">movq</span> <span class="mi">64</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%r11</span>
 
  <span class="nf">movq</span>  <span class="mi">96</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm0</span>
  <span class="nf">movq</span> <span class="mi">112</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm1</span>
  <span class="nf">movq</span> <span class="mi">128</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm2</span>
  <span class="nf">movq</span> <span class="mi">144</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm3</span>
  <span class="nf">movq</span> <span class="mi">160</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm4</span>
  <span class="nf">movq</span> <span class="mi">176</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm5</span>
  <span class="nf">movq</span> <span class="mi">192</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm6</span>
  <span class="nf">movq</span> <span class="mi">208</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm7</span>
  <span class="nf">movq</span> <span class="mi">224</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm8</span>
  <span class="nf">movq</span> <span class="mi">240</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm9</span>
  <span class="nf">movq</span> <span class="mi">256</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm10</span>
  <span class="nf">movq</span> <span class="mi">272</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm11</span>
  <span class="nf">movq</span> <span class="mi">288</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm12</span>
  <span class="nf">movq</span> <span class="mi">304</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm13</span>
  <span class="nf">movq</span> <span class="mi">320</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm14</span>
  <span class="nf">movq</span> <span class="mi">336</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%xmm15</span>
 
  <span class="nf">leaq</span> <span class="mi">352</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%rsp</span>
 
  <span class="nf">jmp</span>  <span class="no">__afl_store</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>关闭子进程中的fd；</li>
<li>恢复子进程的寄存器状态；</li>
<li>跳转到 <code>__afl_store</code> 执行。</li>
</ol>
<h5 id="8-__afl_store">8. __afl_store</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">__afl_store:</span>
 
  <span class="err">/*</span> <span class="nf">Calculate</span> <span class="no">and</span> <span class="no">store</span> <span class="no">hit</span> <span class="no">for</span> <span class="no">the</span> <span class="no">code</span> <span class="no">location</span> <span class="no">specified</span> <span class="no">in</span> <span class="no">rcx.</span> <span class="p">*</span><span class="err">/</span>
 
  <span class="nf">xorq</span> <span class="no">__afl_prev_loc</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rcx</span>
  <span class="nf">xorq</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="no">__afl_prev_loc</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
  <span class="nf">shrq</span> <span class="no">$1</span><span class="p">,</span> <span class="no">__afl_prev_loc</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
 
  <span class="nf">incb</span> <span class="p">(</span><span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>我们直接看反编译的代码：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160522.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160522.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160522.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160522.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160522.png"
        title="image-20210902160522077" /></p>
<p>这里第一步的异或中的 <code>a4</code> ，其实是调用 <code>__afl_maybe_log</code> 时传入 的参数：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160753.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160753.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160753.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160753.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902160753.png"
        title="image-20210902160752809" /></p>
<p>再往上追溯到插桩代码：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902162008.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902162008.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902162008.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902162008.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210902162008.png"
        title="image-20210902160854687" /></p>
<p>可以看到传入 <code>rcx</code> 的，实际上就是用于标记当前桩的随机id， 而 <code>_afl_prev_loc</code> 其实是上一个桩的随机id。</p>
<p>经过两次异或之后，再将 <code>_afl_prev_loc</code> 右移一位作为新的 <code>_afl_prev_loc</code>，最后再共享内存中存储当前插桩位置的地方计数加一。</p>
<h2 id="二afl-的插桩--llvm_mode">二、AFL 的插桩 —— llvm_mode</h2>
<h3 id="一llvm-前置知识">（一）、LLVM 前置知识</h3>
<p>LLVM 主要为了解决编译时多种多样的前端和后端导致编译环境复杂、苛刻的问题，其核心为设计了一个称为 <code>LLVM IR</code> 的中间表示，并以库的形式提供一些列接口，以提供诸如操作 IR 、生成目标平台代码等等后端的功能。其整体架构如下所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150210.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150210.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150210.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150210.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150210.png"
        title="未命名绘图.drawio (1)" /></p>
<p>不同的前端和后端使用统一的中间代码<code>LLVM InterMediate Representation(LLVM IR)</code>，其结果就是如果需要支持一门新的编程语言，只需要实现一个新的前端；如果需要支持一款新的硬件设备，只需要实现一个新的后端；优化阶段为通用阶段，针对统一的 LLVM IR ，与新的编程语言和硬件设备无关。</p>
<p>GCC 的前后端耦合在一起，没有进行分离，所以GCC为了支持一门新的编程语言或一个新的硬件设备，需要重新开发前端到后端的完整过程。</p>
<p>Clang 是 LLVM 项目的一个子项目，它是 LLVM 架构下的 C/C++/Objective-C 的编译器，是 LLVM 前端的一部分。相较于GCC，具备编译速度快、占用内存少、模块化设计、诊断信息可读性强、设计清晰简单等优点。</p>
<p>最终从源码到机器码的流程如下（以 Clang 做编译器为例）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150029.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150029.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150029.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150029.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906150029.png"
        title="20210906150020" /></p>
<p>（LLVM Pass 是一些中间过程处理 IR 的可以用户自定义的内容，可以用来遍历、修改 IR 以达到插桩、优化、静态分析等目的。）</p>
<p>代码首先由编译器前端clang处理后得到中间代码IR，然后经过各 LLVM Pass 进行优化和转换，最终交给编译器后端生成机器码。</p>
<h3 id="二-afl的afl-clang-fast">（二）、 AFL的afl-clang-fast</h3>
<h4 id="1-概述-2">1. 概述</h4>
<p>AFL的 <code>llvm_mode</code> 可以实现编译器级别的插桩，可以替代 <code>afl-gcc</code> 或 <code>afl-clang</code> 使用的比较“粗暴”的汇编级别的重写的方法，且具备如下几个优势：</p>
<ol>
<li>编译器可以进行很多优化以提升效率；</li>
<li>可以实现CPU无关，可以在非 x86 架构上进行fuzz；</li>
<li>可以更好地处理多线程目标。</li>
</ol>
<p>在AFL的 <code>llvm_mode</code> 文件夹下包含3个文件： <code>afl-clang-fast.c</code> ，<code> afl-llvm-pass.so.cc</code>， <code>afl-llvm-rt.o.c</code>。</p>
<p><code>afl-llvm-rt.o.c</code> 文件主要是重写了 <code>afl-as.h</code> 文件中的 <code>main_payload</code> 部分，方便调用；</p>
<p><code>afl-llvm-pass.so.cc</code> 文件主要是当通过 <code>afl-clang-fast</code> 调用 clang 时，这个pass被插入到 LLVM 中，告诉编译器添加与 ``afl-as.h` 中大致等效的代码；</p>
<p><code>afl-clang-fast.c</code> 文件本质上是 clang 的 wrapper，最终调用的还是 clang 。但是与 <code>afl-gcc</code> 一样，会进行一些参数处理。</p>
<p><code>llvm_mode</code> 的插桩思路就是通过编写pass来实现信息记录，对每个基本块都插入探针，具体代码在 <code>afl-llvm-pass.so.cc</code> 文件中，初始化和forkserver操作通过链接完成。</p>
<h4 id="2-源码-2">2. 源码</h4>
<h5 id="1-afl-clang-fastc">1. afl-clang-fast.c</h5>
<h6 id="1-main-函数">1. main 函数</h6>
<p><code>main</code> 函数的全部逻辑如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161113.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161113.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161113.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161113.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161113.png"
        title="image-20210906161113066" /></p>
<p>主要是对 <code>find_obj(), edit_params(), execvp()</code> 函数的调用，</p>
<p>其中主要有以下三个函数的调用：</p>
<ul>
<li><code>find_obj(argv[0])</code>：查找运行时library</li>
<li><code>edit_params(argc, argv)</code>：处理传入的编译参数，将确定好的参数放入 <code>cc_params[]</code> 数组</li>
<li><code>execvp(cc_params[0], (cahr**)cc_params)</code>：替换进程空间，传递参数，执行要调用的clang</li>
</ul>
<p>这里后两个函数的作用与 <code>afl-gcc.c</code> 中的作用基本相同，只是对参数的处理过程存在不同，不同的主要是 <code>find_obj()</code> 函数。</p>
<h6 id="2-find_obj-函数">2. find_obj 函数</h6>
<p><code>find_obj()</code>函数的控制流逻辑如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161809.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161809.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161809.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161809.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906161809.png"
        title="image-20210906161809903" /></p>
<ul>
<li>首先，读取环境变量 <code>AFL_PATH</code> 的值：
<ul>
<li>如果读取成功，确认 <code>AFL_PATH/afl-llvm-rt.o</code> 是否可以访问；如果可以访问，设置该目录为 <code>obj_path</code> ，然后直接返回；</li>
<li>如果读取失败，检查 <code>arg0</code> 中是否存在 <code>/</code> 字符，如果存在，则判断最后一个 <code>/</code> 前面的路径为 AFL 的根目录；然后读取<code>afl-llvm-rt.o</code>文件，成功读取，设置该目录为 <code>obj_path</code> ，然后直接返回。</li>
</ul>
</li>
<li>如果上面两种方式都失败，到<code>/usr/local/lib/afl</code> 目录下查找是否存在 <code>afl-llvm-rt.o</code> ，如果存在，则设置为 <code>obj_path</code> 并直接返回（之所以向该路径下寻找，是因为默认的AFL的MakeFile在编译时，会定义一个名为<code>AFL_PATH</code>的宏，该宏会指向该路径）；</li>
<li>如果以上全部失败，抛出异常提示找不到 <code>afl-llvm-rt.o</code> 文件或 <code>afl-llvm-pass.so</code> 文件，并要求设置 <code>AFL_PATH</code> 环境变量 。</li>
</ul>
<p>函数的主要功能是在寻找AFL的路径以找到 <code>afl-llvm-rt.o</code> 文件，该文件即为要用到的运行时库。</p>
<h6 id="3-edit_params-函数">3. edit_params 函数</h6>
<p>该函数的主要作用仍然为编辑参数数组，其控制流程如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210927175503.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210927175503.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210927175503.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210927175503.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210927175503.png"
        title="20210927175503" /></p>
<ul>
<li>
<p>首先，判断执行的是否为 <code>afl-clang-fast++</code> ：</p>
<ul>
<li>如果是，设置 <code>cc_params[0]</code> 为环境变量 <code>AFL_CXX</code>；如果环境变量为空，则设置为 <code>clang++</code> ；</li>
<li>如果不是，设置 <code>cc_params[0]</code> 为环境变量 <code>AFL_CC</code>；如果环境变量为空，则设置为 <code>clang</code> ；</li>
</ul>
</li>
<li>
<p>判断是否定义了 <code>USE_TRACE_PC</code> 宏，如果有，添加 <code>-fsanitize-coverage=trace-pc-guard -mllvm(only Android) -sanitizer-coverage-block-threshold=0(only Android)</code> 选项到参数数组；如果没有，依次将 <code>-Xclang -load -Xclang obj_path/afl-llvm-pass.so -Qunused-arguments</code> 选项添加到参数数组；（这里涉及到llvm_mode使用的2种插桩方式：默认使用的是传统模式，使用 <code>afl-llvm-pass.so</code> 注入来进行插桩，这种方式较为稳定；另外一种是处于实验阶段的方式——<code>trace-pc-guard</code> 模式，对于该模式的详细介绍可以参考<a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards" target="_blank" rel="noopener noreffer">llvm相关文档——tracing-pcs-with-guards</a>）</p>
</li>
<li>
<p>遍历传递给 <code>afl-clang-fast</code> 的参数，进行一定的检查和设置，并添加到 <code>cc_params</code> 数组：</p>
<ul>
<li>如果存在 <code>-m32</code> 或 <code>armv7a-linux-androideabi</code> ，设置 <code>bit_mode</code> 为32；</li>
<li>如果存在 <code>-m64</code> ，设置 <code>bit_mode</code> 为64；</li>
<li>如果存在 <code>-x</code> ，设置 <code>x_set</code> 为1；</li>
<li>如果存在 <code>-fsanitize=address</code> 或 <code>-fsanitize=memory</code>，设置 <code>asan_set</code> 为1；</li>
<li>如果存在 <code>-Wl,-z,defs</code> 或 <code>-Wl,--no-undefined</code>，则直接pass掉。</li>
</ul>
</li>
<li>
<p>检查环境变量是否设置了 <code>AFL_HARDEN</code>：</p>
<ul>
<li>如果有，添加 <code>-fstack-protector-all</code> 选项；</li>
<li>如果有且没有设置 <code>FORTIFY_SOURCE</code> ，添加 <code>-D_FORTIFY_SOURCE=2</code> 选项；</li>
</ul>
</li>
<li>
<p>检查参数中是否存在 <code>-fsanitize=memory</code>，即 <code>asan_set</code> 为0：</p>
<ul>
<li>如果没有，尝试读取环境变量 <code>AFL_USE_ASAN</code>，如果存在，添加 <code>-U_FORTIFY_SOURCE -fsanitize=address</code>；</li>
<li>接下来对环境变量<code>AFL_USE_MSAN</code>的处理方式与 <code>AFL_USE_ASAN</code> 类似，添加的选项为 <code>-U_FORTIFY_SOURCE -fsanitize=memory</code>；</li>
</ul>
</li>
<li>
<p>检查是否定义了 <code>USE_TRACE_PC</code> 宏，如果存在定义，检查是否存在环境变量 <code>AFL_INST_RATIO</code>，如果存在，抛出异常<code>AFL_INST_RATIO </code> 无法在trace-pc时使用；</p>
</li>
<li>
<p>检查环境变量 <code>AFL_NO_BUILTIN</code> ，如果没有设置，添加 <code>-g -O3 -funroll-loops</code>；</p>
</li>
<li>
<p>检查环境变量 <code>AFL_NO_BUILTIN</code>，如果进行了设置，添加 <code>-fno-builtin-strcmp -fno-builtin-strncmp -fno-builtin-strcasecmp -fno-builtin-strcasecmp -fno-builtin-memcmp</code>；</p>
</li>
<li>
<p>添加参数 <code>-D__AFL_HAVE_MANUAL_CONTROL=1 -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code>；</p>
</li>
<li>
<p>定义了两个宏 <code>__AFL_LOOP(), __AFL_INIT()</code>；</p>
</li>
<li>
<p>检查是否设置了 <code>x_set</code>， 如果有添加 <code>-x none</code>；</p>
</li>
<li>
<p>检查是否设置了宏 <code>__ANDORID__</code> ，如果没有，判断 <code>bit_mode</code> 的值：</p>
<ul>
<li>如果为0，即没有<code>-m32</code>和<code>-m64</code>，添加 <code>obj_path/afl-llvm-rt.o</code> ；</li>
<li>如果为32，添加 <code>obj_path/afl-llvm-rt-32.o</code> ；</li>
<li>如果为64，添加 <code>obj_path/afl-llvm-rt-64.o</code> 。</li>
</ul>
</li>
</ul>
<h5 id="2-afl-llvm-passsocc">2. afl-llvm-pass.so.cc</h5>
<p><code>afl-llvm-pass.so.cc</code> 文件实现了 LLVM-mode 下的一个插桩 LLVM Pass。</p>
<p>本文不过多关心如何实现一个LLVM Pass，重点分析该pass的实现逻辑。</p>
<p>该文件只有一个Transform pass：<code> AFLCoverage</code>，继承自 <code>ModulePass</code>，实现了一个 <code>runOnModule</code> 函数，这也是我们需要重点分析的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">namespace</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">AFLCoverage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ModulePass</span> <span class="p">{</span>

    <span class="k">public</span><span class="o">:</span>

      <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
      <span class="n">AFLCoverage</span><span class="p">()</span> <span class="o">:</span> <span class="n">ModulePass</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

      <span class="kt">bool</span> <span class="nf">runOnModule</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

      <span class="c1">// StringRef getPassName() const override {
</span><span class="c1"></span>      <span class="c1">//  return &#34;American Fuzzy Lop Instrumentation&#34;;
</span><span class="c1"></span>      <span class="c1">// }
</span><span class="c1"></span>
  <span class="p">};</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h6 id="1-pass注册">1. pass注册</h6>
<p>对pass进行注册的部分源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="kt">void</span> <span class="nf">registerAFLPass</span><span class="p">(</span><span class="k">const</span> <span class="n">PassManagerBuilder</span> <span class="o">&amp;</span><span class="p">,</span>
                            <span class="n">legacy</span><span class="o">::</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">PM</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">new</span> <span class="n">AFLCoverage</span><span class="p">());</span>

<span class="p">}</span>


<span class="k">static</span> <span class="n">RegisterStandardPasses</span> <span class="nf">RegisterAFLPass</span><span class="p">(</span>
    <span class="n">PassManagerBuilder</span><span class="o">::</span><span class="n">EP_ModuleOptimizerEarly</span><span class="p">,</span> <span class="n">registerAFLPass</span><span class="p">);</span>

<span class="k">static</span> <span class="n">RegisterStandardPasses</span> <span class="nf">RegisterAFLPass0</span><span class="p">(</span>
    <span class="n">PassManagerBuilder</span><span class="o">::</span><span class="n">EP_EnabledOnOptLevel0</span><span class="p">,</span> <span class="n">registerAFLPass</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>其核心功能为向PassManager注册新的pass，每个pass相互独立。</p>
<p>对于pass注册的细节部分请读者自行研究llvm的相关内容。</p>
<h6 id="2-runonmodule-函数">2. runOnModule 函数</h6>
<p>该函数为该文件中的关键函数，其控制流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906194523.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906194523.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906194523.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906194523.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210906194523.png"
        title="image-20210906194522952" /></p>
<ul>
<li>
<p>首先，通过 <code>getContext()</code> 来获取 <code>LLVMContext</code> ，获取进程上下文：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">C</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>

<span class="n">IntegerType</span> <span class="o">*</span><span class="n">Int8Ty</span>  <span class="o">=</span> <span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt8Ty</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
<span class="n">IntegerType</span> <span class="o">*</span><span class="n">Int32Ty</span> <span class="o">=</span> <span class="n">IntegerType</span><span class="o">::</span><span class="n">getInt32Ty</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>设置插桩密度：读取环境变量 <code>AFL_INST_RATIO</code> ，并赋值给 <code>inst_ratio</code>，其值默认为100，范围为 1～100，该值表示插桩概率；</p>
</li>
<li>
<p>获取只想共享内存shm的指针以及上一个基本块的随机ID：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">GlobalVariable</span> <span class="o">*</span><span class="n">AFLMapPtr</span> <span class="o">=</span>
  <span class="n">new</span> <span class="n">GlobalVariable</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">PointerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Int8Ty</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">false</span><span class="p">,</span>
                     <span class="n">GlobalValue</span><span class="o">::</span><span class="n">ExternalLinkage</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;__afl_area_ptr&#34;</span><span class="p">);</span>

<span class="n">GlobalVariable</span> <span class="o">*</span><span class="n">AFLPrevLoc</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GlobalVariable</span><span class="p">(</span>
  <span class="n">M</span><span class="p">,</span> <span class="n">Int32Ty</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">GlobalValue</span><span class="o">::</span><span class="n">ExternalLinkage</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;__afl_prev_loc&#34;</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="n">GlobalVariable</span><span class="o">::</span><span class="n">GeneralDynamicTLSModel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>进入插桩过程：</p>
<ul>
<li>
<p>通过 <code>for</code> 循环遍历每个BB（基本块），寻找BB中适合插入桩代码的位置，然后通过初始化 <code>IRBuilder</code> 实例执行插入；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">BasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">IP</span> <span class="o">=</span> <span class="n">BB</span><span class="p">.</span><span class="n">getFirstInsertionPt</span><span class="p">();</span>
      <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">IRB</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">IP</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>随机创建当前BB的ID，然后插入load指令，获取前一个BB的ID；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">AFL_R</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">inst_ratio</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 如果大于插桩密度，进行随机插桩
</span><span class="c1"></span>
<span class="cm">/* Make up cur_loc */</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cur_loc</span> <span class="o">=</span> <span class="n">AFL_R</span><span class="p">(</span><span class="n">MAP_SIZE</span><span class="p">);</span>

<span class="n">ConstantInt</span> <span class="o">*</span><span class="n">CurLoc</span> <span class="o">=</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Int32Ty</span><span class="p">,</span> <span class="n">cur_loc</span><span class="p">);</span>  <span class="c1">// 随机创建当前基本块ID
</span><span class="c1"></span>
<span class="cm">/* Load prev_loc */</span>

<span class="n">LoadInst</span> <span class="o">*</span><span class="n">PrevLoc</span> <span class="o">=</span> <span class="n">IRB</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">AFLPrevLoc</span><span class="p">);</span>
<span class="n">PrevLoc</span><span class="o">-&gt;</span><span class="n">setMetadata</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">getMDKindID</span><span class="p">(</span><span class="s">&#34;nosanitize&#34;</span><span class="p">),</span> <span class="n">MDNode</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">None</span><span class="p">));</span>
<span class="n">Value</span> <span class="o">*</span><span class="n">PrevLocCasted</span> <span class="o">=</span> <span class="n">IRB</span><span class="p">.</span><span class="n">CreateZExt</span><span class="p">(</span><span class="n">PrevLoc</span><span class="p">,</span> <span class="n">IRB</span><span class="p">.</span><span class="n">getInt32Ty</span><span class="p">());</span> <span class="c1">// 获取上一个基本块的随机ID
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>插入load指令，获取共享内存的地址，并调用 <code>CreateGEP</code> 函数获取共享内存中指定index的地址；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Load SHM pointer */</span>

<span class="n">LoadInst</span> <span class="o">*</span><span class="n">MapPtr</span> <span class="o">=</span> <span class="n">IRB</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">AFLMapPtr</span><span class="p">);</span>
<span class="n">MapPtr</span><span class="o">-&gt;</span><span class="n">setMetadata</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">getMDKindID</span><span class="p">(</span><span class="s">&#34;nosanitize&#34;</span><span class="p">),</span> <span class="n">MDNode</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">None</span><span class="p">));</span>
<span class="n">Value</span> <span class="o">*</span><span class="n">MapPtrIdx</span> <span class="o">=</span>
  <span class="n">IRB</span><span class="p">.</span><span class="n">CreateGEP</span><span class="p">(</span><span class="n">MapPtr</span><span class="p">,</span> <span class="n">IRB</span><span class="p">.</span><span class="n">CreateXor</span><span class="p">(</span><span class="n">PrevLocCasted</span><span class="p">,</span> <span class="n">CurLoc</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>插入load指令，获取对应index地址的值；插入add指令加一，然后创建store指令写入新值，并更新共享内存；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Update bitmap */</span>

<span class="n">LoadInst</span> <span class="o">*</span><span class="n">Counter</span> <span class="o">=</span> <span class="n">IRB</span><span class="p">.</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">MapPtrIdx</span><span class="p">);</span>
<span class="n">Counter</span><span class="o">-&gt;</span><span class="n">setMetadata</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">getMDKindID</span><span class="p">(</span><span class="s">&#34;nosanitize&#34;</span><span class="p">),</span> <span class="n">MDNode</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">None</span><span class="p">));</span>
<span class="n">Value</span> <span class="o">*</span><span class="n">Incr</span> <span class="o">=</span> <span class="n">IRB</span><span class="p">.</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">Counter</span><span class="p">,</span> <span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Int8Ty</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="n">IRB</span><span class="p">.</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">Incr</span><span class="p">,</span> <span class="n">MapPtrIdx</span><span class="p">)</span>
        <span class="o">-&gt;</span><span class="n">setMetadata</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">getMDKindID</span><span class="p">(</span><span class="s">&#34;nosanitize&#34;</span><span class="p">),</span> <span class="n">MDNode</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">None</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>右移 <code>cur_loc</code> ，插入store指令，更新 <code>__afl_prev_loc</code>；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span>

<span class="n">StoreInst</span> <span class="o">*</span><span class="n">Store</span> <span class="o">=</span>
  <span class="n">IRB</span><span class="p">.</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Int32Ty</span><span class="p">,</span> <span class="n">cur_loc</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="n">AFLPrevLoc</span><span class="p">);</span>
<span class="n">Store</span><span class="o">-&gt;</span><span class="n">setMetadata</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">getMDKindID</span><span class="p">(</span><span class="s">&#34;nosanitize&#34;</span><span class="p">),</span> <span class="n">MDNode</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">None</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>最后对插桩计数加1；</p>
</li>
<li>
<p>扫描下一个BB，根据设置是否为quiet模式等，并判断 <code>inst_blocks</code> 是否为0，如果为0则说明没有进行插桩；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">be_quiet</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inst_blocks</span><span class="p">)</span> <span class="n">WARNF</span><span class="p">(</span><span class="s">&#34;No instrumentation targets found.&#34;</span><span class="p">);</span>
    <span class="k">else</span> <span class="nf">OKF</span><span class="p">(</span><span class="s">&#34;Instrumented %u locations (%s mode, ratio %u%%)</span><span class="p">.</span><span class="s">&#34;,</span>
             <span class="n">inst_blocks</span><span class="p">,</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;AFL_HARDEN&#34;</span><span class="p">)</span> <span class="o">?</span> <span class="s">&#34;hardened&#34;</span> <span class="o">:</span>
             <span class="p">((</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#34;AFL_USE_ASAN&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;AFL_USE_MSAN&#34;</span><span class="p">))</span> <span class="o">?</span>
              <span class="s">&#34;ASAN/MSAN&#34;</span> <span class="o">:</span> <span class="s">&#34;non-hardened&#34;</span><span class="p">),</span> <span class="n">inst_ratio</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p>整个插桩过程较为清晰，没有冗余动作和代码。</p>
<h5 id="3-afl-llvm-rtoc">3. afl-llvm-rt.o.c</h5>
<p>该文件主要实现了llvm_mode的3个特殊功能：<code>deferred instrumentation, persistent mode,trace-pc-guard mode </code>。</p>
<h6 id="1-deferred-instrumentation">1. deferred instrumentation</h6>
<p>AFL会尝试通过只执行一次目标二进制文件来提升性能，在 <code>main()</code> 之前暂停程序，然后克隆“主”进程获得一个稳定的可进行持续fuzz的目标。简言之，避免目标二进制文件的多次、重复的完整运行，而是采取了一种类似快照的机制。</p>
<p>虽然这种机制可以减少程序运行在操作系统、链接器和libc级别的消耗，但是在面对大型配置文件的解析时，优势并不明显。</p>
<p>在这种情况下，可以将 <code>forkserver</code> 的初始化放在大部分初始化工作完成之后、二进制文件解析之前来进行，这在某些情况下可以提升10倍以上的性能。我们把这种方式称为LLVM模式下的 <code>deferred instrumentation</code>。</p>
<p>首先，在代码中寻找可以进行延迟克隆的合适的、不会破坏原二进制文件的位置，然后添加如下代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifdef __AFL_HAVE_MANUAL_CONTROL
</span><span class="cp"></span>	<span class="n">__AFL_INIT</span><span class="p">();</span>
<span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div><p>以上代码插入，在 <code>afl-clang-fast.c</code> 文件中有说明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="n">cc_params</span><span class="p">[</span><span class="n">cc_par_cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;-D__AFL_INIT()=&#34;</span>
    <span class="s">&#34;do { static volatile char *_A __attribute__((used)); &#34;</span>
    <span class="s">&#34; _A = (char*)</span><span class="se">\&#34;</span><span class="s">&#34;</span> <span class="n">DEFER_SIG</span> <span class="s">&#34;</span><span class="se">\&#34;</span><span class="s">; &#34;</span>
<span class="cp">#ifdef __APPLE__
</span><span class="cp"></span>    <span class="s">&#34;__attribute__((visibility(</span><span class="se">\&#34;</span><span class="s">default</span><span class="se">\&#34;</span><span class="s">))) &#34;</span>
    <span class="s">&#34;void _I(void) __asm__(</span><span class="se">\&#34;</span><span class="s">___afl_manual_init</span><span class="se">\&#34;</span><span class="s">); &#34;</span>
<span class="cp">#else
</span><span class="cp"></span>    <span class="s">&#34;__attribute__((visibility(</span><span class="se">\&#34;</span><span class="s">default</span><span class="se">\&#34;</span><span class="s">))) &#34;</span>
    <span class="s">&#34;void _I(void) __asm__(</span><span class="se">\&#34;</span><span class="s">__afl_manual_init</span><span class="se">\&#34;</span><span class="s">); &#34;</span>
<span class="cp">#endif </span><span class="cm">/* ^__APPLE__ */</span><span class="cp">
</span></code></pre></td></tr></table>
</div>
</div><p><code>__afl_manual_init()</code> 函数实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* This one can be called from user code when deferred forkserver mode
</span><span class="cm">    is enabled. */</span>

<span class="kt">void</span> <span class="nf">__afl_manual_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">static</span> <span class="n">u8</span> <span class="n">init_done</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_done</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">__afl_map_shm</span><span class="p">();</span>
    <span class="n">__afl_start_forkserver</span><span class="p">();</span>
    <span class="n">init_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先，判断是否进行了初始化，没有则调用 <code>__afl_map_shm()</code> 函数进行共享内存初始化。 <code>__afl_map_shm()</code> 函数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* SHM setup. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__afl_map_shm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">u8</span> <span class="o">*</span><span class="n">id_str</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="n">SHM_ENV_VAR</span><span class="p">);</span> <span class="c1">// 读取环境变量 SHM_ENV_VAR 获取id
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id_str</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 成功读取id
</span><span class="c1"></span>
    <span class="n">u32</span> <span class="n">shm_id</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">id_str</span><span class="p">);</span>

    <span class="n">__afl_area_ptr</span> <span class="o">=</span> <span class="n">shmat</span><span class="p">(</span><span class="n">shm_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 获取shm地址，赋给 __afl_area_ptr
</span><span class="c1"></span>
    <span class="cm">/* Whooooops. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">__afl_area_ptr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 异常则退出
</span><span class="c1"></span>
    <span class="cm">/* Write something into the bitmap so that even with low AFL_INST_RATIO,
</span><span class="cm">       our parent doesn&#39;t give up on us. */</span>

    <span class="n">__afl_area_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 进行设置
</span><span class="c1"></span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后，调用 <code>__afl_start_forkserver()</code> 函数开始执行forkserver：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Fork server logic. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__afl_start_forkserver</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">static</span> <span class="n">u8</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
  <span class="n">s32</span> <span class="n">child_pid</span><span class="p">;</span>

  <span class="n">u8</span>  <span class="n">child_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/* Phone home and tell the parent that we&#39;re OK. If parent isn&#39;t there,
</span><span class="cm">     assume we&#39;re not running in forkserver mode and just execute program. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">FORKSRV_FD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 写入4字节到状态管道，通知 fuzzer已准备完成
</span><span class="c1"></span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">u32</span> <span class="n">was_killed</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

    <span class="cm">/* Wait for parent by reading from the pipe. Abort if read fails. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">FORKSRV_FD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">was_killed</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 

    <span class="cm">/* If we stopped the child in persistent mode, but there was a race
</span><span class="cm">       condition and afl-fuzz already issued SIGKILL, write off the old
</span><span class="cm">       process. */</span>
    
	  <span class="c1">// 处于persistent mode且子进程已被killed
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">child_stopped</span> <span class="o">&amp;&amp;</span> <span class="n">was_killed</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">child_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">child_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child_stopped</span><span class="p">)</span> <span class="p">{</span> 

      <span class="cm">/* Once woken up, create a clone of our process. */</span>

      <span class="n">child_pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <span class="c1">// 重新fork
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">child_pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

      <span class="cm">/* In child process: close fds, resume execution. */</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child_pid</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">close</span><span class="p">(</span><span class="n">FORKSRV_FD</span><span class="p">);</span> <span class="c1">// 关闭fd，
</span><span class="c1"></span>        <span class="n">close</span><span class="p">(</span><span class="n">FORKSRV_FD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
  
      <span class="p">}</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

      <span class="cm">/* Special handling for persistent mode: if the child is alive but
</span><span class="cm">         currently stopped, simply restart it with SIGCONT. */</span>
			
      <span class="c1">// 子进程只是暂停，则进行重启
</span><span class="c1"></span>      <span class="n">kill</span><span class="p">(</span><span class="n">child_pid</span><span class="p">,</span> <span class="n">SIGCONT</span><span class="p">);</span>
      <span class="n">child_stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="cm">/* In parent process: write PID to pipe, then wait for child. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">FORKSRV_FD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_pid</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">child_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="n">is_persistent</span> <span class="o">?</span> <span class="nl">WUNTRACED</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="cm">/* In persistent mode, the child stops itself with SIGSTOP to indicate
</span><span class="cm">       a successful run. In this case, we want to wake it up without forking
</span><span class="cm">       again. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">WIFSTOPPED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="n">child_stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Relay wait status to pipe, then loop back. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">FORKSRV_FD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="n">_exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述逻辑可以概括如下：</p>
<ul>
<li>
<p>首先，设置 <code>child_stopped = 0</code>，写入4字节到状态管道，通知fuzzer已准备完成；</p>
</li>
<li>
<p>进入 <code>while</code> ，开启fuzz循环：</p>
<ul>
<li>
<p>调用 <code>read</code> 从控制管道读取4字节，判断子进程是否超时。如果管道内读取失败，发生阻塞，读取成功则表示AFL指示forkserver执行fuzz；</p>
</li>
<li>
<p>如果 <code>child_stopped</code> 为0，则fork出一个子进程执行fuzz，关闭和控制管道和状态管道相关的fd，跳出fuzz循环；</p>
</li>
<li>
<p>如果 <code>child_stopped</code> 为1，在 <code>persistent mode</code> 下进行的特殊处理，此时子进程还活着，只是被暂停了，可以通过<code>kill(child_pid, SIGCONT)</code>来简单的重启，然后设置<code>child_stopped</code>为0；</p>
</li>
<li>
<p>forkserver向状态管道 <code>FORKSRV_FD + 1</code> 写入子进程的pid，然后等待子进程结束；</p>
</li>
<li>
<p><code>WIFSTOPPED(status)</code> 宏确定返回值是否对应于一个暂停子进程，因为在 <code>persistent mode</code> 里子进程会通过 <code>SIGSTOP</code> 信号来暂停自己，并以此指示运行成功，我们需要通过 <code>SIGCONT</code>信号来唤醒子进程继续执行，不需要再进行一次fuzz，设置<code>child_stopped</code>为1；</p>
</li>
<li>
<p>子进程结束后，向状态管道 <code>FORKSRV_FD + 1</code> 写入4个字节，通知AFL本次执行结束。</p>
</li>
</ul>
</li>
</ul>
<p>######2. persistent mode</p>
<p><code>persistent mode</code> 并没有通过fork子进程的方式来执行fuzz。一些库中提供的API是无状态的，或者可以在处理不同输入文件之间进行重置，恢复到之前的状态。执行此类重置时，可以使用一个长期存活的进程来测试多个用例，以这种方式来减少重复的 <code>fork()</code> 调用和操作系统的开销。不得不说，这种思路真的很优秀。</p>
<p>一个基础的框架大概如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>

  <span class="cm">/* Read input data. */</span>
  <span class="cm">/* Call library code to be fuzzed. */</span>
  <span class="cm">/* Reset state. */</span>

<span class="p">}</span>

<span class="cm">/* Exit normally */</span>
</code></pre></td></tr></table>
</div>
</div><p>设置一个 <code>while</code> 循环，并指定循环次数。在每次循环内，首先读取数据，然后调用想fuzz的库代码，然后重置状态，继续循环。（本质上也是一种快照。）</p>
<p>对于循环次数的设置，循环次数控制了AFL从头重新启动过程之前的最大迭代次数，较小的循环次数可以降低内存泄漏类故障的影响，官方建议的数值为1000。（循环次数设置过高可能出现较多意料之外的问题，并不建议设置过高。）</p>
<p>一个 <code>persistent mode</code> 的样例程序如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>

<span class="cm">/* Main entry point. */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>

  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="cm">/* Example-only buffer, you&#39;d replace it with other global or
</span><span class="cm">                    local variables appropriate for your use case. */</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span> <span class="p">{</span>

    <span class="cm">/*** PLACEHOLDER CODE ***/</span>

    <span class="cm">/* STEP 1: 初始化所有变量 */</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>

    <span class="cm">/* STEP 2: 读取输入数据，从文件读入时需要先关闭旧的fd然后重新打开文件*/</span>

    <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>

    <span class="cm">/* STEP 3: 调用待fuzz的code*/</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;f&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;one</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;o&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;two</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;o&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">&#34;three</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;!&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;four</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
            <span class="n">abort</span><span class="p">();</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/*** END PLACEHOLDER CODE ***/</span>

  <span class="p">}</span>

  <span class="cm">/* 循环结束，正常结束。AFL会重启进程，并清理内存、剩余fd等 */</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>宏定义 <code>__AFL_LOOP</code> 内部调用 <code>__afl_persistent_loop</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="n">cc_params</span><span class="p">[</span><span class="n">cc_par_cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;-D__AFL_LOOP(_A)=&#34;</span>
    <span class="s">&#34;({ static volatile char *_B __attribute__((used)); &#34;</span>
    <span class="s">&#34; _B = (char*)</span><span class="se">\&#34;</span><span class="s">&#34;</span> <span class="n">PERSIST_SIG</span> <span class="s">&#34;</span><span class="se">\&#34;</span><span class="s">; &#34;</span>
<span class="cp">#ifdef __APPLE__
</span><span class="cp"></span>    <span class="s">&#34;__attribute__((visibility(</span><span class="se">\&#34;</span><span class="s">default</span><span class="se">\&#34;</span><span class="s">))) &#34;</span>
    <span class="s">&#34;int _L(unsigned int) __asm__(</span><span class="se">\&#34;</span><span class="s">___afl_persistent_loop</span><span class="se">\&#34;</span><span class="s">); &#34;</span>
<span class="cp">#else
</span><span class="cp"></span>    <span class="s">&#34;__attribute__((visibility(</span><span class="se">\&#34;</span><span class="s">default</span><span class="se">\&#34;</span><span class="s">))) &#34;</span>
    <span class="s">&#34;int _L(unsigned int) __asm__(</span><span class="se">\&#34;</span><span class="s">__afl_persistent_loop</span><span class="se">\&#34;</span><span class="s">); &#34;</span>
<span class="cp">#endif </span><span class="cm">/* ^__APPLE__ */</span><span class="cp">
</span><span class="cp"></span>    <span class="s">&#34;_L(_A); })&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>__afl_persistent_loop(unsigned int max_cnt)</code> 的逻辑如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907115818.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907115818.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907115818.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907115818.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907115818.png"
        title="image-20210907115817761" /></p>
<p>结合源码梳理一下其逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* A simplified persistent mode handler, used as explained in README.llvm. */</span>

<span class="kt">int</span> <span class="nf">__afl_persistent_loop</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cnt</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">static</span> <span class="n">u8</span>  <span class="n">first_pass</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">u32</span> <span class="n">cycle_cnt</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">first_pass</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">is_persistent</span><span class="p">)</span> <span class="p">{</span>

      <span class="n">memset</span><span class="p">(</span><span class="n">__afl_area_ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">);</span>
      <span class="n">__afl_area_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">__afl_prev_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cycle_cnt</span>  <span class="o">=</span> <span class="n">max_cnt</span><span class="p">;</span>
    <span class="n">first_pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">is_persistent</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">cycle_cnt</span><span class="p">)</span> <span class="p">{</span>

      <span class="n">raise</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">);</span>

      <span class="n">__afl_area_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">__afl_prev_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

      <span class="n">__afl_area_ptr</span> <span class="o">=</span> <span class="n">__afl_area_initial</span><span class="p">;</span>

    <span class="p">}</span>

  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>首先判读是否为第一次执行循环，如果是第一次：</p>
<ul>
<li>如果 <code>is_persistent</code> 为1，清空 <code>__afl_area_ptr</code>，设置 <code>__afl_area_ptr[0]</code> 为1，<code>__afl_prev_loc</code> 为0；</li>
<li>设置 <code>cycle_cnt</code> 的值为传入的 <code>max_cnt</code> 参数，然后设置 <code>first_pass=0</code> 表示初次循环结束，返回1；</li>
</ul>
</li>
<li>
<p>如果不是第一次执行循环，在 persistent mode 下，且 <code>--cycle_cnt</code> 大于1：</p>
<ul>
<li>
<p>发出信号 <code>SIGSTOP</code> 让当前进程暂停</p>
</li>
<li>
<p>设置 <code>__afl_area_ptr[0]</code> 为1，<code>__afl_prev_loc</code> 为0，然后直接返回1</p>
</li>
<li>
<p>如果 <code>cycle_cnt</code> 为0，设置<code>__afl_area_ptr</code>指向数组 <code>__afl_area_initial</code>。</p>
</li>
</ul>
</li>
<li>
<p>最后返回0</p>
</li>
</ul>
<p>重新总结一下上面的逻辑：</p>
<ul>
<li>第一次执行loop循环，进行初始化，然后返回1，此时满足 <code>while(__AFL_LOOP(1000)</code>， 于是执行一次fuzz，计数器cnt减1，抛出SIGSTOP信号暂停子进程；</li>
<li>第二次执行loop循环，恢复之前暂停的子进程继续执行，并设置 <code>child_stopped</code> 为0。此时相当于重新执行了一次程序，重新对 <code>__afl_prev_loc</code> 进行设置，随后返回1，再次进入 <code>while(_AFL_LOOP(1000))</code> ，执行一次fuzz，计数器cnt减1，抛出SIGSTOP信号暂停子进程；</li>
<li>第1000次执行，计数器cnt此时为0，不再暂停子进程，令 <code>__afl_area_ptr</code> 指向无关数组 <code>__afl_area_initial</code> ，随后子进程结束。</li>
</ul>
<h6 id="3-trace-pc-guard-mode">3. trace-pc-guard mode</h6>
<p>该功能的使用需要设置宏 <code>AFL_TRACE_PC=1</code> ，然后再执行 <code>afl-clang-fast</code> 时传入参数 <code>-fsanitize-coverage=trace-pc-guard</code> 。</p>
<p>该功能的主要特点是会在每个edge插入桩代码，函数 <code>__sanitizer_cov_trace_pc_guard</code> 会在每个edge进行调用，该函数利用函数参数 <code>guard</code> 指针所指向的 <code>uint32</code> 值来确定共享内存上所对应的地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">__sanitizer_cov_trace_pc_guard</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">guard</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__afl_area_ptr</span><span class="p">[</span><span class="o">*</span><span class="n">guard</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>guard</code> 的初始化位于函数 <code>__sanitizer_cov_trace_pc_guard_init</code> 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">__sanitizer_cov_trace_pc_guard_init</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">stop</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">u32</span> <span class="n">inst_ratio</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">u8</span><span class="o">*</span> <span class="n">x</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">stop</span> <span class="o">||</span> <span class="o">*</span><span class="n">start</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">x</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;AFL_INST_RATIO&#34;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">inst_ratio</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inst_ratio</span> <span class="o">||</span> <span class="n">inst_ratio</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">abort</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="o">*</span><span class="p">(</span><span class="n">start</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">MAP_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 这里如果计算stop-start，就是程序里总计的edge数
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">inst_ratio</span><span class="p">)</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">MAP_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">start</span><span class="o">++</span><span class="p">;</span>

  <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="三afl的fuzzer--afl-fuzzc">三、AFL的fuzzer —— afl-fuzz.c</h2>
<h3 id="1-概述-3">1. 、概述</h3>
<p>AFL中最重要的部分便是fuzzer的实现部分——<code>afl_fuzz.c</code> ，其主要作用是通过不断变异测试用例来影响程序的执行路径。该文件代码量在8000行左右，处于篇幅原因，我们不会对每一个函数进行源码级分析，而是按照功能划分，介绍其中的核心函数。该文件属于AFL整个项目的核心中的核心，强烈建议通读该文件。</p>
<p>在介绍源码的同时，会穿插AFL的整体运行过程和设计思路，辅助理解源码的设计思路。</p>
<p>在功能上，可以总体上分为3部分：</p>
<ol>
<li>初始配置：进行fuzz环境配置相关工作</li>
<li>fuzz执行：fuzz的主循环过程</li>
<li>变异策略：测试用例的变异过程和方式</li>
</ol>
<p>我们将按照以上3个功能对其中的关键函数和流程进行分析。</p>
<h3 id="2核心源码分析">2、核心源码分析</h3>
<h4 id="1-初始配置">1. 初始配置</h4>
<h5 id="11-第一个while循环">1.1 第一个while循环</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">((</span><span class="n">opt</span> <span class="o">=</span> <span class="n">getopt</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&#34;+i⭕fⓜ️b:t:T:dnCB:S:M:x:QV&#34;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">...</span> <span class="p">...</span>
</code></pre></td></tr></table>
</div>
</div><p>该循环主要通过 <code>getopt</code> 获取各种环境配置、选项参数等。</p>
<h5 id="12-setup_signal_handlers-函数">1.2 setup_signal_handlers 函数</h5>
<p>调用 <code>sigaction</code> ，注册信号处理函数，设置信号句柄。具体的信号内容如下：</p>
<table>
<thead>
<tr>
<th>信号</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP/SIGINT/SIGTERM</td>
<td>处理各种“stop”情况</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>处理超时的情况</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>处理窗口大小</td>
</tr>
<tr>
<td>SIGUSER1</td>
<td>用户自定义信号，这里定义为skip request</td>
</tr>
<tr>
<td>SIGSTP/SIGPIPE</td>
<td>不是很重要的一些信号，可以不用关心</td>
</tr>
</tbody>
</table>
<h5 id="13-check_asan_opts-函数">1.3 check_asan_opts 函数</h5>
<p>读取环境变量 <code>ASAN_OPTIONS</code> 和 <code>MSAN_OPTIONS</code>，做一些必要性检查。</p>
<h5 id="14-fix_up_sync-函数">1.4 fix_up_sync 函数</h5>
<p>如果通过 <code>-M</code>或者<code>-S</code>指定了 <code>sync_id</code>，则更新 <code>out_dir</code> 和 <code>sync_dir</code> 的值：设置 <code>sync_dir</code> 的值为 <code>out_dir</code>，设置 <code>out_dir</code> 的值为<code>out_dir/sync_id</code>。</p>
<h5 id="15-save_cmdline-函数">1.5 save_cmdline 函数</h5>
<p>copy当前命令行参数，保存。</p>
<h5 id="16--check_if_tty-函数">1.6  check_if_tty 函数</h5>
<p>检查是否在tty终端上面运行：读取环境变量 <code>AFL_NO_UI</code> ，如果存在，设置 <code>not_on_tty</code> 为1，并返回；通过 <code>ioctl</code> 读取window size，如果报错为 <code>ENOTTY</code>，表示当前不在一个tty终端运行，设置 <code>not_on_tty</code>。</p>
<h5 id="17-几个cpu检查相关的函数">1.7 几个CPU检查相关的函数</h5>
<ul>
<li><code>static void get_core_count(void)get_core_count() </code>：获取核心数量</li>
<li><code>check_crash_handling()</code>：确保核心转储不会进入程序</li>
<li><code>check_cpu_governor()</code>：检查CPU管理者</li>
</ul>
<h5 id="18-setup_shm-函数">1.8 <strong>setup_shm</strong> 函数</h5>
<p>该函数用于设置共享内存和 <code>virgin_bits</code>，属于比较重要的函数，这里我们结合源码来解析一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Configure shared memory and virgin_bits. This is called at startup. */</span>

<span class="n">EXP_ST</span> <span class="kt">void</span> <span class="nf">setup_shm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">u8</span><span class="o">*</span> <span class="n">shm_str</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_bitmap</span><span class="p">)</span> <span class="n">memset</span><span class="p">(</span><span class="n">virgin_bits</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">);</span> 
  <span class="c1">// 如果 in_bitmap 为空，调用 memset 初始化数组 virgin_bits[MAP_SIZE] 的每个元素的值为 ‘255’。
</span><span class="c1"></span>
  <span class="n">memset</span><span class="p">(</span><span class="n">virgin_tmout</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">);</span> <span class="c1">// 调用 memset 初始化数组 virgin_tmout[MAP_SIZE] 的每个元素的值为 ‘255’。
</span><span class="c1"></span>  <span class="n">memset</span><span class="p">(</span><span class="n">virgin_crash</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">);</span> <span class="c1">// 调用 memset 初始化数组 virgin_crash[MAP_SIZE] 的每个元素的值为 ‘255’。
</span><span class="c1"></span>
  <span class="n">shm_id</span> <span class="o">=</span> <span class="n">shmget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">,</span> <span class="n">IPC_CREAT</span> <span class="o">|</span> <span class="n">IPC_EXCL</span> <span class="o">|</span> <span class="mo">0600</span><span class="p">);</span>
  <span class="c1">// 调用 shmget 函数分配一块共享内存，并将返回的共享内存标识符保存到 shm_id
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">shm_id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;shmget() failed&#34;</span><span class="p">);</span>

  <span class="n">atexit</span><span class="p">(</span><span class="n">remove_shm</span><span class="p">);</span> <span class="c1">// 注册 atexit handler 为 remove_shm
</span><span class="c1"></span>
  <span class="n">shm_str</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">shm_id</span><span class="p">);</span> <span class="c1">// 创建字符串 shm_str
</span><span class="c1"></span>
  <span class="cm">/* If somebody is asking us to fuzz instrumented binaries in dumb mode,
</span><span class="cm">     we don&#39;t want them to detect instrumentation, since we won&#39;t be sending
</span><span class="cm">     fork server commands. This should be replaced with better auto-detection
</span><span class="cm">     later on, perhaps? */</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumb_mode</span><span class="p">)</span> <span class="n">setenv</span><span class="p">(</span><span class="n">SHM_ENV_VAR</span><span class="p">,</span> <span class="n">shm_str</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
  <span class="c1">// 如果不是dumb_mode，设置环境变量 SHM_ENV_VAR 的值为 shm_str
</span><span class="c1"></span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">shm_str</span><span class="p">);</span>

  <span class="n">trace_bits</span> <span class="o">=</span> <span class="n">shmat</span><span class="p">(</span><span class="n">shm_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// 设置 trace_bits 并初始化为0
</span><span class="c1"></span>  
  <span class="k">if</span> <span class="p">(</span><span class="n">trace_bits</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;shmat() failed&#34;</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里通过 <code>trace_bits</code> 和 <code>virgin_bits</code> 两个 bitmap 来分别记录当前的 tuple 信息及整体 tuple 信息，其中 <code>trace_bits</code> 位于共享内存上，便于进行进程间通信。通过 <code>virgin_tmout</code> 和 <code>virgin_crash</code> 两个 bitmap 来记录 fuzz 过程中出现的所有目标程序超时以及崩溃的 tuple 信息。</p>
<h5 id="19-setup_dirs_fds-函数">1.9 setup_dirs_fds 函数</h5>
<p>该函数用于准备输出文件夹和文件描述符，结合源码进行解析：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">EXP_ST</span> <span class="kt">void</span> <span class="nf">setup_dirs_fds</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">u8</span><span class="o">*</span> <span class="n">tmp</span><span class="p">;</span>
  <span class="n">s32</span> <span class="n">fd</span><span class="p">;</span>

  <span class="n">ACTF</span><span class="p">(</span><span class="s">&#34;Setting up output directories...&#34;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sync_id</span> <span class="o">&amp;&amp;</span> <span class="n">mkdir</span><span class="p">(</span><span class="n">sync_dir</span><span class="p">,</span> <span class="mo">0700</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">)</span>
      <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">sync_dir</span><span class="p">);</span>
  <span class="cm">/* 如果sync_id，且创建sync_dir文件夹并设置权限为0700，如果报错单errno不是 EEXIST ，抛出异常 */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 创建out_dir， 权限为0700
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span> 

    <span class="n">maybe_delete_out_dir</span><span class="p">();</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">in_place_resume</span><span class="p">)</span> <span class="c1">// 创建成功
</span><span class="c1"></span>      <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Resume attempted but old output directory not found&#34;</span><span class="p">);</span>

    <span class="n">out_dir_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span> <span class="c1">// 以只读模式打开，返回fd：out_dir_fd
</span><span class="c1"></span>
<span class="cp">#ifndef __sun
</span><span class="cp"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">out_dir_fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">flock</span><span class="p">(</span><span class="n">out_dir_fd</span><span class="p">,</span> <span class="n">LOCK_EX</span> <span class="o">|</span> <span class="n">LOCK_NB</span><span class="p">))</span>
      <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to flock() output directory.&#34;</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* !__sun */</span><span class="cp">
</span><span class="cp"></span>
  <span class="p">}</span>

  <span class="cm">/* Queue directory for any starting &amp; discovered paths. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/queue&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span> 
  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>  
  <span class="c1">// 创建 out_dir/queue 文件夹，权限为0700
</span><span class="c1"></span>    
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* Top-level directory for queue metadata used for session
</span><span class="cm">     resume and related tasks. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/queue/.state/&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  
  <span class="c1">// 创建 out_dir/queue/.state 文件夹，用于保存session resume 和相关tasks的队列元数据。
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* Directory for flagging queue entries that went through
</span><span class="cm">     deterministic fuzzing in the past. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/queue/.state/deterministic_done/&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* Directory with the auto-selected dictionary entries. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/queue/.state/auto_extras/&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* The set of paths currently deemed redundant. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/queue/.state/redundant_edges/&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* The set of paths showing variable behavior. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/queue/.state/variable_behavior/&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* Sync directory for keeping track of cooperating fuzzers. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sync_id</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/.synced/&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">in_place_resume</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EEXIST</span><span class="p">))</span>
      <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

    <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="cm">/* All recorded crashes. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/crashes&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* All recorded hangs. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/hangs&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mo">0700</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="cm">/* Generally useful file descriptors. */</span>

  <span class="n">dev_null_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/null&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dev_null_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to open /dev/null&#34;</span><span class="p">);</span>

  <span class="n">dev_urandom_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/urandom&#34;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dev_urandom_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to open /dev/urandom&#34;</span><span class="p">);</span>

  <span class="cm">/* Gnuplot output file. */</span>

  <span class="n">tmp</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/plot_data&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>
  <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">O_WRONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="mo">0600</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to create &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
  <span class="n">ck_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

  <span class="n">plot_file</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">plot_file</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;fdopen() failed&#34;</span><span class="p">);</span>

  <span class="n">fprintf</span><span class="p">(</span><span class="n">plot_file</span><span class="p">,</span> <span class="s">&#34;# unix_time, cycles_done, cur_path, paths_total, &#34;</span>
                     <span class="s">&#34;pending_total, pending_favs, map_size, unique_crashes, &#34;</span>
                     <span class="s">&#34;unique_hangs, max_depth, execs_per_sec</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
                     <span class="cm">/* ignore errors */</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数的源码中，开发者对关键位置均做了清楚的注释，很容易理解，不做过多解释。</p>
<h5 id="110-read_testcases-函数">1.10 read_testcases 函数</h5>
<p>该函数会将 <code>in_dir</code> 目录下的测试用例扫描到 <code>queue</code> 中，并且区分该文件是否为经过确定性变异的input，如果是的话跳过，以节省时间。
调用函数 <code>add_to_queue()</code> 将测试用例排成queue队列。该函数会在启动时进行调用。</p>
<h5 id="111-add_to_queue-函数">1.11 add_to_queue 函数</h5>
<p>该函数主要用于将新的test case添加到队列，初始化 <code>fname</code> 文件名称，增加<code>cur_depth</code> 深度，增加 <code>queued_paths</code> 测试用例数量等。</p>
<p>首先，<code>queue_entry</code> 结构体定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">queue_entry</span> <span class="p">{</span>

  <span class="n">u8</span><span class="o">*</span> <span class="n">fname</span><span class="p">;</span>                          <span class="cm">/* File name for the test case      */</span>
  <span class="n">u32</span> <span class="n">len</span><span class="p">;</span>                            <span class="cm">/* Input length                     */</span>

  <span class="n">u8</span>  <span class="n">cal_failed</span><span class="p">,</span>                     <span class="cm">/* Calibration failed?              */</span>
      <span class="n">trim_done</span><span class="p">,</span>                      <span class="cm">/* Trimmed?                         */</span>
      <span class="n">was_fuzzed</span><span class="p">,</span>                     <span class="cm">/* Had any fuzzing done yet?        */</span>
      <span class="n">passed_det</span><span class="p">,</span>                     <span class="cm">/* Deterministic stages passed?     */</span>
      <span class="n">has_new_cov</span><span class="p">,</span>                    <span class="cm">/* Triggers new coverage?           */</span>
      <span class="n">var_behavior</span><span class="p">,</span>                   <span class="cm">/* Variable behavior?               */</span>
      <span class="n">favored</span><span class="p">,</span>                        <span class="cm">/* Currently favored?               */</span>
      <span class="n">fs_redundant</span><span class="p">;</span>                   <span class="cm">/* Marked as redundant in the fs?   */</span>

  <span class="n">u32</span> <span class="n">bitmap_size</span><span class="p">,</span>                    <span class="cm">/* Number of bits set in bitmap     */</span>
      <span class="n">exec_cksum</span><span class="p">;</span>                     <span class="cm">/* Checksum of the execution trace  */</span>

  <span class="n">u64</span> <span class="n">exec_us</span><span class="p">,</span>                        <span class="cm">/* Execution time (us)              */</span>
      <span class="n">handicap</span><span class="p">,</span>                       <span class="cm">/* Number of queue cycles behind    */</span>
      <span class="n">depth</span><span class="p">;</span>                          <span class="cm">/* Path depth                       */</span>

  <span class="n">u8</span><span class="o">*</span> <span class="n">trace_mini</span><span class="p">;</span>                     <span class="cm">/* Trace bytes, if kept             */</span>
  <span class="n">u32</span> <span class="n">tc_ref</span><span class="p">;</span>                         <span class="cm">/* Trace bytes ref count            */</span>

  <span class="k">struct</span> <span class="n">queue_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>           <span class="cm">/* Next element, if any             */</span>
                     <span class="o">*</span><span class="n">next_100</span><span class="p">;</span>       <span class="cm">/* 100 elements ahead               */</span>

<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>然后在函数内部进行的相关操作如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Append new test case to the queue. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_queue</span><span class="p">(</span><span class="n">u8</span><span class="o">*</span> <span class="n">fname</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="n">u8</span> <span class="n">passed_det</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="n">queue_entry</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">ck_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span><span class="p">));</span>
  <span class="c1">// 通过ck_alloc分配一个 queue_entry 结构体，并进行初始化
</span><span class="c1"></span>
  <span class="n">q</span><span class="o">-&gt;</span><span class="n">fname</span>        <span class="o">=</span> <span class="n">fname</span><span class="p">;</span>
  <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span>          <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">q</span><span class="o">-&gt;</span><span class="n">depth</span>        <span class="o">=</span> <span class="n">cur_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">q</span><span class="o">-&gt;</span><span class="n">passed_det</span>   <span class="o">=</span> <span class="n">passed_det</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">max_depth</span><span class="p">)</span> <span class="n">max_depth</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">depth</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">queue_top</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">queue_top</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">queue_top</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

  <span class="p">}</span> <span class="k">else</span> <span class="n">q_prev100</span> <span class="o">=</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">queue_top</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

  <span class="n">queued_paths</span><span class="o">++</span><span class="p">;</span> <span class="c1">// queue计数器加1
</span><span class="c1"></span>  <span class="n">pending_not_fuzzed</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 待fuzz的样例计数器加1
</span><span class="c1"></span>
  <span class="n">cycles_wo_finds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">queued_paths</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">queued_paths</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">q_prev100</span><span class="o">-&gt;</span><span class="n">next_100</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q_prev100</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="n">last_path_time</span> <span class="o">=</span> <span class="n">get_cur_time</span><span class="p">();</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="112-pivot_inputs-函数">1.12 pivot_inputs 函数</h5>
<p>在输出目录中为输入测试用例创建硬链接。</p>
<h5 id="1-13-find_timeout-函数">1. 13 find_timeout 函数</h5>
<p>变量 <code>timeout_given</code> 没有被设置时，会调用到该函数。该函数主要是在没有指定 <code>-t</code> 选项进行 resuming session 时，避免一次次地自动调整超时时间。</p>
<h5 id="114-detect_file_args">1.14 detect_file_args</h5>
<p>识别参数中是否有“@@”，如果有，则替换为 <code>out_dir/.cur_input</code> ，没有则返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Detect @@ in args. */</span>

<span class="n">EXP_ST</span> <span class="kt">void</span> <span class="nf">detect_file_args</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">u32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">u8</span><span class="o">*</span> <span class="n">cwd</span> <span class="o">=</span> <span class="n">getcwd</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cwd</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;getcwd() failed&#34;</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>

    <span class="n">u8</span><span class="o">*</span> <span class="n">aa_loc</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&#34;@@&#34;</span><span class="p">);</span> <span class="c1">// 查找@@
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aa_loc</span><span class="p">)</span> <span class="p">{</span>

      <span class="n">u8</span> <span class="o">*</span><span class="n">aa_subst</span><span class="p">,</span> <span class="o">*</span><span class="n">n_arg</span><span class="p">;</span>

      <span class="cm">/* If we don&#39;t have a file name chosen yet, use a safe default. */</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">out_file</span><span class="p">)</span>
        <span class="n">out_file</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/.cur_input&#34;</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">);</span>

      <span class="cm">/* Be sure that we&#39;re always using fully-qualified paths. */</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">out_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="n">aa_subst</span> <span class="o">=</span> <span class="n">out_file</span><span class="p">;</span>
      <span class="k">else</span> <span class="n">aa_subst</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s/%s&#34;</span><span class="p">,</span> <span class="n">cwd</span><span class="p">,</span> <span class="n">out_file</span><span class="p">);</span> 

      <span class="cm">/* Construct a replacement argv value. */</span>

      <span class="o">*</span><span class="n">aa_loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">n_arg</span> <span class="o">=</span> <span class="n">alloc_printf</span><span class="p">(</span><span class="s">&#34;%s%s%s&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">aa_subst</span><span class="p">,</span> <span class="n">aa_loc</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
      <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_arg</span><span class="p">;</span>
      <span class="o">*</span><span class="n">aa_loc</span> <span class="o">=</span> <span class="sc">&#39;@&#39;</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">out_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="n">ck_free</span><span class="p">(</span><span class="n">aa_subst</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">cwd</span><span class="p">);</span> <span class="cm">/* not tracked */</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="115-check_binary-函数">1.15 check_binary 函数</h5>
<p>检查指定路径要执行的程序是否存在，是否为shell脚本，同时检查elf文件头是否合法及程序是否被插桩。</p>
<h4 id="2-第一遍fuzz">2. 第一遍fuzz</h4>
<h5 id="21-检查">2.1 检查</h5>
<p>调用 <code>get_cur_time()</code> 函数获取开始时间，检查是否处于 <code>qemu_mode</code>。</p>
<h5 id="22-perform_dry_run-函数">2.2 perform_dry_run 函数</h5>
<p>该函数是AFL中的一个关键函数，它会执行 <code>input</code> 文件夹下的预先准备的所有测试用例，生成初始化的 queue 和 bitmap，只对初始输入执行一次。函数控制流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907202050.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907202050.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907202050.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907202050.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907202050.png"
        title="image-20210907201943574" /></p>
<p>下面将结合函数源码进行解析（删除部分非关键代码）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Perform dry run of all test cases to confirm that the app is working as
</span><span class="cm">   expected. This is done only for the initial inputs, and only once. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">perform_dry_run</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="n">queue_entry</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span> <span class="c1">// 创建queue_entry结构体
</span><span class="c1"></span>  <span class="n">u32</span> <span class="n">cal_failures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">u8</span><span class="o">*</span> <span class="n">skip_crashes</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;AFL_SKIP_CRASHES&#34;</span><span class="p">);</span> <span class="c1">// 读取环境变量 AFL_SKIP_CRASHES
</span><span class="c1"></span>
  <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历队列
</span><span class="c1"></span>
    <span class="n">u8</span><span class="o">*</span> <span class="n">use_mem</span><span class="p">;</span>
    <span class="n">u8</span>  <span class="n">res</span><span class="p">;</span>
    <span class="n">s32</span> <span class="n">fd</span><span class="p">;</span>

    <span class="n">u8</span><span class="o">*</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">strrchr</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">ACTF</span><span class="p">(</span><span class="s">&#34;Attempting dry run with &#39;%s&#39;...&#34;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;Unable to open &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">);</span>

    <span class="n">use_mem</span> <span class="o">=</span> <span class="n">ck_alloc_nozero</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span> 

    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">use_mem</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
      <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Short read from &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fname</span><span class="p">);</span> <span class="c1">// 打开q-&gt;fname，读取到分配的内存中
</span><span class="c1"></span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">calibrate_case</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">use_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 调用函数calibrate_case校准测试用例
</span><span class="c1"></span>    <span class="n">ck_free</span><span class="p">(</span><span class="n">use_mem</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stop_soon</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">crash_mode</span> <span class="o">||</span> <span class="n">res</span> <span class="o">==</span> <span class="n">FAULT_NOBITS</span><span class="p">)</span> 
      <span class="n">SAYF</span><span class="p">(</span><span class="n">cGRA</span> <span class="s">&#34;    len = %u, map size = %u, exec speed = %llu us</span><span class="se">\n</span><span class="s">&#34;</span> <span class="n">cRST</span><span class="p">,</span> 
           <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bitmap_size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_us</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 判断res的值
</span><span class="c1"></span>
      <span class="k">case</span> <span class="nl">FAULT_NONE</span><span class="p">:</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">==</span> <span class="n">queue</span><span class="p">)</span> <span class="n">check_map_coverage</span><span class="p">();</span> <span class="c1">// 如果为头结点，调用check_map_coverage评估覆盖率
</span><span class="c1"></span>
        <span class="k">if</span> <span class="p">(</span><span class="n">crash_mode</span><span class="p">)</span> <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Test case &#39;%s&#39; does *NOT* crash&#34;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span> <span class="c1">// 抛出异常
</span><span class="c1"></span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="nl">FAULT_TMOUT</span><span class="p">:</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">timeout_given</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 指定了 -t 选项
</span><span class="c1"></span>
          <span class="cm">/* The -t nn+ syntax in the command line sets timeout_given to &#39;2&#39; and
</span><span class="cm">             instructs afl-fuzz to tolerate but skip queue entries that time
</span><span class="cm">             out. */</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">timeout_given</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">WARNF</span><span class="p">(</span><span class="s">&#34;Test case results in a timeout (skipping)&#34;</span><span class="p">);</span>
            <span class="n">q</span><span class="o">-&gt;</span><span class="n">cal_failed</span> <span class="o">=</span> <span class="n">CAL_CHANCES</span><span class="p">;</span>
            <span class="n">cal_failures</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>

          <span class="n">SAYF</span><span class="p">(...</span> <span class="p">...);</span>

          <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Test case &#39;%s&#39; results in a timeout&#34;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>

        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

          <span class="n">SAYF</span><span class="p">(...</span> <span class="p">...);</span>

          <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Test case &#39;%s&#39; results in a timeout&#34;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>

        <span class="p">}</span>

      <span class="k">case</span> <span class="nl">FAULT_CRASH</span><span class="p">:</span>  

        <span class="k">if</span> <span class="p">(</span><span class="n">crash_mode</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> 

        <span class="k">if</span> <span class="p">(</span><span class="n">skip_crashes</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">WARNF</span><span class="p">(</span><span class="s">&#34;Test case results in a crash (skipping)&#34;</span><span class="p">);</span>
          <span class="n">q</span><span class="o">-&gt;</span><span class="n">cal_failed</span> <span class="o">=</span> <span class="n">CAL_CHANCES</span><span class="p">;</span>
          <span class="n">cal_failures</span><span class="o">++</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mem_limit</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 建议增加内存
</span><span class="c1"></span>
          <span class="n">SAYF</span><span class="p">(...</span> <span class="p">...);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

          <span class="n">SAYF</span><span class="p">(...</span> <span class="p">...);</span>

        <span class="p">}</span>

        <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Test case &#39;%s&#39; results in a crash&#34;</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>

      <span class="k">case</span> <span class="nl">FAULT_ERROR</span><span class="p">:</span>

        <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Unable to execute target application (&#39;%s&#39;)&#34;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

      <span class="k">case</span> <span class="nl">FAULT_NOINST</span><span class="p">:</span> <span class="c1">// 测试用例运行没有路径信息
</span><span class="c1"></span>
        <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;No instrumentation detected&#34;</span><span class="p">);</span>

      <span class="k">case</span> <span class="nl">FAULT_NOBITS</span><span class="p">:</span>  <span class="c1">// 没有出现新路径，判定为无效路径
</span><span class="c1"></span>
        <span class="n">useless_at_start</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_bitmap</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">shuffle_queue</span><span class="p">)</span>
          <span class="n">WARNF</span><span class="p">(</span><span class="s">&#34;No new instrumentation output, test case may be useless.&#34;</span><span class="p">);</span>

        <span class="k">break</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">var_behavior</span><span class="p">)</span> <span class="n">WARNF</span><span class="p">(</span><span class="s">&#34;Instrumentation output varies across runs.&#34;</span><span class="p">);</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 读取下一个queue
</span><span class="c1"></span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cal_failures</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cal_failures</span> <span class="o">==</span> <span class="n">queued_paths</span><span class="p">)</span>
      <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;All test cases time out%s, giving up!&#34;</span><span class="p">,</span>
            <span class="n">skip_crashes</span> <span class="o">?</span> <span class="s">&#34; or crash&#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">);</span>

    <span class="n">WARNF</span><span class="p">(</span><span class="s">&#34;Skipped %u test cases (%0.02f%%) due to timeouts%s.&#34;</span><span class="p">,</span> <span class="n">cal_failures</span><span class="p">,</span>
          <span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">cal_failures</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">queued_paths</span><span class="p">,</span>
          <span class="n">skip_crashes</span> <span class="o">?</span> <span class="s">&#34; or crashes&#34;</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cal_failures</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="n">queued_paths</span><span class="p">)</span>
      <span class="n">WARNF</span><span class="p">(</span><span class="n">cLRD</span> <span class="s">&#34;High percentage of rejected test cases, check settings!&#34;</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="n">OKF</span><span class="p">(</span><span class="s">&#34;All test cases processed.&#34;</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>总结以上流程：</p>
<ol>
<li>进入 <code>while</code> 循环，遍历 <code>input</code> 队列，从队列中取出 <code>q-&gt;fname</code>，读取文件内容到分配的内存中，然后关闭文件；</li>
<li>调用 <code>calibrate_case</code> 函数校准该测试用例；</li>
<li>根据校准的返回值 <code>res</code> ，判断错误类型；</li>
<li>打印错误信息，退出。</li>
</ol>
<h5 id="23-calibrate_case-函数">2.3 calibrate_case 函数</h5>
<p>该函数同样为AFL的一个关键函数，用于新测试用例的校准，在处理输入目录时执行，以便在早期就发现有问题的测试用例，并且在发现新路径时，评估新发现的测试用例的是否可变。该函数在 <code>perform_dry_run</code>，<code>save_if_interesting</code>，<code>fuzz_one</code>，<code>pilot_fuzzing</code>，<code>core_fuzzing</code>函数中均有调用。该函数主要用途是初始化并启动fork server，多次运行测试用例，并用 <code>update_bitmap_score</code> 进行初始的byte排序。</p>
<p>函数控制流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907204007.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907204007.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907204007.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907204007.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210907204007.png"
        title="image-20210907203020918" /></p>
<p>结合源码进行解读如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Calibrate a new test case. This is done when processing the input directory
</span><span class="cm">   to warn about flaky or otherwise problematic test cases early on; and when
</span><span class="cm">   new paths are discovered to detect variable behavior and so on. */</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">calibrate_case</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">queue_entry</span><span class="o">*</span> <span class="n">q</span><span class="p">,</span> <span class="n">u8</span><span class="o">*</span> <span class="n">use_mem</span><span class="p">,</span>
                         <span class="n">u32</span> <span class="n">handicap</span><span class="p">,</span> <span class="n">u8</span> <span class="n">from_queue</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">static</span> <span class="n">u8</span> <span class="n">first_trace</span><span class="p">[</span><span class="n">MAP_SIZE</span><span class="p">];</span> <span class="c1">// 创建 firts_trace[MAP_SIZE]
</span><span class="c1"></span>
  <span class="n">u8</span>  <span class="n">fault</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var_detected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hnb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="n">first_run</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_cksum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 获取执行追踪结果，判断case是否为第一次运行，若为0则表示第一次运行，来自input文件夹
</span><span class="c1"></span>
  <span class="n">u64</span> <span class="n">start_us</span><span class="p">,</span> <span class="n">stop_us</span><span class="p">;</span>

  <span class="n">s32</span> <span class="n">old_sc</span> <span class="o">=</span> <span class="n">stage_cur</span><span class="p">,</span> <span class="n">old_sm</span> <span class="o">=</span> <span class="n">stage_max</span><span class="p">;</span>
  <span class="n">u32</span> <span class="n">use_tmout</span> <span class="o">=</span> <span class="n">exec_tmout</span><span class="p">;</span>
  <span class="n">u8</span><span class="o">*</span> <span class="n">old_sn</span> <span class="o">=</span> <span class="n">stage_name</span><span class="p">;</span> <span class="c1">// 保存原有 stage_cur, stage_max, stage_name
</span><span class="c1"></span>
  <span class="cm">/* Be a bit more generous about timeouts when resuming sessions, or when
</span><span class="cm">     trying to calibrate already-added finds. This helps avoid trouble due
</span><span class="cm">     to intermittent latency. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">from_queue</span> <span class="o">||</span> <span class="n">resuming_fuzz</span><span class="p">)</span> 
    <span class="c1">// 如果from_queue为0（表示case不是来自queue）或者resuming_fuzz为1（表示处于resuming sessions）
</span><span class="c1"></span>    <span class="n">use_tmout</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">exec_tmout</span> <span class="o">+</span> <span class="n">CAL_TMOUT_ADD</span><span class="p">,</span>
                    <span class="n">exec_tmout</span> <span class="o">*</span> <span class="n">CAL_TMOUT_PERC</span> <span class="o">/</span> <span class="mi">100</span><span class="p">);</span> <span class="c1">// 提升 use_tmout 的值
</span><span class="c1"></span>
  <span class="n">q</span><span class="o">-&gt;</span><span class="n">cal_failed</span><span class="o">++</span><span class="p">;</span>

  <span class="n">stage_name</span> <span class="o">=</span> <span class="s">&#34;calibration&#34;</span><span class="p">;</span> <span class="c1">// 设置 stage_name
</span><span class="c1"></span>  <span class="n">stage_max</span>  <span class="o">=</span> <span class="n">fast_cal</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="n">CAL_CYCLES</span><span class="p">;</span> <span class="c1">// 设置 stage_max，新测试用例的校准周期数
</span><span class="c1"></span>
  <span class="cm">/* Make sure the fork server is up before we do anything, and let&#39;s not
</span><span class="cm">     count its spin-up time toward binary calibration. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dumb_mode</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">no_fork</span> <span class="n">server</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">forksrv_pid</span><span class="p">)</span>
    <span class="n">init_fork</span> <span class="n">server</span><span class="p">(</span><span class="n">argv</span><span class="p">);</span> <span class="c1">// 没有运行在dumb_mode，没有禁用fork server，切forksrv_pid为0时，启动fork server
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_cksum</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 判断是否为新case（如果这个queue不是来自input文件夹）
</span><span class="c1"></span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">first_trace</span><span class="p">,</span> <span class="n">trace_bits</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">);</span>
    <span class="n">hnb</span> <span class="o">=</span> <span class="n">has_new_bits</span><span class="p">(</span><span class="n">virgin_bits</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">hnb</span> <span class="o">&gt;</span> <span class="n">new_bits</span><span class="p">)</span> <span class="n">new_bits</span> <span class="o">=</span> <span class="n">hnb</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="n">start_us</span> <span class="o">=</span> <span class="n">get_cur_time_us</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">stage_cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stage_cur</span> <span class="o">&lt;</span> <span class="n">stage_max</span><span class="p">;</span> <span class="n">stage_cur</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 开始执行 calibration stage，总计执行 stage_max 轮
</span><span class="c1"></span>
    <span class="n">u32</span> <span class="n">cksum</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_run</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">stage_cur</span> <span class="o">%</span> <span class="n">stats_update_freq</span><span class="p">))</span> <span class="n">show_stats</span><span class="p">();</span> <span class="c1">// queue不是来自input，第一轮calibration stage执行结束，刷新一次展示界面
</span><span class="c1"></span>
    <span class="n">write_to_testcase</span><span class="p">(</span><span class="n">use_mem</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

    <span class="n">fault</span> <span class="o">=</span> <span class="n">run_target</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">use_tmout</span><span class="p">);</span>

    <span class="cm">/* stop_soon is set by the handler for Ctrl+C. When it&#39;s pressed,
</span><span class="cm">       we want to bail out quickly. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stop_soon</span> <span class="o">||</span> <span class="n">fault</span> <span class="o">!=</span> <span class="n">crash_mode</span><span class="p">)</span> <span class="k">goto</span> <span class="n">abort_calibration</span><span class="p">;</span>
    

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumb_mode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">stage_cur</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">count_bytes</span><span class="p">(</span><span class="n">trace_bits</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// 如果 calibration stage第一次运行，且不在dumb_mode，共享内存中没有任何路径
</span><span class="c1"></span>      <span class="n">fault</span> <span class="o">=</span> <span class="n">FAULT_NOINST</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">abort_calibration</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cksum</span> <span class="o">=</span> <span class="n">hash32</span><span class="p">(</span><span class="n">trace_bits</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">,</span> <span class="n">HASH_CONST</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_cksum</span> <span class="o">!=</span> <span class="n">cksum</span><span class="p">)</span> <span class="p">{</span>

      <span class="n">hnb</span> <span class="o">=</span> <span class="n">has_new_bits</span><span class="p">(</span><span class="n">virgin_bits</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">hnb</span> <span class="o">&gt;</span> <span class="n">new_bits</span><span class="p">)</span> <span class="n">new_bits</span> <span class="o">=</span> <span class="n">hnb</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_cksum</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不等于exec_cksum，表示第一次运行，或在相同参数下，每次执行，cksum不同，表示是一个路径可变的queue
</span><span class="c1"></span>
        <span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">var_bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">first_trace</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">trace_bits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
					<span class="c1">// 从0到MAP_SIZE进行遍历， first_trace[i] != trace_bits[i]，表示发现了可变queue
</span><span class="c1"></span>            <span class="n">var_bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">stage_max</span>    <span class="o">=</span> <span class="n">CAL_CYCLES_LONG</span><span class="p">;</span>

          <span class="p">}</span>

        <span class="p">}</span>

        <span class="n">var_detected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

        <span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_cksum</span> <span class="o">=</span> <span class="n">cksum</span><span class="p">;</span> <span class="c1">// q-&gt;exec_cksum=0，表示第一次执行queue，则设置计算出来的本次执行的cksum
</span><span class="c1"></span>        <span class="n">memcpy</span><span class="p">(</span><span class="n">first_trace</span><span class="p">,</span> <span class="n">trace_bits</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">);</span>

      <span class="p">}</span>

    <span class="p">}</span>

  <span class="p">}</span>

  <span class="n">stop_us</span> <span class="o">=</span> <span class="n">get_cur_time_us</span><span class="p">();</span>

  <span class="n">total_cal_us</span>     <span class="o">+=</span> <span class="n">stop_us</span> <span class="o">-</span> <span class="n">start_us</span><span class="p">;</span>  <span class="c1">// 保存所有轮次的总执行时间
</span><span class="c1"></span>  <span class="n">total_cal_cycles</span> <span class="o">+=</span> <span class="n">stage_max</span><span class="p">;</span> <span class="c1">// 保存总轮次
</span><span class="c1"></span>
  <span class="cm">/* OK, let&#39;s collect some stats about the performance of this test case.
</span><span class="cm">     This is used for fuzzing air time calculations in calculate_score(). */</span>

  <span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_us</span>     <span class="o">=</span> <span class="p">(</span><span class="n">stop_us</span> <span class="o">-</span> <span class="n">start_us</span><span class="p">)</span> <span class="o">/</span> <span class="n">stage_max</span><span class="p">;</span> <span class="c1">// 单次执行时间的平均值
</span><span class="c1"></span>  <span class="n">q</span><span class="o">-&gt;</span><span class="n">bitmap_size</span> <span class="o">=</span> <span class="n">count_bytes</span><span class="p">(</span><span class="n">trace_bits</span><span class="p">);</span> <span class="c1">// 最后一次执行所覆盖的路径数
</span><span class="c1"></span>  <span class="n">q</span><span class="o">-&gt;</span><span class="n">handicap</span>    <span class="o">=</span> <span class="n">handicap</span><span class="p">;</span>
  <span class="n">q</span><span class="o">-&gt;</span><span class="n">cal_failed</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">total_bitmap_size</span> <span class="o">+=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bitmap_size</span><span class="p">;</span> <span class="c1">// 加上queue所覆盖的路径数
</span><span class="c1"></span>  <span class="n">total_bitmap_entries</span><span class="o">++</span><span class="p">;</span>

  <span class="n">update_bitmap_score</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>

  <span class="cm">/* If this case didn&#39;t result in new output from the instrumentation, tell
</span><span class="cm">     parent. This is a non-critical problem, but something to warn the user
</span><span class="cm">     about. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dumb_mode</span> <span class="o">&amp;&amp;</span> <span class="n">first_run</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fault</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">new_bits</span><span class="p">)</span> <span class="n">fault</span> <span class="o">=</span> <span class="n">FAULT_NOBITS</span><span class="p">;</span>

<span class="nl">abort_calibration</span><span class="p">:</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">new_bits</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">has_new_cov</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">has_new_cov</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">queued_with_cov</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Mark variable paths. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">var_detected</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// queue是可变路径
</span><span class="c1"></span>
    <span class="n">var_byte_count</span> <span class="o">=</span> <span class="n">count_bytes</span><span class="p">(</span><span class="n">var_bytes</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">var_behavior</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">mark_as_variable</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
      <span class="n">queued_variable</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">}</span>
	
  <span class="c1">// 恢复之前的stage值
</span><span class="c1"></span>  <span class="n">stage_name</span> <span class="o">=</span> <span class="n">old_sn</span><span class="p">;</span>
  <span class="n">stage_cur</span>  <span class="o">=</span> <span class="n">old_sc</span><span class="p">;</span>
  <span class="n">stage_max</span>  <span class="o">=</span> <span class="n">old_sm</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_run</span><span class="p">)</span> <span class="n">show_stats</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">fault</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>总结以上过程如下：</p>
<ol>
<li>进行参数设置，包括当前阶段 <code>stage_cur</code>，阶段名称 <code>stage_name</code>，新比特 `new_bit 等初始化;</li>
<li>参数 <code>from_queue</code>，判断case是否在队列中，且是否处于resuming session， 以此设置时间延迟。testcase参数 <code>q-&gt;cal_failed</code> 加1， 是否校准失败参数加1；</li>
<li>判断是否已经启动fork server ，调用函数 <code>init_fork server()</code> ；</li>
<li>拷贝 <code>trace_bits</code> 到 <code>first_trace</code> ，调用 <code>get_cur_time_us()</code> 获取开始时间 <code>start_us</code>；</li>
<li>进入loop循环，该loop循环多次执行testcase，循环次数为8次或者3次；</li>
<li>调用 <code>write_to_testcase</code> 将修改后的数据写入文件进行测试。如果 <code>use_stdin</code> 被清除，取消旧文件链接并创建一个新文件。否则，缩短<code>prog_in_fd</code> ；</li>
<li>调用 <code>run_target</code> 通知fork server可以开始fork并fuzz；</li>
<li>调用 <code>hash32</code> 校验此次运行的 <code>trace_bits</code>，检查是否出现新的情况；</li>
<li>将本次运行的出现 <code>trace_bits</code> 哈希和本次 testcase的 <code>q-&gt;exec_cksum</code>对比。如果发现不同，则调用 <code>has_new_bits</code>函数和总表<code>virgin_bits</code> 对比；</li>
<li>判断 <code>q-&gt;exec_cksum</code> 是否为0，不为0说明不是第一次执行。后面运行如果和前面第一次 <code>trace_bits</code> 结果不同，则需要多运行几次；</li>
<li>loop循环结束；</li>
<li>收集一些关于测试用例性能的统计数据。比如执行时间延迟，校准错误，bitmap大小等等；</li>
<li>调用 <code>update_bitmap_score() </code> 函数对测试用例的每个byte进行排序，用一个 <code>top_rate[]</code> 维护最佳入口；</li>
<li>如果没有从检测中得到 <code>new_bit</code>，则告诉父进程，这是一个无关紧要的问题，但是需要提醒用户。
总结：calibratecase函数到此为止，该函数主要用途是init_fork server；将testcase运行多次；用update_bitmap_score进行初始的byte排序。</li>
</ol>
<h5 id="24-init_forkserve-函数">2.4 init_forkserve 函数</h5>
<p>AFL的fork server机制避免了多次执行 <code>execve()</code> 函数的多次调用，只需要调用一次然后通过管道发送命令即可。该函数主要用于启动APP和它的fork server。函数整体控制流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908115123.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908115123.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908115123.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908115123.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908115123.png"
        title="image-20210908115123089" /></p>
<p>结合源码梳理一下函数流程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">EXP_ST</span> <span class="kt">void</span> <span class="n">init_fork</span> <span class="nf">server</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">static</span> <span class="k">struct</span> <span class="n">itimerval</span> <span class="n">it</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">st_pipe</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ctl_pipe</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
  <span class="n">s32</span> <span class="n">rlen</span><span class="p">;</span>

  <span class="n">ACTF</span><span class="p">(</span><span class="s">&#34;Spinning up the fork server...&#34;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">st_pipe</span><span class="p">)</span> <span class="o">||</span> <span class="n">pipe</span><span class="p">(</span><span class="n">ctl_pipe</span><span class="p">))</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;pipe() failed&#34;</span><span class="p">);</span> 
  <span class="c1">// 检查 st_pipe 和ctl_pipe，在父子进程间进行管道通信，一个用于传递状态，一个用于传递命令
</span><span class="c1"></span>
  <span class="n">forksrv_pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> 
  <span class="c1">// fork进程出一个子进程
</span><span class="c1"></span>  <span class="c1">// 如果fork成功，则现在有父子两个进程
</span><span class="c1"></span>  <span class="c1">// 此时的父进程为fuzzer，子进程则为目标程序进程，也是将来的fork server
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">forksrv_pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;fork() failed&#34;</span><span class="p">);</span> <span class="c1">// fork失败
</span><span class="c1"></span>  
  <span class="c1">// 子进程和父进程都会向下执行，通过pid来使父子进程执行不同的代码
</span><span class="c1"></span>  
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">forksrv_pid</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 子进程执行
</span><span class="c1"></span>
    <span class="k">struct</span> <span class="n">rlimit</span> <span class="n">r</span><span class="p">;</span>

    <span class="cm">/* 中间省略针对OpenBSD的特殊处理 */</span>

    <span class="p">...</span> <span class="p">...</span>
      
    <span class="cm">/* Isolate the process and configure standard descriptors. If out_file is
</span><span class="cm">       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span>
		
    <span class="c1">// 创建守护进程
</span><span class="c1"></span>    <span class="n">setsid</span><span class="p">();</span>
		
    <span class="c1">// 重定向文件描述符1和2到dev_null_fd
</span><span class="c1"></span>    <span class="n">dup2</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">dup2</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		
    <span class="c1">// 如果指定了out_file，则文件描述符0重定向到dev_null_fd，否则重定向到out_fd
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">out_file</span><span class="p">)</span> <span class="p">{</span>

      <span class="n">dup2</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

      <span class="n">dup2</span><span class="p">(</span><span class="n">out_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">close</span><span class="p">(</span><span class="n">out_fd</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="cm">/* Set up control and status pipes, close the unneeded original fds. */</span>
    <span class="c1">// 设置控制和状态管道，关闭不需要的一些文件描述符
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">ctl_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FORKSRV_FD</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;dup2() failed&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">st_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">FORKSRV_FD</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;dup2() failed&#34;</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">ctl_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">ctl_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">st_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">st_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">out_dir_fd</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">dev_urandom_fd</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fileno</span><span class="p">(</span><span class="n">plot_file</span><span class="p">));</span>

    <span class="cm">/* This should improve performance a bit, since it stops the linker from
</span><span class="cm">       doing extra work post-fork(). */</span>
		
    <span class="c1">// 如果没有设置延迟绑定，则进行设置，不使用缺省模式
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#34;LD_BIND_LAZY&#34;</span><span class="p">))</span> <span class="n">setenv</span><span class="p">(</span><span class="s">&#34;LD_BIND_NOW&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* Set sane defaults for ASAN if nothing else specified. */</span>
		
    <span class="c1">// 设置环境变量ASAN_OPTIONS，配置ASAN相关
</span><span class="c1"></span>    <span class="n">setenv</span><span class="p">(</span><span class="s">&#34;ASAN_OPTIONS&#34;</span><span class="p">,</span> <span class="s">&#34;abort_on_error=1:&#34;</span>
                           <span class="s">&#34;detect_leaks=0:&#34;</span>
                           <span class="s">&#34;symbolize=0:&#34;</span>
                           <span class="s">&#34;allocator_may_return_null=1&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* MSAN is tricky, because it doesn&#39;t support abort_on_error=1 at this
</span><span class="cm">       point. So, we do this in a very hacky way. */</span>
		
    <span class="c1">// MSAN相关
</span><span class="c1"></span>    <span class="n">setenv</span><span class="p">(</span><span class="s">&#34;MSAN_OPTIONS&#34;</span><span class="p">,</span> <span class="s">&#34;exit_code=&#34;</span> <span class="n">STRINGIFY</span><span class="p">(</span><span class="n">MSAN_ERROR</span><span class="p">)</span> <span class="s">&#34;:&#34;</span>
                           <span class="s">&#34;symbolize=0:&#34;</span>
                           <span class="s">&#34;abort_on_error=1:&#34;</span>
                           <span class="s">&#34;allocator_may_return_null=1:&#34;</span>
                           <span class="s">&#34;msan_track_origins=0&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		
		<span class="cm">/* 带参数执行目标程序，报错才返回 
</span><span class="cm">			 execv()会替换原有进程空间为目标程序，所以后续执行的都是目标程序。
</span><span class="cm">			 第一个目标程序会进入__afl_maybe_log里的__afl_fork_wait_loop，并充当fork server。
</span><span class="cm">			 在整个过程中，每次要fuzz一次目标程序，都会从这个fork server再fork出来一个子进程去fuzz。
</span><span class="cm">			 因此可以看作是三段式：fuzzer -&gt; fork server -&gt; target子进程
</span><span class="cm">		*/</span>
    <span class="n">execv</span><span class="p">(</span><span class="n">target_path</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="cm">/* Use a distinctive bitmap signature to tell the parent about execv()
</span><span class="cm">       falling through. */</span>
		
    <span class="c1">// 告诉父进程执行失败，结束子进程
</span><span class="c1"></span>    <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">trace_bits</span> <span class="o">=</span> <span class="n">EXEC_FAIL_SIG</span><span class="p">;</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="cm">/* Close the unneeded endpoints. */</span>

  <span class="n">close</span><span class="p">(</span><span class="n">ctl_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">st_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="n">fsrv_ctl_fd</span> <span class="o">=</span> <span class="n">ctl_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 父进程只能发送命令
</span><span class="c1"></span>  <span class="n">fsrv_st_fd</span>  <span class="o">=</span> <span class="n">st_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// 父进程只能读取状态
</span><span class="c1"></span>
  <span class="cm">/* Wait for the fork server to come up, but don&#39;t wait too long. */</span>
	<span class="c1">// 在一定时间内等待fork server启动
</span><span class="c1"></span>  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">((</span><span class="n">exec_tmout</span> <span class="o">*</span> <span class="n">FORK_WAIT_MULT</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">((</span><span class="n">exec_tmout</span> <span class="o">*</span> <span class="n">FORK_WAIT_MULT</span><span class="p">)</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

  <span class="n">setitimer</span><span class="p">(</span><span class="n">ITIMER_REAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">rlen</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fsrv_st_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 从管道里读取4字节数据到status
</span><span class="c1"></span>
  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">setitimer</span><span class="p">(</span><span class="n">ITIMER_REAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="cm">/* If we have a four-byte &#34;hello&#34; message from the server, we&#39;re all set.
</span><span class="cm">     Otherwise, try to figure out what went wrong. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">rlen</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 以读取的结果判断fork server是否成功启动
</span><span class="c1"></span>    <span class="n">OKF</span><span class="p">(</span><span class="s">&#34;All right - fork server is up.&#34;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
	
  <span class="c1">// 子进程启动失败的异常处理相关
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">child_timed_out</span><span class="p">)</span>
    <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Timeout while initializing fork server (adjusting -t may help)&#34;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">forksrv_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;waitpid() failed&#34;</span><span class="p">);</span>
  
   <span class="p">...</span> <span class="p">...</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们结合fuzzer对该函数的调用来梳理完整的流程如下：</p>
<p>启动目标程序进程后，目标程序会运行一个fork server，fuzzer自身并不负责fork子进程，而是通过管道与fork server通信，由fork server来完成fork以及继续执行目标程序的操作。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908165212.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908165212.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908165212.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908165212.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908165212.png"
        title="未命名绘图.drawio" /></p>
<p>对于fuzzer和目标程序之间的通信状态我们可以通过下图来梳理：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908170232.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908170232.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908170232.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908170232.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210908170232.png"
        title="未命名绘图.drawio" /></p>
<p>结合前面的插桩部分一起来看：</p>
<p>首先，<code>afl-fuzz</code> 会创建两个管道：状态管道和控制管道，然后执行目标程序。此时的目标程序的 <code>main()</code> 函数已经被插桩，程序控制流进入 <code>__afl_maybe_log</code> 中。如果fuzz是第一次执行，则此时的程序就成了fork server们之后的目标程序都由该fork server通过fork生成子进程来运行。fuzz进行过程中，fork server会一直执行fork操作，并将子进程的结束状态通过状态管道传递给 <code>afl-fuzz</code>。</p>
<p>（对于fork server的具体操作，在前面插桩部分时已经根据源码进行了说明，可以回顾一下。）</p>
<h5 id="25-run_target-函数">2.5 run_target 函数</h5>
<p>该函数主要执行目标应用程序，并进行超时监控，返回状态信息，被调用的程序会更新 <code>trace_bits[]</code> 。</p>
<p>结合源码进行解释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">u8</span> <span class="nf">run_target</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">static</span> <span class="k">struct</span> <span class="n">itimerval</span> <span class="n">it</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">u32</span> <span class="n">prev_timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">u64</span> <span class="n">exec_ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">u32</span> <span class="n">tb4</span><span class="p">;</span>

  <span class="n">child_timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="cm">/* After this memset, trace_bits[] are effectively volatile, so we
</span><span class="cm">     must prevent any earlier operations from venturing into that
</span><span class="cm">     territory. */</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">trace_bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">);</span> <span class="c1">// 将trace_bits全部置0，清空共享内存
</span><span class="c1"></span>  <span class="n">MEM_BARRIER</span><span class="p">();</span>

  <span class="cm">/* If we&#39;re running in &#34;dumb&#34; mode, we can&#39;t rely on the fork server
</span><span class="cm">     logic compiled into the target program, so we will just keep calling
</span><span class="cm">     execve(). There is a bit of code duplication between here and 
</span><span class="cm">     init_fork server(), but c&#39;est la vie. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dumb_mode</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">no_fork</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果是dumb_mode模式且没有fork server
</span><span class="c1"></span>
    <span class="n">child_pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span> <span class="c1">// 直接fork出一个子进程
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">child_pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;fork() failed&#34;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child_pid</span><span class="p">)</span> <span class="p">{</span>

     <span class="p">...</span> <span class="p">...</span>

      <span class="cm">/* Isolate the process and configure standard descriptors. If out_file is
</span><span class="cm">         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */</span>

      <span class="n">setsid</span><span class="p">();</span>

      <span class="n">dup2</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">dup2</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">out_file</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">dup2</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

        <span class="n">dup2</span><span class="p">(</span><span class="n">out_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">out_fd</span><span class="p">);</span>

      <span class="p">}</span>

      <span class="cm">/* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */</span>

      <span class="n">close</span><span class="p">(</span><span class="n">dev_null_fd</span><span class="p">);</span>
      <span class="n">close</span><span class="p">(</span><span class="n">out_dir_fd</span><span class="p">);</span>
      <span class="n">close</span><span class="p">(</span><span class="n">dev_urandom_fd</span><span class="p">);</span>
      <span class="n">close</span><span class="p">(</span><span class="n">fileno</span><span class="p">(</span><span class="n">plot_file</span><span class="p">));</span>

      <span class="cm">/* Set sane defaults for ASAN if nothing else specified. */</span>

      <span class="n">setenv</span><span class="p">(</span><span class="s">&#34;ASAN_OPTIONS&#34;</span><span class="p">,</span> <span class="s">&#34;abort_on_error=1:&#34;</span>
                             <span class="s">&#34;detect_leaks=0:&#34;</span>
                             <span class="s">&#34;symbolize=0:&#34;</span>
                             <span class="s">&#34;allocator_may_return_null=1&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

      <span class="n">setenv</span><span class="p">(</span><span class="s">&#34;MSAN_OPTIONS&#34;</span><span class="p">,</span> <span class="s">&#34;exit_code=&#34;</span> <span class="n">STRINGIFY</span><span class="p">(</span><span class="n">MSAN_ERROR</span><span class="p">)</span> <span class="s">&#34;:&#34;</span>
                             <span class="s">&#34;symbolize=0:&#34;</span>
                             <span class="s">&#34;msan_track_origins=0&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

      <span class="n">execv</span><span class="p">(</span><span class="n">target_path</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span> <span class="c1">// 让子进程execv执行目标程序
</span><span class="c1"></span>
      <span class="cm">/* Use a distinctive bitmap value to tell the parent about execv()
</span><span class="cm">         falling through. */</span>

      <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">trace_bits</span> <span class="o">=</span> <span class="n">EXEC_FAIL_SIG</span><span class="p">;</span> <span class="c1">// execv执行失败，写入 EXEC_FAIL_SIG
</span><span class="c1"></span>      <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="p">}</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="n">s32</span> <span class="n">res</span><span class="p">;</span>

    <span class="cm">/* In non-dumb mode, we have the fork server up and running, so simply
</span><span class="cm">       tell it to have at it, and then read back PID. */</span>
		
    <span class="c1">// 如果并不是处在dumb_mode模式，说明fork server已经启动了，我们只需要进行
</span><span class="c1"></span>    <span class="c1">// 控制管道的写和状态管道的读即可
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">fsrv_ctl_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev_timed_out</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span> 

      <span class="k">if</span> <span class="p">(</span><span class="n">stop_soon</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">RPFATAL</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s">&#34;Unable to request new process from fork server (OOM?)&#34;</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fsrv_st_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child_pid</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">stop_soon</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">RPFATAL</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s">&#34;Unable to request new process from fork server (OOM?)&#34;</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">child_pid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">FATAL</span><span class="p">(</span><span class="s">&#34;Fork server is misbehaving (OOM?)&#34;</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="cm">/* Configure timeout, as requested by user, then wait for child to terminate. */</span>
  
  
<span class="c1">// 配置超时，等待子进程结束
</span><span class="c1"></span>  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>

  <span class="n">setitimer</span><span class="p">(</span><span class="n">ITIMER_REAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="cm">/* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */</span>
	
  <span class="k">if</span> <span class="p">(</span><span class="n">dumb_mode</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">no_fork</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">child_pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">PFATAL</span><span class="p">(</span><span class="s">&#34;waitpid() failed&#34;</span><span class="p">);</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="n">s32</span> <span class="n">res</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">res</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fsrv_st_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">stop_soon</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">RPFATAL</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s">&#34;Unable to communicate with fork server (OOM?)&#34;</span><span class="p">);</span>

    <span class="p">}</span>

  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WIFSTOPPED</span><span class="p">(</span><span class="n">status</span><span class="p">))</span> <span class="n">child_pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">getitimer</span><span class="p">(</span><span class="n">ITIMER_REAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">);</span>
  <span class="n">exec_ms</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span> <span class="n">timeout</span> <span class="o">-</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span>
                             <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">);</span> <span class="c1">// 计算执行时间
</span><span class="c1"></span>
  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">it</span><span class="p">.</span><span class="n">it_value</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">setitimer</span><span class="p">(</span><span class="n">ITIMER_REAL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">total_execs</span><span class="o">++</span><span class="p">;</span>

  <span class="cm">/* Any subsequent operations on trace_bits must not be moved by the
</span><span class="cm">     compiler below this point. Past this location, trace_bits[] behave
</span><span class="cm">     very normally and do not have to be treated as volatile. */</span>

  <span class="n">MEM_BARRIER</span><span class="p">();</span>

  <span class="n">tb4</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">trace_bits</span><span class="p">;</span>

  <span class="c1">// 分别执行64和32位下的classify_counts，设置trace_bits所在的mem
</span><span class="c1"></span><span class="cp">#ifdef WORD_SIZE_64
</span><span class="cp"></span>  <span class="n">classify_counts</span><span class="p">((</span><span class="n">u64</span><span class="o">*</span><span class="p">)</span><span class="n">trace_bits</span><span class="p">);</span>
<span class="cp">#else
</span><span class="cp"></span>  <span class="n">classify_counts</span><span class="p">((</span><span class="n">u32</span><span class="o">*</span><span class="p">)</span><span class="n">trace_bits</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* ^WORD_SIZE_64 */</span><span class="cp">
</span><span class="cp"></span>
  <span class="n">prev_timed_out</span> <span class="o">=</span> <span class="n">child_timed_out</span><span class="p">;</span>

  <span class="cm">/* Report outcome to caller. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">WIFSIGNALED</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">stop_soon</span><span class="p">)</span> <span class="p">{</span>
		
    <span class="n">kill_signal</span> <span class="o">=</span> <span class="n">WTERMSIG</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">child_timed_out</span> <span class="o">&amp;&amp;</span> <span class="n">kill_signal</span> <span class="o">==</span> <span class="n">SIGKILL</span><span class="p">)</span> <span class="k">return</span> <span class="n">FAULT_TMOUT</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">FAULT_CRASH</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="cm">/* A somewhat nasty hack for MSAN, which doesn&#39;t support abort_on_error and
</span><span class="cm">     must use a special exit code. */</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">uses_asan</span> <span class="o">&amp;&amp;</span> <span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="o">==</span> <span class="n">MSAN_ERROR</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">kill_signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">FAULT_CRASH</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">dumb_mode</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">no_fork</span> <span class="n">server</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">tb4</span> <span class="o">==</span> <span class="n">EXEC_FAIL_SIG</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FAULT_ERROR</span><span class="p">;</span>

  <span class="cm">/* It makes sense to account for the slowest units only if the testcase was run
</span><span class="cm">  under the user defined timeout. */</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">exec_tmout</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">slowest_exec_ms</span> <span class="o">&lt;</span> <span class="n">exec_ms</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">slowest_exec_ms</span> <span class="o">=</span> <span class="n">exec_ms</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">FAULT_NONE</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="26-update_bitmap_score-函数">2.6 update_bitmap_score 函数</h5>
<p>当我们发现一个新路径时，需要判断发现的新路径是否更“favorable”，也就是是否包含最小的路径集合能遍历到所有bitmap中的位，并在之后的fuzz过程中聚焦在这些路径上。</p>
<p>以上过程的第一步是为bitmap中的每个字节维护一个 <code>top_rated[]</code> 的列表，这里会计算究竟哪些位置是更“合适”的，该函数主要实现该过程。</p>
<p>函数的控制流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909111120.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909111120.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909111120.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909111120.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909111120.png"
        title="image-20210909111119930" /></p>
<p>结合源码进行解释：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_bitmap_score</span><span class="p">(</span><span class="k">struct</span> <span class="n">queue_entry</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">u64</span> <span class="n">fav_factor</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">exec_us</span> <span class="o">*</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
  <span class="c1">// 首先计算case的fav_factor，计算方法是执行时间和样例大小的乘积
</span><span class="c1"></span>
  <span class="cm">/* For every byte set in trace_bits[], see if there is a previous winner,
</span><span class="cm">     and how it compares to us. */</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 遍历trace_bits数组
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">trace_bits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 不为0，表示已经被覆盖到的路径
</span><span class="c1"></span>
       <span class="k">if</span> <span class="p">(</span><span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 检查top_rated是否存在
</span><span class="c1"></span>
         <span class="cm">/* Faster-executing or smaller test cases are favored. */</span>

         <span class="k">if</span> <span class="p">(</span><span class="n">fav_factor</span> <span class="o">&gt;</span> <span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">exec_us</span> <span class="o">*</span> <span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 判断哪个计算结果更小
</span><span class="c1"></span>         <span class="c1">// 如果top_rated[i]的更小，则代表它的更优，不做处理，继续遍历下一个路径；
</span><span class="c1"></span>         <span class="c1">// 如果q的更小，就执行以下代码：
</span><span class="c1"></span>   
         <span class="cm">/* Looks like we&#39;re going to win. Decrease ref count for the
</span><span class="cm">            previous winner, discard its trace_bits[] if necessary. */</span>

         <span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">tc_ref</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">ck_free</span><span class="p">(</span><span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">trace_mini</span><span class="p">);</span>
           <span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">trace_mini</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
         <span class="p">}</span>
       <span class="p">}</span>
       <span class="cm">/* Insert ourselves as the new winner. */</span>

       <span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// 设置为当前case
</span><span class="c1"></span>       <span class="n">q</span><span class="o">-&gt;</span><span class="n">tc_ref</span><span class="o">++</span><span class="p">;</span>

       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">trace_mini</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 为空
</span><span class="c1"></span>         <span class="n">q</span><span class="o">-&gt;</span><span class="n">trace_mini</span> <span class="o">=</span> <span class="n">ck_alloc</span><span class="p">(</span><span class="n">MAP_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
         <span class="n">minimize_bits</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">trace_mini</span><span class="p">,</span> <span class="n">trace_bits</span><span class="p">);</span>
       <span class="p">}</span>

       <span class="n">score_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

     <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="3-主循环">3. 主循环</h4>
<h5 id="31-主循环之前">3.1 主循环之前</h5>
<h6 id="311-cull_queue-函数">3.1.1 cull_queue 函数</h6>
<p>在前面讨论的关于case的 <code>top_rated</code> 的计算中，还有一个机制是检查所有的 <code>top_rated[]</code> 条目，然后顺序获取之前没有遇到过的byte的对比分数低的“获胜者”进行标记，标记至少会维持到下一次运行之前。在所有的fuzz步骤中，“favorable”的条目会获得更多的执行时间。</p>
<p>函数的控制流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909141025.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909141025.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909141025.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909141025.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909141025.png"
        title="image-20210909141024743" /></p>
<p>结合源码解析如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="nf">cull_queue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="n">queue_entry</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">u8</span> <span class="n">temp_v</span><span class="p">[</span><span class="n">MAP_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">];</span>
  <span class="n">u32</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dumb_mode</span> <span class="o">||</span> <span class="o">!</span><span class="n">score_changed</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>  <span class="c1">// 如果处于dumb模式或者score没有发生变化（top_rated没有发生变化），直接返回
</span><span class="c1"></span>
  <span class="n">score_changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">temp_v</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">MAP_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
  <span class="c1">// 设置temp_v大小为MAP_SIZE&gt;&gt;3，初始化为0xff，全1，表示还没有被覆盖到，为0表示被覆盖到了。
</span><span class="c1"></span>
  <span class="n">queued_favored</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">pending_favored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 进行队列遍历
</span><span class="c1"></span>    <span class="n">q</span><span class="o">-&gt;</span><span class="n">favored</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 所有元素的favored均设置为0
</span><span class="c1"></span>    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Let&#39;s see if anything in the bitmap isn&#39;t captured in temp_v.
</span><span class="cm">     If yes, and if it has a top_rated[] contender, let&#39;s use it. */</span>
	
  <span class="c1">// i从0到MAP_SIZE进行迭代，筛选出一组队列条目，它们可以覆盖到所有现在已经覆盖的路径
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAP_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">temp_v</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">))))</span> <span class="p">{</span>

      <span class="n">u32</span> <span class="n">j</span> <span class="o">=</span> <span class="n">MAP_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">;</span>

      <span class="cm">/* Remove all bits belonging to the current entry from temp_v. */</span>
			
      <span class="c1">// 从temp_v中，移除所有属于当前current-entry的byte，也就是这个testcase触发了多少path就给tempv标记上
</span><span class="c1"></span>      <span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">--</span><span class="p">)</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">trace_mini</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
          <span class="n">temp_v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">trace_mini</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

      <span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">favored</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">queued_favored</span><span class="o">++</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">top_rated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">was_fuzzed</span><span class="p">)</span> <span class="n">pending_favored</span><span class="o">++</span><span class="p">;</span>

    <span class="p">}</span>

  <span class="n">q</span> <span class="o">=</span> <span class="n">queue</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历队列，不是favored的case（冗余的测试用例）被标记成redundant_edges
</span><span class="c1"></span>    <span class="n">mark_as_redundant</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">favored</span><span class="p">);</span> <span class="c1">// 位置在/queue/.state/redundent_edges中
</span><span class="c1"></span>    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里根据网上公开的一个例子来理解该过程：</p>
<p>现假设有如下tuple和seed信息：</p>
<ul>
<li>
<p><strong>tuple</strong>:  t0, t1, t2, t3, t4</p>
</li>
<li>
<p><strong>seed</strong>: s0, s1, s2</p>
</li>
<li>
<p>初始化 <code>temp_v = [1,1,1,1,1]</code></p>
</li>
<li>
<p>s1可覆盖t2, t3，s2覆盖t0, t1, t4，并且top_rated[0] = s2，top_rated[2]=s1</p>
</li>
</ul>
<p>将按照如下过程进行筛选和判断：</p>
<ol>
<li>首先判断 temp_v[0]=1，说明t0没有被覆盖；</li>
<li>top_rated[0] 存在 (s2) -&gt; 判断s2可以覆盖的范围 -&gt; <code>trace_mini = [1,1,0,0,1]</code>；</li>
<li>更新 <code>temp_v=[0,0,1,1,0]</code>， 标记s2为 &ldquo;favored&rdquo;；</li>
<li>继续判断 temp_v[1]=0，说明t1此时已经被覆盖，跳过；</li>
<li>继续判断 temp_v[2]=1，说明t2没有被覆盖；</li>
<li>top_rated[2] 存在 (s1) -&gt; 判断s1可以覆盖的范围 -&gt; <code>trace_mini=[0,0,1,1,0]</code>；</li>
<li>更新 <code>temp_v=[0,0,0,0,0]</code>，标记s1为 &ldquo;favored&rdquo;；</li>
<li>此时所有tuple都被覆盖，具备&quot;favored&rsquo;标记的为s1, s2，过程结束。</li>
</ol>
<h6 id="312-show_init_stats-函数">3.1.2 show_init_stats 函数</h6>
<p>进入主循环前的准备工作使用的函数之一，主要作用为在处理输入目录的末尾显示统计信息，警告信息以及硬编码的常量；</p>
<h6 id="313-find_start_position-函数">3.1.3 find_start_position 函数</h6>
<p>进入主循环前的准备工作使用的函数之一，主要作用为在resume时，尝试查找要开始的队列的位置。</p>
<h6 id="314-write_stats_file-函数">3.1.4 write_stats_file 函数</h6>
<p>也是准备工作函数之一，主要作用为更新统计信息文件以进行无人值守的监视。</p>
<h6 id="315-save_auto-函数">3.1.5 save_auto 函数</h6>
<p>该函数主要保存自动生成的extras。</p>
<h5 id="32-主循环">3.2 主循环</h5>
<p>这里是seed变异的主循环处理过程，我们将结合流程图和源码进行详细解读。</p>
<p>主循环的控制流程图如下（将while部分单独设置为了一个函数，只看循环部分即可）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909164334.png"
        data-srcset="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909164334.png, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909164334.png 1.5x, https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909164334.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/AlexsanderShaw/BlogImages@main/img/vuln/shebei20210909164334.png"
        title="image-20210909164334608" /></p>
<p>主循环源码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">u8</span> <span class="n">skipped_fuzz</span><span class="p">;</span>

  <span class="n">cull_queue</span><span class="p">();</span> <span class="c1">// 调用cull_queue进行队列精简
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_cur</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果queue_cure为空（所有queue都被执行完一轮）
</span><span class="c1"></span>
    <span class="n">queue_cycle</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 计数器，所有queue执行的轮数
</span><span class="c1"></span>    <span class="n">current_entry</span>     <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cur_skipped_paths</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">queue_cur</span>         <span class="o">=</span> <span class="n">queue</span><span class="p">;</span> <span class="c1">// 准备开始新一轮fuzz
</span><span class="c1"></span>
    <span class="k">while</span> <span class="p">(</span><span class="n">seek_to</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果seek_to不为空
</span><span class="c1"></span>      <span class="n">current_entry</span><span class="o">++</span><span class="p">;</span>
      <span class="n">seek_to</span><span class="o">--</span><span class="p">;</span>
      <span class="n">queue_cur</span> <span class="o">=</span> <span class="n">queue_cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 从seek_to指定的queue项开始执行
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">show_stats</span><span class="p">();</span> <span class="c1">// 刷新展示界面
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">not_on_tty</span><span class="p">)</span> <span class="p">{</span> 
      <span class="n">ACTF</span><span class="p">(</span><span class="s">&#34;Entering queue cycle %llu.&#34;</span><span class="p">,</span> <span class="n">queue_cycle</span><span class="p">);</span>
      <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* If we had a full queue cycle with no new finds, try
</span><span class="cm">         recombination strategies next. */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">queued_paths</span> <span class="o">==</span> <span class="n">prev_queued</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果一轮执行后queue中的case数与执行前一样，表示没有发现新的case
</span><span class="c1"></span>
      <span class="k">if</span> <span class="p">(</span><span class="n">use_splicing</span><span class="p">)</span> <span class="n">cycles_wo_finds</span><span class="o">++</span><span class="p">;</span> <span class="k">else</span> <span class="n">use_splicing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 是否使用splice进行case变异
</span><span class="c1"></span>
    <span class="p">}</span> <span class="k">else</span> <span class="n">cycles_wo_finds</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">prev_queued</span> <span class="o">=</span> <span class="n">queued_paths</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sync_id</span> <span class="o">&amp;&amp;</span> <span class="n">queue_cycle</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;AFL_IMPORT_FIRST&#34;</span><span class="p">))</span>
      <span class="n">sync_fuzzers</span><span class="p">(</span><span class="n">use_argv</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="n">skipped_fuzz</span> <span class="o">=</span> <span class="n">fuzz_one</span><span class="p">(</span><span class="n">use_argv</span><span class="p">);</span> <span class="c1">// 对queue_cur进行一次测试
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stop_soon</span> <span class="o">&amp;&amp;</span> <span class="n">sync_id</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skipped_fuzz</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// 如果skipped_fuzz为0且存在sync_id，表示要进行一次sync
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sync_interval_cnt</span><span class="o">++</span> <span class="o">%</span> <span class="n">SYNC_INTERVAL</span><span class="p">))</span>
      <span class="n">sync_fuzzers</span><span class="p">(</span><span class="n">use_argv</span><span class="p">);</span>

  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stop_soon</span> <span class="o">&amp;&amp;</span> <span class="n">exit_1</span><span class="p">)</span> <span class="n">stop_soon</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">stop_soon</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

  <span class="n">queue_cur</span> <span class="o">=</span> <span class="n">queue_cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">current_entry</span><span class="o">++</span><span class="p">;</span>

<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>总结以上内容，该处该过程整体如下：</p>
<ol>
<li>判断 <code>queue_cur</code> 是否为空，如果是则表示已经完成队列遍历，初始化相关参数，重新开始一轮；</li>
<li>找到queue入口的case，直接跳到该case；</li>
<li>如果一整个队列循环都没新发现，尝试重组策略；</li>
<li>调用关键函数 <code>fuzz_one()</code> 对该case进行fuzz；</li>
<li>上面的变异完成后，AFL会对文件队列的下一个进行变异处理。当队列中的全部文件都变异测试后，就完成了一个”cycle”，这个就是AFL状态栏右上角的”cycles done”。而正如cycle的意思所说，整个队列又会从第一个文件开始，再次进行变异，不过与第一次变异不同的是，这一次就不需要再进行“deterministic fuzzing”了。如果用户不停止AFL，seed文件将会一遍遍的变异下去。</li>
</ol>
<h5 id="33-主循环后">3.3 主循环后</h5>
<h6 id="331-fuzz_one-函数">3.3.1 fuzz_one 函数</h6>
<p>该函数源码在1000多行，出于篇幅原因，我们简要介绍函数的功能。但强烈建议通读该函数源码，</p>
<p>函数主要是从queue中取出entry进行fuzz，成功返回0，跳过或退出的话返回1。</p>
<p>整体过程：</p>
<ol>
<li>根据是否有 <code>pending_favored</code> 和<code>queue_cur</code>的情况，按照概率进行跳过；有<code>pending_favored</code>, 对于已经fuzz过的或者non-favored的有99%的概率跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored；</li>
<li>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case进行测试；</li>
<li>如果测试用例没有修剪过，那么调用函数trim_case对测试用例进行修剪；</li>
<li>修剪完毕之后，使用calculate_score对每个测试用例进行打分；</li>
<li>如果该queue已经完成deterministic阶段，则直接跳到havoc阶段；</li>
<li>deterministic阶段变异4个stage，变异过程中会多次调用函数common_fuzz_stuff函数，保存interesting 的种子：
<ul>
<li>bitflip，按位翻转，1变为0，0变为1</li>
<li>arithmetic，整数加/减算术运算</li>
<li>interest，把一些特殊内容替换到原文件中</li>
<li>dictionary，把自动生成或用户提供的token替换/插入到原文件中</li>
<li>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异。</li>
<li>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件。</li>
</ul>
</li>
<li>该轮完成。</li>
</ol>
<p>这里涉及到AFL中的变异策略，不在本次的讨论中，感兴趣的小伙伴可以结合源码自行进行研究。</p>
<h6 id="332-sync_fuzzers-函数">3.3.2 sync_fuzzers 函数</h6>
<p>该函数的主要作用是进行queue同步，先读取有哪些fuzzer文件夹，然后读取其他fuzzer文件夹下的queue文件夹中的测试用例，然后以此执行。如果在执行过程中，发现这些测试用例可以触发新路径，则将测试用例保存到自己的queue文件夹中，并将最后一个同步的测试用例的id写入到 <code>.synced/fuzzer文件夹名</code> 文件中，避免重复运行。</p>
<h2 id="四总结">四、总结</h2>
<p>分析完源码，可以感受到，AFL遵循的基本原则是简单有效，没有进行过多的复杂的优化，能够针对fuzz领域的痛点，对症下药，拒绝花里胡哨，给出切实可行的解决方案，在漏洞挖掘领域的意义的确非同凡响。后期的很多先进的fuzz工具基本沿用了AFL的思路，甚至目前为止已基本围绕AFL建立了“生态圈”，涉及到多个平台、多种漏洞挖掘对象，对于安全研究员来说实属利器，值得从事fuzz相关工作的研究员下足功夫去体会AFL的精髓所在。</p>
<p>考虑到篇幅限制，我们没有对AFL中的变异策略进行源码说明，实属遗憾。如果有机会，将新开文章详细介绍AFL的变异策略和源码分析。</p>
<h2 id="五参考文献">五、参考文献</h2>
<ol>
<li><a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="noopener noreffer">http://lcamtuf.coredump.cx/afl/</a></li>
<li><a href="https://eternalsakura13.com/2020/08/23/afl/" target="_blank" rel="noopener noreffer">https://eternalsakura13.com/2020/08/23/afl/</a></li>
<li><a href="https://bbs.pediy.com/thread-265936.htm" target="_blank" rel="noopener noreffer">https://bbs.pediy.com/thread-265936.htm</a></li>
<li><a href="https://bbs.pediy.com/thread-249912.htm#msg_header_h3_3" target="_blank" rel="noopener noreffer">https://bbs.pediy.com/thread-249912.htm#msg_header_h3_3</a></li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 0001-01-01</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://www.v4ler1an.com/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" data-title="" data-via="@YaoyaoShaw"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://www.v4ler1an.com/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://www.v4ler1an.com/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" data-title=""><i class="fab fa-hacker-news fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://www.v4ler1an.com/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" data-title=""><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://www.v4ler1an.com/1/01/afl%E4%BA%8C%E4%B8%89%E4%BA%8B4/" data-title="" data-ralateuid="xxxx"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/1/01/fuzzing101-6/" class="prev" rel="prev" title=""><i class="fas fa-angle-left fa-fw"></i></a>
            <a href="/1/01/roarctf/" class="next" rel="next" title=""><i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Something just like this.</div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://www.v4ler1an.com" target="_blank">v4ler1an-有毒</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><script type="text/javascript" src="https://.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"OGG2bwJUUrIOs4sAfU87yE6d-gzGzoHsz","appKey":"vOzsADf7YdkMoNXlgShAFepl","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"人世纷乱，出入平安。","recordIP":true,"visitor":true}},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
